file C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\uLCD-220RD.fnc

000001  000001  #platform "uLCD-220RD"
000002  000001  #platform "uLCD-220RD"
000003  000008  */
000004  000009      #constant ULCD_220RD_DIABLO16_GFX
000005  000009      #constant ULCD_220RD_DIABLO16_GFX
000006  000010        
000007  000011      #IFNOT EXISTS DIABLO16_GFX2_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\Diablo16_Functions.fnc

000008  000012          #inherit "Diablo16_Functions.fnc"          // inherit the generic functions
000009  000012          #inherit "Diablo16_Functions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for Diablo16 platforms
000012  000003  //#constant ULCD_32PT_DIABLO16_GFX
000013  000004        
000014  000005        
000015  000006  // define the compiler dummy preambles
000016  000007  #constant LOCAL $//
000017  000007  #constant LOCAL $//
000018  000008  #constant EXTERN $ /**/
000019  000008  #constant EXTERN $ /**/
000020  000009        
000021  000010  #CONST
000022  000019  #END
000023  000020        
000024  000021  #CONST
000025  000037  #END
000026  000038        
000027  000039        
000028  000040        
000029  000041        
000030  000046  */
000031  000047        
000032  000048        
000033  000049  //------------------------------------------------------------------//
000034  000050  //     EVE  miscellaneous functions                                 //
000035  000051  //------------------------------------------------------------------//
000036  000052        
000037  000053  func to("device"), 0;                // output device redirection
000038  000054  // Syntax: to(outstream);
000039  000055  // Usage : to(APPEND); putstr("TWO ");
000040  000056  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000041  000057  //     :
000042  000058  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000043  000059  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000044  000060  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000045  000061  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000046  000062  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000047  000063  //     : completed its action. The APPEND argument is used to send the printed output to the same
000048  000064  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000049  000065  //     : sequential data to a media stream.
000050  000066  //     :
000051  000067  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000052  000068  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000053  000069  //     :                            appended to user memory if previous redirection was to an array.
000054  000070  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000055  000071  //     : TEXT           0xFF08      Output is directed to the screen (default).
000056  000072  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000057  000073  //     : I2C1           0xF820      Output is directed to the I2C1 port.
000058  000074  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000059  000075        
000060  000076  //------------------------------------------------------------------//
000061  000077  // to(..) redirection constants            //
000062  000078  //------------------------------------------------------------------//
000063  000079  #CONST
000064  000092  #END
000065  000093        
000066  000094        
000067  000095  func putch("char"), 0;                // write single char to current output device
000068  000096  // Syntax    : putch("char");
000069  000097  // Usage     : putch("A");
000070  000098  // Notes     : prints single characters to the current output stream, usually the
000071  000099  //           : display unless redirected with the ‘to’ redirection function.
000072  000100  //         : The arguments can be a variable, array element, expression or constant.
000073  000101        
000074  000102        
000075  000103  func putchXY("xpos", "ypos", "char"), 0;
000076  000104  // Syntax  : putchXY(x, y, '0x41'),
000077  000105  // Usage   : putchXY(100, 100, "HELLO");
000078  000106  // Notes   : Print a single character at position x, y.
000079  000107  //         : Char may be a constant or variable.
000080  000108  // Returns : nothing.
000081  000109        
000082  000110  func putstrXY("xpos", "ypos", "string"), 0;
000083  000111  // Syntax  : putstrXY(x, y, "string"),
000084  000112  // Usage   : putstrXY(100, 100, "HELLO");
000085  000113  // Notes   : Print a string at position x, y
000086  000114  //         : "String" may be a string constant, or pointer to a word aligned string.
000087  000115  // Returns : nothing.
000088  000116        
000089  000117        
000090  000118  func putstrCentred("xc", "yc", "string"), 0;
000091  000119  // Syntax  : putstrCentred(x, y, "string"),
000092  000120  // Usage   : putstrCentred(100, 100, "HELLO");
000093  000121  // Notes   : Print a string centred at position x, y
000094  000122  //         : "String" may be a string constant, or pointer to a word aligned string.
000095  000123  // Returns : nothing.
000096  000124        
000097  000125        
000098  000126  func pause("milliseconds"), 0;            // blocking delay
000099  000127  // Syntax: pause(milliseconds);
000100  000128  // Usage : pause(1000);                //pause for 1 second
000101  000129  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000102  000130        
000103  000131        
000104  000132  func putnum("arg1","arg2"), 1;            // print number to current output device
000105  000133  // Syntax: putnum(format, value);
000106  000134  // Usage : var := putnum(HEX, val);
000107  000135  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000108  000136  //     : Format: A constant that specifies the number format
000109  000137  //     : Value : The number to be printed
000110  000138  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000111  000139  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000112  000140  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000113  000141  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000114  000142  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000115  000143  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000116  000144  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000117  000145  //     :                                     BIN6     BIN6Z     BIN6ZB
000118  000146  //     :                                     BIN7     BIN7Z     BIN7ZB
000119  000147  //     :                                     BIN8     BIN8Z     BIN8ZB
000120  000148  //     :                                     BIN9     BIN9Z     BIN9ZB
000121  000149  //     :                                     BIN10     BIN10Z     BIN10ZB
000122  000150  //     :                                     BIN11     BIN11Z     BIN11ZB
000123  000151  //     :                                     BIN12     BIN12Z     BIN12ZB
000124  000152  //     :                                     BIN13     BIN13Z     BIN13ZB
000125  000153  //     :                                     BIN14     BIN14Z     BIN14ZB
000126  000154  //     :                                     BIN15     BIN15Z     BIN15ZB
000127  000155  //     :                                     BIN16     BIN16Z     BIN16ZB
000128  000156  //     : 
000129  000157  //     : bit 15 Leading spaces (1=space before signed number, 0=No space)
000130  000158  //     : bit 14 sign bit (0=signed, 1=unsigned)
000131  000159  //     : bit 13 Blanking (1=Leading zero blanking, 0=Show Zeros)
000132  000160  //     : bit 12 Leading zeros (1=Zeros included, 0=Zeros suppressed)
000133  000161  //     : bits 11-8 Displayed digit quantity
000134  000162  //     : bits 7-5 Reserved
000135  000163  //     : bits 4-0 Number base (usually 2,10 or 16)
000136  000164        
000137  000165        
000138  000166  func __translate("arg1","arg2","arg3","arg4"), 1; // list translator (*** internal compiler use only, not usable)
000139  000167        
000140  000168        
000141  000169  func putstr("string"), 1;                         // print var (word) aligned string to current output device
000142  000170  // Syntax: putstr(pointer);
000143  000171  // Usage : putstr("HELLO\n");
000144  000172  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000145  000173  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000146  000174  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000147  000175  //       : The output of putstr can be redirected to the communications port, the media, or memory
000148  000176  //       : using the to(...); function.
000149  000177  //       : A string constant is automatically terminated with a zero.
000150  000178  //       : A string in a data statement is not automatically terminated with a zero.
000151  000179  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000152  000180  //       : element packs 1 or 2 characters.
000153  000181        
000154  000182        
000155  000183  func strlen("varAddress"), 1;                   // return length of a var (word) aligned string in character units
000156  000184  // Syntax: strlen("varAddress);
000157  000185  // Usage : strlen("HELLO\n");
000158  000186  // Notes : gives the length of a string that is packed into regular var array
000159  000187  //       : Use str_Length(ptr)  for string pointer mode
000160  000188        
000161  000189        
000162  000190  func charwidth("char"), 1;
000163  000191  // Syntax  : charwidth(char);
000164  000192  // Usage   : wid := charwidth('W');
000165  000193  // Notes   : calculates width of a character in pixel units.
000166  000194  //         : 'char' may be a constant or variable.
000167  000195  // Returns : Width of character in pixel units.
000168  000196        
000169  000197        
000170  000198  func charheight("char"), 1;
000171  000199  // Syntax  : charheight(char);
000172  000200  // Usage   : ht := charheight('0x41');
000173  000201  // Notes   : Calculates height of a character in pixel units.
000174  000202  //         : 'char' may be a constant or variable.
000175  000203  // Returns : Height of character in pixel units.
000176  000204        
000177  000205        
000178  000206  func strwidth("pointer"), 1;
000179  000207  // Syntax  : strwidth(ptr);
000180  000208  // Usage   : x := strwidth("HELLO");
000181  000209  // Notes   : returns width of a string in pixel units.
000182  000210  //         : 'pointer' may be a constant or pointer to word aligned variable
000183  000211  // Returns : Width of string in pixel units, can be multi line.
000184  000212        
000185  000213        
000186  000214  func strheight(), 1;
000187  000215  // Syntax  : strheight();
000188  000216  // Usage   : h := strheight();
000189  000217  // Notes   : calculates height of a string in pixel units (after a call to strwidth );
000190  000218  //         : pointer may be a constant or pointer to word aligned variable
000191  000219  // Returns : Height of string in pixel units, can be multi line.
000192  000220        
000193  000221        
000194  000222  func unicode_page("charbeg","charend","charoffset"), 1;
000195  000223  // Syntax: unicode_page("charbeg","charend","charoffset");
000196  000224  // Usage : eg:  F_Traditional_0x20_0xFF
000197  000225  // Notes : After selecting a unicode image control with txt_FontID,
000198  000226  //       : this function is called to set the required font within the
000199  000227  //       : unicode set. The file "Unicode.inc" contains wrappers for
000200  000228  //       : this function, and it is not normally called directly.
000201  000229  //       : Returns count of characters in the set.
000202  000230  //       : Refer to "Unicode.inc" for further information.
000203  000231        
000204  000232        
000205  000233  //------------------------------------------------------------------//
000206  000234  //          Text Related Functions                                  //
000207  000235  //------------------------------------------------------------------//
000208  000236        
000209  000237  func txt_MoveCursor("line", "column"), 0;
000210  000238  // Syntax: txt_SetCursor(line, column);
000211  000239  // Usage : txt_SetCursor(arg1, arg2);
000212  000240  // Notes : Moves the text Cursor to a new screen position set by
000213  000241  //       : line,column parameters.
000214  000242        
000215  000243  func txt_Set("function", "value"), 0;
000216  000244  // Syntax: txt_Set(function, value);
000217  000245  // Usage : txt_Set(arg1, arg2);
000218  000246  // Returns : Original value before the change
000219  000247  // Notes : Sets various text related parameters used by other functions
000220  000248  //       : This allows the features to be set programatically with a
000221  000249  //       : single function call.It is strongly recommended to use the
000222  000250  //       : pre-defined constants rather than the mode numbers.
000223  000251  //       : NB:- It is often required to be able to set text
000224  000252  //       : functions with a single function call for graphics engine
000225  000253  //       : related functions, however, there is a complete set of single parameter
000226  000254  //       : shortcut functions that have exactly the same function as
000227  000255  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000228  000256  //       :
000229  000257  //       : txt_Set(TEXT_COLOUR, colour);        // function 0, TEXT_COLOUR, default colour = LIME
000230  000258  //       : txt_Set(TEXT_HIGHLIGHT, colour);     // function 1, TEXT_HIGHLIGHT)
000231  000259  //       : txt_Set(FONT_ID, fontNumer);         // function 2, FONT_ID)
000232  000260  //       : txt_Set(TEXT_WIDTH, multiplier);     // function 3, TEXT_WIDTH)
000233  000261  //       : txt_Set(TEXT_HEIGHT, multiplier);    // function 4, TEXT_HEIGHT)
000234  000262  //       : txt_Set(TEXT_XGAP, pixels);          // function 5, TEXT_XGAP)
000235  000263  //       : txt_Set(TEXT_YGAP, pixels);          // function 6, TEXT_YGAP)
000236  000264  //       : txt_Set(TEXT_PRINTDELAY, msecs);     // function 7, TEXT_PRINTDELAY)
000237  000265  //       : txt_Set(TEXT_OPACITY, value);        // function 8, TEXT_OPACITY)
000238  000266  //       : txt_Set(TEXT_BOLD, boldness);        // function 9, TEXT_BOLD)
000239  000267  //       : txt_Set(TEXT_ITALIC, slope);         // function 10, TEXT_ITALIC)
000240  000268  //       : txt_Set(TEXT_INVERSE, onoff);        // function 11, TEXT_INVERSE)
000241  000269  //       : txt_Set(TEXT_UNDERLINED, onoff);     // function 12, TEXT_UNDERLINED)
000242  000270  //       : txt_Set(TEXT_ATTRIBUTES, combine);   // function 13, TEXT_ATTRIBUTES)
000243  000271  //       : txt_Set(TEXT_WRAP, column);          // function 14, TEXT_WRAP)
000244  000272  //       : txt_Set(TEXT_ANGLE , degrees);       // function 15, TEXT_ANGLE)
000245  000273  //       :
000246  000274  //       : txt_Set(TEXT_COLOUR, colour);
000247  000275  //       : mode = TEXT_COLOUR (function 0)
000248  000276  //       : txt_Set(TEXT_COLOUR, value);
000249  000277  //       : value = 0 to 0xFFFF, Black to White
000250  000278  //       : Sets the Text colour for the display
000251  000279  //       : Default = LIME.
000252  000280  //       :
000253  000281  //       : mode = TEXT_HIGHLIGHT (function 1)
000254  000282  //       : txt_Set(TEXT_HIGHLIGHT, value);
000255  000283  //       : value = 0 to 0xFFFF, Black to White
000256  000284  //       : Sets the Text background colour for the display. Effective
000257  000285  //       : when text mode is Opaque.
000258  000286  //       : Default = BLACK.
000259  000287  //       :
000260  000288  //       : mode = FONT_ID (function 2)
000261  000289  //       : txt_Set(FONT_ID, value);
000262  000290  //       : value = FONT1 to FONT11 for internal fonts
000263  000291  //       : else this value is the name of a font included
000264  000292  //       : in a users program in a data statement.
000265  000293  //       : Default = FONT SIZE 3.
000266  000294  //       :
000267  000295  //       : mode = TEXT_WIDTH  (function 3)
000268  000296  //       : txt_Set(TEXT_WIDTH, value);
000269  000297  //       : value = 1 to 16
000270  000298  //       : Sets the Text Width multiplier
000271  000299  //       : text will be printed magnified horizontally
000272  000300  //       : by this factor, Default = 1.
000273  000301  //       :
000274  000302  //       : mode = TEXT_HEIGHT  (function 4)
000275  000303  //       : txt_Set(TEXT_HEIGHT, value);
000276  000304  //       : value = 1 to 16
000277  000305  //       : Sets the Text Height multiplier
000278  000306  //       : text will be printed magnified vertically
000279  000307  //       : by this factor, Default = 1.
000280  000308  //       :
000281  000309  //       : mode = TEXT_XGAP  (function 5)
000282  000310  //       : txt_Set(TEXT_XGAP, value);
000283  000311  //       : value = 1 to 32
000284  000312  //       : Sets the horizontal gap between characters
000285  000313  //       : The gap is in pixel units, Default = 0
000286  000314  //       :
000287  000315  //       : mode = TEXT_YGAP  (function 6)
000288  000316  //       : txt_Set(TEXT_YGAP, value);
000289  000317  //       : value = 1 to 32
000290  000318  //       : Sets the vertical gap below characters
000291  000319  //       : The gap is in pixel units, Default = 0
000292  000320  //       :
000293  000321  //       : mode = TEXT_PRINTDELAY  (function 7) DEPRECATED
000294  000322  //       : txt_Set(TEXT_PRINTDELAY, value);
000295  000323  //       : value = 0 to 255
000296  000324  //       : Sets the delay time (in ms) during character
000297  000325  //       : printing to give a 'teletype' like effect.
000298  000326  //       : Often used to attract attention to a string
000299  000327  //       : being printed which can often be missed if
000300  000328  //       : just suddenly appearing or changing.
000301  000329  //       : Default = 0 ms.
000302  000330  //       :
000303  000331  //       : mode = TEXT_OPACITY (function 8)
000304  000332  //       : txt_Set(TEXT_OPACITY, value);
000305  000333  //       : value = TRANSPARENT (0) = Text Trasparent
000306  000334  //       : value = OPAQUE (1) = Text Opaque
000307  000335  //       : Sets the Opacity/Transparency of the text
000308  000336  //       : Default = 0 or TRANSPARENT
000309  000337  //       :
000310  000338  //       : mode = TEXT_BOLD (function 9)
000311  000339  //       : txt_Set(TEXT_BOLD, value);
000312  000340  //       : value = dont care
000313  000341  //       : Sets Bold Text mode for the next string or char
000314  000342  //       : The feature automatically resets after printing
000315  000343  //       : using putstr or print has completed
000316  000344  //       :
000317  000345  //       : mode = TEXT_ITALIC (function10)
000318  000346  //       : txt_Set(TEXT_ITALIC, value);
000319  000347  //       : value = dont care
000320  000348  //       : Sets Italic Text mode for the next string or char
000321  000349  //       : The feature automatically resets after printing
000322  000350  //       : using putstr or print has completed
000323  000351        
000324  000352  //       : mode = TEXT_INVERSE (function 11)
000325  000353  //       : txt_Set(TEXT_INVERSE, value);
000326  000354  //       : value = dont care
000327  000355  //       : Sets Inverse Text mode for the next string or char
000328  000356  //       : The feature automatically resets after printing
000329  000357  //       : using putstr or print has completed
000330  000358  //       :
000331  000359  //       : mode = TEXT_UNDERLINED (function 12)
000332  000360  //       : txt_Set(TEXT_UNDERLINED, value);
000333  000361  //       : value = dont care
000334  000362  //       : Sets Underlined Text mode for the next string or char
000335  000363  //       : The feature automatically resets after printing
000336  000364  //       : using putstr or print has completed
000337  000365  //       :
000338  000366  //       : mode = TEXT_ATTRIBUTES (function 13)
000339  000367  //       : txt_Set(TEXT_ATTRIBUTES, value);
000340  000368  //       : value = bits are defined as:
000341  000369  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000342  000370  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000343  000371  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000344  000372  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000345  000373  //       : Allows a combination of text attributes to be defined together
000346  000374  //       : by 'or'ing the bits together.
000347  000375  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000348  000376  //       : The feature automatically resets after printing
000349  000377  //       : using putstr or print has completed.
000350  000378  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000351  000379  //       :
000352  000380  //       : mode = TEXT_WRAP (function 14)
000353  000381  //       : txt_Set(TEXT_WRAP , value);
000354  000382  //       : Sets the position where text wrap will occur
000355  000383  //       : The feature automatically resets when screen
000356  000384  //       : mode is changed. If the value is set to 0,
000357  000385  //       : text wrap is turned off.
000358  000386  //       : of the current screen. Default value is 0
000359  000387  // Notes : The value is in pixel units.
000360  000388  //       :
000361  000389  //       : mode = TEXT_ANGLE (function 15)
000362  000390  //       : txt_Set(TEXT_ANGLE , value);
000363  000391  //       : Sets the angle of plotted fonts
000364  000392  // Notes : The angle is in degrees.
000365  000393  //       :
000366  000394        
000367  000395  //------------------------------------------------------------------------------
000368  000396  //txt_Set() related constants
000369  000397  //------------------------------------------------------------------------------
000370  000398  #CONST
000371  000417  #END
000372  000418        
000373  000419  //------------------------------------------------------------------------------
000374  000420  //txt_Set() related arguments
000375  000421  //------------------------------------------------------------------------------
000376  000422  #CONST
000377  000448  #END
000378  000449        
000379  000450        
000380  000451  //=====================================================//
000381  000452  // Single parameter short-cuts                         //
000382  000453  // for the txt_Set functions                           //
000383  000454  // These functions return the existing value before    //
000384  000455  // the change is made.                                 //
000385  000456  //=====================================================//
000386  000457  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000387  000458  func txt_BGcolour("colour"), 1;             // 1  text background colour
000388  000459  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000389  000460  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000390  000461  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000391  000462  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000392  000463  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000393  000464  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000394  000465  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000395  000466  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000396  000467  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000397  000468  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000398  000469  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000399  000470  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000400  000471  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000401  000472  func txt_Angle("value"), 1;                 // 15 text set angle of plotted font
000402  000473        
000403  000474        
000404  000475        
000405  000476  //------------------------------------------------------------------//
000406  000477  // Memory Access Functions                                          //
000407  000478  //------------------------------------------------------------------//
000408  000479                                                  //
000409  000480  func peekW("address"), 1;                       // read a word from system memory
000410  000481  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000411  000482  // refer to address map of internal variables   //
000412  000483        
000413  000484        
000414  000485  //------------------------------------------------------------------//
000415  000486  //        CTYPE Function Prototypes
000416  000487  //------------------------------------------------------------------//
000417  000488        
000418  000489  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
000419  000490  // Syntax: isdigit("char");
000420  000491  // Usage : Var := isdigit(ch);
000421  000492  // Notes : char specifies the ascii character for the test
000422  000493  //     : 0 : char is not an ascii digit.
000423  000494  //     : 1 : char is an ascii digit..
000424  000495  //     : Valid range is "0123456789"
000425  000496        
000426  000497  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
000427  000498  // Syntax: isxdigit("char");
000428  000499  // Usage : Var := isxdigit(ch);
000429  000500  // Notes : char specifies the ascii character for the test
000430  000501  //     : 0 : char is not an ascii hexadecimal digit.
000431  000502  //     : 1 : char is an ascii hexadecimal digit..
000432  000503  //     : Valid range is "0123456789ABCDEF"
000433  000504        
000434  000505  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
000435  000506  // Syntax: isupper("char");
000436  000507  // Usage : Var := isupper(ch);
000437  000508  // Notes : char specifies the ascii character for the test
000438  000509  //     : 0 : char is not an ascii upper-case letter.
000439  000510  //     : 1 : char is an ascii upper-case letter.
000440  000511  //     : Valid range is "ABCD....WXYZ"
000441  000512        
000442  000513  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
000443  000514  // Syntax: islower("char");
000444  000515  // Usage : Var := islower(ch);
000445  000516  // Notes : char specifies the ascii character for the test
000446  000517  //     : 0 : char is not an ascii lower-case letter.
000447  000518  //     : 1 : char is an ascii lower-case letter.
000448  000519  //     : Valid range is "abcd....wxyz"
000449  000520        
000450  000521  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
000451  000522  // Syntax: isalpha("char");
000452  000523  // Usage : Var := isalpha(ch);
000453  000524  // Notes : char specifies the ascii character for the test
000454  000525  //     : 0 : char is not an ascii lower or upper case letter.
000455  000526  //     : 1 : char is an ascii lower or upper case letter.
000456  000527  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
000457  000528        
000458  000529  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
000459  000530  // Syntax: isalnum("char");
000460  000531  // Usage : Var := isalnum(ch);
000461  000532  // Notes : char specifies the ascii character for the test
000462  000533  //     : 0 : char is not an ascii alphanumeric character.
000463  000534  //     : 1 : char is an ascii alphanumeric character.
000464  000535  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
000465  000536        
000466  000537  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
000467  000538  // Syntax: isprint("char");
000468  000539  // Usage : Var := isprint(ch);
000469  000540  // Notes : char specifies the ascii character for the test
000470  000541  //     : 0 : char is not a printable ascii character.
000471  000542  //     : 1 : char is a printable ascii character.
000472  000543  //     : Valid range is "0x20...0x7F"
000473  000544        
000474  000545  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
000475  000546  // Syntax: isspace("char");
000476  000547  // Usage : Var := isspace(ch);
000477  000548  // Notes : char specifies the ascii character for the test
000478  000549  //     : 0 : char is not a space type character.
000479  000550  //     : 1 : char is a space type character.
000480  000551  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
000481  000552        
000482  000553  //unformatted
000483  000554  func iswhite("char"), 1;    //
000484  000555  // Syntax: iswhite("char");
000485  000556  // Usage : Var := iswhite(ch);
000486  000557  // Notes : char specifies the ascii character for the test
000487  000558  //     : 0 : char is not a space or tab character.
000488  000559  //     : 1 : char is not a space or tab character.
000489  000560  //     : Valid range is space or tab
000490  000561        
000491  000562  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
000492  000563  // Syntax: toupper("char");
000493  000564  // Usage : Var := toupper(ch);
000494  000565  // Notes : char specifies the ascii character for the test
000495  000566  //     : "ABCD....XYZ" : if character is a lower case letter.
000496  000567  //     : char : if character is not a lower case letter.
000497  000568  //     : Valid range is "abcd....wxyz"
000498  000569        
000499  000570  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
000500  000571  // Syntax: tolower("char");
000501  000572  // Usage : Var := tolower(ch);
000502  000573  // Notes : char specifies the ascii character for the test
000503  000574  //     : "abcd....xyz" : if character is an upper case letter.
000504  000575  //     : char : if character is not an upper case letter.
000505  000576  //     : Valid range is "ABCD....WXYZ"
000506  000577        
000507  000578  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
000508  000579  // Syntax: LObyte(var);
000509  000580  // Usage : myVar := LObyte(myvar2);
000510  000581  // Notes : var specifies the user variable
000511  000582  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
000512  000583        
000513  000584  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
000514  000585  // Syntax: HIbyte(var);
000515  000586  // Usage : myVar := HIbyte(myvar2);
000516  000587  // Notes : var specifies the user variable
000517  000588  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
000518  000589        
000519  000590        
000520  000591  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
000521  000592  // Syntax: ByteSwap(var);
000522  000593  // Usage : myVar := ByteSwap(myvar2);
000523  000594  // Notes : var specifies the user variable
000524  000595  //     : Returns the endian swapped value of a 16 bit variable
000525  000596        
000526  000597        
000527  000598  func NybleSwap("var"), 1;    //Returns the swapped lower bytes nybles, upper byte retained.
000528  000599  // Syntax: NybleSwap(var);
000529  000600  // Usage : myVar := NybleSwap(myvar2);
000530  000601  // Notes : var specifies the user variable
000531  000602  //     : Returns the 16 bit variable with swapped lower nybles
000532  000603        
000533  000604  func putnumXY("xpos", "ypos", "arg1","arg2"), 1;            // print number at the specified position
000534  000605  // Syntax: putnumXY(x, y, format, value);
000535  000606  // Usage : var := putnumXY(100, 100, HEX, val);
000536  000607  // Notes : prints a 16bit number in various formats at the specified XY coordinates.
000537  000608  //     : Format: A constant that specifies the number format
000538  000609  //     : Value : The number to be printed
000539  000610        
000540  000611  func txt_FontBank("flashbank", "address"), 1;               // use a font located in another bank
000541  000612  // Syntax: txt_FontBank(bank, offset);
000542  000613  // Usage : txt_FontBank(FLASHBANK_2, arg2);
000543  000614  // Returns : Current font before the change, or 0 if invalid or bank is protected
000544  000615  // Notes : Sets the current font to a font held in another bank
000545  000616        
000546  000617  //------------------------------------------------------------------//
000547  000618  // 16bit signed Math Functions                                      //
000548  000619  //------------------------------------------------------------------//
000549  000620                                                  //
000550  000621  func ABS("value"), 1;                           // return a positive number
000551  000622  // Syntax: ABS(value);
000552  000623  // Usage : var := ABS(arg);
000553  000624  // Notes : Returns the absolute value of an argument
000554  000625        
000555  000626  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000556  000627  // Syntax: MIN(value1, value2);
000557  000628  // Usage : var := MIN(arg1, arg2);
000558  000629  // Notes : Returns the minimum of 2 arguments
000559  000630        
000560  000631  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000561  000632  // Syntax: MAX(value1, value2);
000562  000633  // Usage : var := MAX(arg1, arg2);
000563  000634  // Notes : Returns the maximum of 2 arguments
000564  000635        
000565  000636  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000566  000637  // Syntax: SWAP(&var1, &var2);
000567  000638  // Usage : SWAP(&var1, &var2);
000568  000639  // Notes : Swaps the contents of 2 variables or memory locations
000569  000640        
000570  000641  func SIN("angle"), 1;                           // return SIN of angle
000571  000642  // Syntax: SIN(angle);
000572  000643  // Usage : var := SIN(arg);
000573  000644  // Notes : Returns the sine in radians of an argument in degrees
000574  000645  //       : the returned value range is from 127 to -127. The real
000575  000646  //       : cosine values vary from 1.0 to -1.0 so appropriate
000576  000647  //       : scaling must be done in user code.
000577  000648        
000578  000649  func COS("angle"), 1;                           // return COS of angle
000579  000650  // Syntax: COS(angle);
000580  000651  // Usage : var := COS(arg);
000581  000652  // Notes : Returns the cosine in radians of an argument in degrees
000582  000653  //       : the returned value range is from 127 to -127. The real
000583  000654  //       : cosine values vary from 1.0 to -1.0 so appropriate
000584  000655  //       : scaling must be done in user code.
000585  000656        
000586  000657  func RAND(), 1;                                 // return a pseudo random number
000587  000658  // Syntax: RAND();
000588  000659  // Usage : var := RAND();
000589  000660  // Notes : Returns a random number between 0 and 0xFFFF.
000590  000661  //       : The random number generator must first be seeded
000591  000662  //       : by using the SEED(number) function.
000592  000663        
000593  000664  func RANDVAL("low", "high"), 1;                 // return a ranged pseudo random number
000594  000665  // Syntax: RANDVAL("low", "high");
000595  000666  // Usage : var := RANDVAL(low, high);
000596  000667  // Notes : Returns a random number between low and high limits
000597  000668  //       : such that low <= N < high
000598  000669  //       : The random number generator may first be seeded
000599  000670  //       : by using the SEED(number) function.
000600  000671  //       : RANDVAL is the equivalent of aggregate functions:-
000601  000672  //       :     myvar = ABS( (RAND()%(high-low)+low) );
000602  000673  //       : Note that the lower limit is inclusive, but the upper limit is exclusive.
000603  000674        
000604  000675  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000605  000676  // Syntax: SEED(number);
000606  000677  // Usage : SEED(arg);
000607  000678  // Notes : Seeds the random number generator.
000608  000679        
000609  000680  func SQRT("number"), 1;                         // return square root of a number
000610  000681  // Syntax: SQRT(number);
000611  000682  // Usage : SQRT(arg);
000612  000683  // Notes : Returns the integer square root of a number.
000613  000684        
000614  000685  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000615  000686  // Syntax: OVF();
000616  000687  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000617  000688  //       : hiWord := OVF();
000618  000689  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000619  000690        
000620  000691  func CY(), 1;
000621  000692  // Syntax: CY();
000622  000693  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
000623  000694  //       : print(myvar," "CY(),"\n");           // carry = 1
000624  000695  // Notes : This function returns the carry status of an
000625  000696  // unsigned overflow from any 16 or 32bit additions or sutractions.
000626  000697        
000627  000698  func EVE_SP(), 1;
000628  000699  // Syntax: EVE_SP();
000629  000700  // Usage : eg:  print(EVE_SP());
000630  000701  // Notes : Used for debugging to assess the current stack level,
000631  000702  //       : mainly for checking stack leaks, see example EVE_SP.4dg
000632  000703        
000633  000704  func EVE_SSIZE(), 1;
000634  000705  // Syntax: EVE_SSIZE();
000635  000706  // Usage : eg:  print(EVE_SSIZE());
000636  000707  // Notes : Used to get the stack size,
000637  000708  //       : mainly for debugging purposes, EVE_SP.4dg
000638  000709        
000639  000710        
000640  000711  //------------------------------------------------------------------//
000641  000712  //
000642  000713  //------------------------------------------------------------------//
000643  000714  func mem_ArrayOp1("memarray", "count", "op", "value"), 0;                     // single array functions
000644  000715        
000645  000716        
000646  000717  // single word array operations
000647  000718  #CONST
000648  000739  #END
000649  000740        
000650  000741        
000651  000742  func mem_ArrayOp2("memarray1", "memarray2", "count", "op", "value"), 0;         // dual array functions
000652  000743        
000653  000744  // dual word array operations
000654  000745  #CONST
000655  000757  #END
000656  000758        
000657  000759        
000658  000760  func __reserved3(), 0; // do not remove
000659  000761  func __reserved4(), 0; // do not remove
000660  000762        
000661  000763        
000662  000764  //------------------------------------------------------------------//
000663  000765  // unsigned long (32 bit) operations                                //
000664  000766  //------------------------------------------------------------------//
000665  000767        
000666  000768  func uadd_3232("res32", "val1", "val2"), 1;
000667  000769  // Syntax   : cmp_3232(res32, varA, varB);
000668  000770  // Input    : DWORD res32 points to optional result (or zero for compare)
000669  000771  //          : DWORD val1 points to 32bit augend
000670  000772  //          : DWORD val2 points to 32bit addend
000671  000773  // Usage    : var res32[2];
000672  000774  //          : res := cmp_3232(res32, val1, val2);
000673  000775  // Notes    : performs an unsigned addition of 2 x 32bit values
000674  000776  //          : placing the 32bit result in a 2 word array.
000675  000777  // Returns  : returns 1 on 32bit unsigned overflow (carry).
000676  000778  //          ; carry flag is also set on 32bit unsigned overflow
000677  000779  //          ; and can be read with the CY() function.
000678  000780        
000679  000781        
000680  000782  func usub_3232("res32", "val1", "val2"), 1;
000681  000783  // Syntax   : cmp_3232(res32, varA, varB);
000682  000784  // Input    : DWORD res32 points to optional result (or zero for compare)
000683  000785  //          : DWORD val1 points to first 32bit minuend
000684  000786  //          : DWORD val2 points to 32bit subtrahend
000685  000787  // Usage    : var res32[2];
000686  000788  //          : res := cmp_3232(res32, val1, val2);
000687  000789  // Notes    : performs an unsigned subtraction of 2 x 32bit values
000688  000790  //          : placing the 32bit result in a 2 word array.
000689  000791  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
000690  000792  //          ; carry flag is also set on 32bit unsigned underflow
000691  000793  //          ; and can be read with the CY() function.
000692  000794        
000693  000795        
000694  000796  func umul_1616("&res32", "val1", "val2"), 1;
000695  000797  // Syntax   : umul_1616(&res32, varA, varB);
000696  000798  // Input    : DWORD result   points to 32bit result register.
000697  000799  //          : VAR   val1  16bit register or constant
000698  000800  //          : VAR   val2  16bit register or constant
000699  000801  // Usage    : var res32[2];
000700  000802  //          : umul_1616(&res32, myvar, 50000);
000701  000803  // Notes    : performs an unsigned multiply of 2 x 16bit values
000702  000804  //          : placing the 32bit result in a 2 word array.
000703  000805  // Returns  : the pointer to the 32bit result.
000704  000806  //          : carry and overflow are not affected.
000705  000807        
000706  000808        
000707  000809  func udiv_3232("res32", "val1", "val2"), 1;
000708  000810  // Syntax   : udiv_1616(res32, varA, varB);
000709  000811  // Input    : DWORD *result   points to 32bit result register.
000710  000812  //          : DWORD   val1  pointer to 32bit value (dividend)
000711  000813  //          : DWORD   val2  pointer to 32bit value (divisor)
000712  000814  // Usage    : var res32[2];
000713  000815  //          : umul_1616(res32, myvar, 50000);
000714  000816  // Notes    : performs an unsigned division of 2 x 32bit values
000715  000817  //          : placing the 32bit result in a 2 word array.
000716  000818  // Returns  : the pointer to the 32bit result.
000717  000819  //          : carry and overflow are not affected.
000718  000820        
000719  000821        
000720  000822  func ucmp_3232("val1", "val2"), 1;
000721  000823  // Syntax   : cmp_3232(varA, varB);
000722  000824  // Input    : DWORD val1 points to 32bit minuend
000723  000825  //          : DWORD val2 points to 32bit sutrahend
000724  000826  // Usage    : res := cmp_3232(val1, val2);
000725  000827  // Notes    : performs an unsigned comparison of 2 x 32bit values.
000726  000828  //          : The result of the subtraction is returned.
000727  000829  // Returns  : 0  if equal
000728  000830  //          : 1  if val1 > val2
000729  000831  //          : -1 if val1 < val2
000730  000832  //          : This function does not affect the carry flag.
000731  000833        
000732  000834  func __reserved5(), 0; // do not remove
000733  000835  func __reserved6(), 0; // do not remove
000734  000836        
000735  000837  //------------------------------------------------------------------//
000736  000838  // Floating point operations                                        //
000737  000839  // Note that source arguments may be a pointer to a float variable, //
000738  000840  // or a numeric text string.                                        //
000739  000841  // A string argument is converted at run-time by calling            //
000740  000842  // flt_Val for a string argument.                                   //
000741  000843  // Note that a float variable is a 2 word array, eg var myfloat[2]; //
000742  000844  //------------------------------------------------------------------//
000743  000845  func flt_VAL("fresult", "numstring"), 1;
000744  000846  // Syntax   : flt_VAL(float1, mystring);
000745  000847  // Input    : FLOAT  fresult  points to float result register
000746  000848  //          : numstring       a string constant or string variable
000747  000849  //          : that is holds valid floating point number.
000748  000850  // Usage    : var float1[2];
000749  000851  //          : flt_VAL(float1, "1.0594631");
000750  000852  // Notes    : The string argument can be a string constant, a pointer
000751  000853  //          : to a string variable, or a pointer to a data statement.
000752  000854  //          : The string may be a float, or a hex or binary integer value (no decimal point allowed).
000753  000855  //          : For hex or binary, the number is preceeded with 0x or 0b
000754  000856  // Returns  : the pointer to the float result.
000755  000857  //          : carry and overflow are not affected.
000756  000858        
000757  000859        
000758  000860  func flt_ITOF("fresult", "var16"), 1;
000759  000861  // Syntax   : flt_ITOF(resf, intval);
000760  000862  // Input    : FLOAT  fresult  points to float result register
000761  000863  //          : var16           a 16bit signed integer variable or string constant
000762  000864  // Usage    : var float1[2];
000763  000865  //          : var myvar := 30000;
000764  000866  //          : flt_VAL(float1, myvar);
000765  000867  // Notes    : Converts a 16bit signed integer value to a signed floating point number.
000766  000868  // Returns  : the pointer to the float result.
000767  000869        
000768  000870        
000769  000871  func flt_UITOF("fresult", "uvar16"), 1;
000770  000872  // Syntax   : flt_ITOF(resf, intval);
000771  000873  // Input    : FLOAT  fresult  points to float result register
000772  000874  //          : var16           a 16bit integer variable or constant (treated as unsigned)
000773  000875  // Usage    : var float1[2];
000774  000876  //          : var myuvar := 30000;
000775  000877  //          : flt_UITOF(float1, myuvar);
000776  000878  // Notes    : Converts a 16bit unsigned integer value to a positive floating point number.
000777  000879  // Returns  : the pointer to the float result.
000778  000880        
000779  000881  func flt_LTOF("fresult", "var32"), 1;
000780  000882  // Syntax   : flt_LTOF(resf, var32);
000781  000883  // Input    : FLOAT  fresult  points to float result register
000782  000884  //          : var32           points to a 32bit (long) signed variable or string constant
000783  000885  // Usage    : var float1[2];
000784  000886  //          : var mylong[2];
000785  000887  //          : flt_VAL(float1, mylong);
000786  000888  // Notes    : Converts a 32bit signed integer value to a signed floating point number.
000787  000889  // Returns  : the pointer to the float result.
000788  000890        
000789  000891        
000790  000892  func flt_ULTOF("fresult", "uvar32"), 1;
000791  000893  // Syntax   : flt_ITOF(resf, uvar32);
000792  000894  // Input    : FLOAT  fresult  points to float result register
000793  000895  //          : var32           points to a 32bit (unsigned long) unsigned variable or string constant
000794  000896  // Usage    : var float1[2];
000795  000897  //          : var myulong[2];
000796  000898  //          : flt_VAL(float1, myulong);
000797  000899  // Notes    : Converts a 32bit unsigned integer value to a positive floating point number.
000798  000900  // Returns  : the pointer to the float result.
000799  000901        
000800  000902        
000801  000903  func flt_PRINT("fvalue", "formatstring"), 1;
000802  000904  // Syntax   : flt_PRINT(resf, formatstr);
000803  000905  // Input    : FLOAT  fresult  points to float result register
000804  000906  //          : formatstring    zero, null string, of valid format string
000805  000907  // Usage    : var float1[2];
000806  000908  //          : flt_PRINT(float1, "");
000807  000909  // Notes    : The string argument can be a string constant, a pointer
000808  000910  //          : to a string variable, or a pointer to a data statement.
000809  000911  //          : If it is zero or an empty string, the number is
000810  000912  //          : automatically formatted for the best presentation.
000811  000913  //          : The format string is similar to the C language, but only
000812  000914  //          : a single '%' may be used to print a single variable.
000813  000915  // Returns  : zero if success.
000814  000916        
000815  000917        
000816  000918  func flt_ABS("result", "floatval"), 1;
000817  000919  // Syntax   : flt_ABS(&result, &fval);
000818  000920  // Input    : FLOAT  result   points to float result register
000819  000921  //          : numstring       a string that is a valid number
000820  000922  // Usage    : var float1[2];
000821  000923  //          : flt_VAL(float1, float1); // convert float1 to its ABS value
000822  000924  // Returns  : the pointer to the float result.
000823  000925  //          : carry and overflow are not affected.
000824  000926        
000825  000927        
000826  000928  func flt_ACOS("result", "floatval"), 1;
000827  000929  // Syntax   : flt_ACOS(result, fval);
000828  000930  // Input    : FLOAT  result (in radians) points to float result register
000829  000931  //          : FLOAT  floatval points to the float value to get arccos of
000830  000932  // Usage    : var float1[2];
000831  000933  //          : flt_ACOS(result, float1); // get the arccos of float1
000832  000934  // Notes    : the result is in radians.
000833  000935  // Returns  : the pointer to the float result.
000834  000936  //          : carry and overflow are not affected.
000835  000937        
000836  000938        
000837  000939  func flt_ASIN("result", "floatval"), 1;
000838  000940  // Syntax   : flt_ASIN(result, fval);
000839  000941  // Input    : FLOAT  result (in radians) points to float result register
000840  000942  //          : FLOAT  floatval points to the float value to get arcsin of
000841  000943  // Usage    : var float1[2];
000842  000944  //          : flt_ASIN(result, float1); // get the Arcsin of float1
000843  000945  // Notes    : the result is in radians.
000844  000946  // Returns  : the pointer to the float result.
000845  000947  //          : carry and overflow are not affected.
000846  000948        
000847  000949        
000848  000950  func flt_ATAN("result", "floatval"), 1;
000849  000951  // Syntax   : flt_ATAN(result, fval);
000850  000952  // Input    : FLOAT  result (in radians) points to float result register
000851  000953  //          : FLOAT  floatval points to the float value to get arctan of
000852  000954  // Usage    : var float1[2];
000853  000955  //          : flt_ATAN(result, float1); // get the Arctan of float1
000854  000956  // Notes    : the result is in radians.
000855  000957  // Returns  : the pointer to the float result.
000856  000958  //          : carry and overflow are not affected.
000857  000959        
000858  000960        
000859  000961  func flt_COS("result", "floatval"), 1;
000860  000962  // Syntax   : flt_COS(result, fval);
000861  000963  // Input    : FLOAT  result   points to float result register
000862  000964  //          : FLOAT  floatval (in radians) points to the float value to get Cos of
000863  000965  // Usage    : var float1[2];
000864  000966  //          : flt_COS(result, float1); // get the Cosine of float1
000865  000967  // Notes    : the result is in radians.
000866  000968  // Returns  : the pointer to the float result.
000867  000969  //          : carry and overflow are not affected.
000868  000970        
000869  000971        
000870  000972  func flt_EXP("result", "floatval"), 1;
000871  000973  // Syntax   : flt_EXP(result, fval);
000872  000974  // Input    : FLOAT  result   points to float result register
000873  000975  //          : FLOAT  floatval points to the float value to get Exponent of
000874  000976  // Usage    : var float1[2];
000875  000977  //          : flt_EXP(result, float1); // get the Exponent of float1
000876  000978  // Returns  : the pointer to the float result.
000877  000979  //          : carry and overflow are not affected.
000878  000980        
000879  000981        
000880  000982  func flt_CEIL("result", "floatval"), 1;
000881  000983  // Syntax   : flt_CEIL(result, floatval);
000882  000984  // Input    : FLOAT  floatval points to the float value to integerize up
000883  000985  // Usage    : var float1[2];
000884  000986  //          : n := flt_INT(float1, float1); // round value up to the integer value
000885  000987  // Notes    : Removes fractional part, rounding up correctly.
000886  000988  // Returns  : the pointer to the float result.
000887  000989  //          : carry and overflow are not affected.
000888  000990        
000889  000991        
000890  000992  func flt_FLOOR("result", "floatval"), 1;
000891  000993  // Syntax   : flt_FLOOR(result, floatval);
000892  000994  // Input    : FLOAT  floatval points to the float value to integerize down
000893  000995  // Usage    : var float1[2];
000894  000996  //          : n := flt_INT(float1, float1); // round value down to the integer value
000895  000997  // Notes    : Removes fractional part, rounding down correctly.
000896  000998  // Returns  : the pointer to the float result.
000897  000999  //          : carry and overflow are not affected.
000898  001000        
000899  001001        
000900  001002  func flt_SIN("result", "floatval"), 1;
000901  001003  // Syntax   : flt_SIN(result, fval);
000902  001004  // Input    : FLOAT  result   points to float result register
000903  001005  //          : FLOAT  floatval (in radians) points to the float value to get Sine of
000904  001006  // Usage    : var float1[2];
000905  001007  //          : flt_SIN(result, float1); // get the Sin of float1
000906  001008  // Notes    : the result is in radians.
000907  001009  // Returns  : the pointer to the float result.
000908  001010  //          : carry and overflow are not affected.
000909  001011        
000910  001012        
000911  001013  func flt_LOG("result", "floatval"), 1;
000912  001014  // Syntax   : flt_LOG(&result, &fval);
000913  001015  // Input    : FLOAT  result   points to float result register
000914  001016  //          : FLOAT  floatval points to the float value to get Log of
000915  001017  // Usage    : var float1[2];
000916  001018  //          : flt_LOG(result, float1); // get the natural Log of float1
000917  001019  // Returns  : the pointer to the float result.
000918  001020  //          : carry and overflow are not affected.
000919  001021        
000920  001022        
000921  001023  func flt_SQR("result", "floatval"), 1;
000922  001024  // Syntax   : flt_SQR(result, fval);
000923  001025  // Input    : FLOAT  result   points to float result register
000924  001026  //          : FLOAT  floatval points to the float value to get Log of
000925  001027  // Usage    : var float1[2];
000926  001028  //          : flt_SQR(result, float1); // get the square root of float1
000927  001029  // Returns  : the pointer to the float result, or zero if number was negative.
000928  001030  //          : carry and overflow are not affected.
000929  001031        
000930  001032        
000931  001033  func flt_TAN("result", "floatval"), 1;
000932  001034  // Syntax   : flt_TAN(result, fval);
000933  001035  // Input    : FLOAT  result   points to float result register
000934  001036  //          : FLOAT  floatval (in radians) points to the float value to get Tangent of
000935  001037  // Usage    : var float1[2];
000936  001038  //          : flt_TAN(result, float1); // get the Tangent of float1
000937  001039  // Returns  : the pointer to the float result.
000938  001040  //          : carry and overflow are not affected.
000939  001041        
000940  001042        
000941  001043  func flt_POW("result", "floatx", "floaty"), 1;
000942  001044  // Syntax   : flt_POW(result, fval1, fval2);
000943  001045  // Input    : FLOAT  result   points to float result register
000944  001046  //          : FLOAT  floatx   points to the float value to raise
000945  001047  //          : FLOAT  floaty   points to the float value for power
000946  001048  // Usage    : flt_POW(result, floatx, floaty); // raise x to power y
000947  001049  // Returns  : the pointer to the float result, or zero if error occurs.
000948  001050  //          : carry and overflow are not affected.
000949  001051        
000950  001052        
000951  001053  func flt_ADD("result", "floatA", "floatB"), 1;
000952  001054  // Syntax   : flt_ADD(result, floatA, floatB);
000953  001055  // Input    : FLOAT  result   points to float result register
000954  001056  //          : FLOAT  floatval points to the float value A
000955  001057  //          : FLOAT  floatval points to the float value B
000956  001058  // Usage    : flt_ADD(result, floatx, floaty); // add B to A
000957  001059  // Returns  : the pointer to the float result, or zero if error occurs.
000958  001060  //          : carry and overflow are not affected.
000959  001061        
000960  001062        
000961  001063  func flt_SUB("&result", "&floatA", "&floatB"), 1;
000962  001064  // Syntax   : flt_SUB(result, floatA, floatB);
000963  001065  // Input    : FLOAT  result   points to float result register
000964  001066  //          : FLOAT  floatval points to the float value A
000965  001067  //          : FLOAT  floatval points to the float value B
000966  001068  // Usage    : flt_SUB(&result, &floatx, &floaty); // subtract B from A
000967  001069  // Returns  : the pointer to the float result, or zero if error occurs.
000968  001070  //          : carry and overflow are not affected.
000969  001071        
000970  001072        
000971  001073  func flt_MUL("result", "floatA", "floatB"), 1;
000972  001074  // Syntax   : flt_MUL(result, floatA, floatB);
000973  001075  // Input    : FLOAT  result   points to float result register
000974  001076  //          : FLOAT  floatval points to the float value A
000975  001077  //          : FLOAT  floatval points to the float value B
000976  001078  // Usage    : flt_MUL(result, floatA, floatB); // multiply A by B
000977  001079  // Returns  : the pointer to the float result, or zero if error occurs.
000978  001080  //          : carry and overflow are not affected.
000979  001081        
000980  001082        
000981  001083  func flt_DIV("result", "floatA", "floatB"), 1;
000982  001084  // Syntax   : flt_DIV(result, floatA, floatB);
000983  001085  // Input    : FLOAT  result   points to float result register
000984  001086  //          : FLOAT  floatval points to the float value A
000985  001087  //          : FLOAT  floatval points to the float value B
000986  001088  // Usage    : flt_DIV(result, floatA, floatB); // divide A by B
000987  001089  // Returns  : the pointer to the float result, or zero if error occurs.
000988  001090  //          : carry and overflow are not affected.
000989  001091        
000990  001092        
000991  001093  //------------------------------------------------------------------//
000992  001094  // The following float functions all return integer values.
000993  001095  //------------------------------------------------------------------//
000994  001096  func flt_EQ("floatA", "floatB"), 1;
000995  001097  // Syntax   : flt_EQ(floatA, floatB);
000996  001098  // Input    : FLOAT  floatval points to the float value A
000997  001099  //          : FLOAT  floatval points to the float value B
000998  001100  // Usage    : if (flt_EQ(floatA, floatB)) // compare A to B, true if A == B
000999  001101  // Returns  : True if numbers are equal, false otherwise.
001000  001102        
001001  001103        
001002  001104  func flt_NE("floatA", "floatB"), 1;
001003  001105  // Syntax   : flt_NE(floatA, floatB);
001004  001106  // Input    : FLOAT  floatval points to the float value A
001005  001107  //          : FLOAT  floatval points to the float value B
001006  001108  // Usage    : if (flt_NE(floatA, floatB)) // compare A to B, true if A != B
001007  001109  // Returns  : True if numbers are not equal, false otherwise.
001008  001110        
001009  001111        
001010  001112        
001011  001113  func flt_GT("floatA", "floatB"), 1;
001012  001114  // Syntax   : flt_GT(floatA, floatB);
001013  001115  // Input    : FLOAT  floatval points to the float value A
001014  001116  //          : FLOAT  floatval points to the float value B
001015  001117  // Usage    : if (flt_GT(floatA, floatB)) // compare A to B, true if A > B
001016  001118  // Returns  : True if A > B, false otherwise.
001017  001119        
001018  001120        
001019  001121  func flt_GE("floatA", "floatB"), 1;
001020  001122  // Syntax   : flt_GE(floatA, floatB);
001021  001123  // Input    : FLOAT  floatval points to the float value A
001022  001124  //          : FLOAT  floatval points to the float value B
001023  001125  // Usage    : if (flt_GE(floatA, floatB)) // compare A to B, true if A >= B
001024  001126  // Returns  : True if A >= B, false otherwise.
001025  001127        
001026  001128        
001027  001129  func flt_LT("floatA", "floatB"), 1;
001028  001130  // Syntax   : flt_LT(floatA, floatB);
001029  001131  // Input    : FLOAT  floatval points to the float value A
001030  001132  //          : FLOAT  floatval points to the float value B
001031  001133  // Usage    : if (flt_LT(floatA, floatB)) // compare A to B, true if A < B
001032  001134  // Returns  : True if A < B, false otherwise.
001033  001135        
001034  001136        
001035  001137  func flt_LE("floatA", "floatB"), 1;
001036  001138  // Syntax   : flt_LE(floatA, floatB);
001037  001139  // Input    : FLOAT  floatval points to the float value A
001038  001140  //          : FLOAT  floatval points to the float value B
001039  001141  // Usage    : if (flt_LE(floatA, floatB )) // compare A to B, true if A <= B
001040  001142  // Returns  : True if A <= B, false otherwise.
001041  001143        
001042  001144        
001043  001145  func flt_SGN("floatval"), 1;
001044  001146  // Syntax   : flt_SGN(fval);
001045  001147  // Input    : FLOAT  floatval   points to the float value examine sign
001046  001148  // Usage    : var float1[2];
001047  001149  //          : n := flt_SGN(float1); // return -1 if float number negative
001048  001150  // Notes    : returns 0 if sign is positive or zero.
001049  001151  // Returns  : returns 16bit integer -1 if float sign is negative, or zero if positive.
001050  001152  //          : carry and overflow are not affected.
001051  001153        
001052  001154        
001053  001155  func flt_FTOI("floatvar"), 1;
001054  001156  // Syntax   : flt_FTOI(myfloat);
001055  001157  // Input    : FLOAT  fresult  points to float result register
001056  001158  // Usage    : var float1[2];
001057  001159  //          : myvar := flt_VAL(&float1, myvar);
001058  001160  // Notes    : Converts a floating point number to a 16bit integer.
001059  001161  //          : The floating point number is rounded up or down accordingly.
001060  001162  // Returns  : the integer value of the float.
001061  001163        
001062  001164  func flt_PRINTxy("xpos", "ypos", "fvalue", "formatstring"), 1;
001063  001165  // Syntax   : flt_PRINT(x, y, resf, formatstr);
001064  001166  // Input    : FLOAT  fresult  points to float result register
001065  001167  //          : formatstring    zero, null string, of valid format string
001066  001168  // Usage    : var float1[2];
001067  001169  //          : flt_PRINT(float1, "");
001068  001170  // Notes    : The string argument can be a string constant, a pointer
001069  001171  //          : to a string variable, or a pointer to a data statement.
001070  001172  //          : If it is zero or an empty string, the number is
001071  001173  //          : automatically formatted for the best presentation.
001072  001174  //          : The format string is similar to the C language, but only
001073  001175  //          : a single '%' may be used to print a single variable.
001074  001176  // Returns  : zero if success.
001075  001177        
001076  001178  func __reserved9(), 0; // do not remove
001077  001179  func __reserved10(), 0; // do not remove
001078  001180        
001079  001181  //------------------------------------------------------------------//
001080  001182  //------------------------------------------------------------------//
001081  001183  //------------------------------------------------------------------//
001082  001184  //------------------------------------------------------------------//
001083  001185  //------------------------------------------------------------------//
001084  001186  func pin_Set("mode", "pin"), 1;            // set pin to required mode
001085  001187  // Syntax: pin_Set(mode, pin);
001086  001188  // Usage : pin_Set(PIN_OUT,);
001087  001189  // Notes : Sets the selected pin to the desired mode. Refer to the manual
001088  001190  //       : for pin function compatitblilites.
001089  001191  //       : returns true if the pin number and mode is legal (usually ignored)
001090  001192  //       :    available pin modes
001091  001193  //       :    PIN_INP                 0        // pin is input, no pullup or pulldown
001092  001194  //       :    PIN_INP_HI              1        // pin is input with pullup to Vcc
001093  001195  //       :    PIN_INP_LO              2        // pin is input with pulldown to Gnd
001094  001196  //       :    PIN_OUT                 3        // pin is output
001095  001197  //       :    PIN_OUT_OD              4        // pin is output with open drain
001096  001198  //       :    PIN_AN                  5        // pin is analogue (PA0 to PA3 only)
001097  001199  //       :    PIN_ANAVG               6        // pin is analogue (PA0 to PA3 only), averaged - 16 samples
001098  001200  //       :
001099  001201        
001100  001202  func pin_HI("pin"), 1;                    // set pin to logic '1'
001101  001203  // Syntax: pin_HI(pin);
001102  001204  // Usage : pin_HI(PA4);        // make PA4 HI level
001103  001205  // Notes : Outputs a logic "High" to the pin latch
001104  001206  //       : The pin is automatically made an output.
001105  001207  //       : pullup, pulldown, and change notification will be disable for the selected pin.
001106  001208  //       : returns true if the pin number is legal (usually ignored)
001107  001209  //       :
001108  001210        
001109  001211  func pin_LO("pin"), 1;                    // set pin to logic '0'
001110  001212  // Syntax: pin_LO(pin);
001111  001213  // Usage : pin_LO(PA3);
001112  001214  // Notes : Outputs a logic "Low" to the pin latch
001113  001215  //       : The pin is automatically made an output.
001114  001216  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001115  001217  //       : returns true if the pin number is legal (usually ignored)
001116  001218  //       :
001117  001219        
001118  001220  func pin_Val("pin", "value"), 0;                    // set pin to to state of variable
001119  001221  // Syntax: pin_Var(pin, value);
001120  001222  // Usage : pin_Var(IO3, myvar);
001121  001223  // Notes : Outputs a logic state on a pin depending on the value of bit 0 of a variable
001122  001224  //       : The pin is automatically made an output.
001123  001225  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001124  001226  //       : returns true if the pin number is legal (usually ignored)
001125  001227        
001126  001228  func pin_Read("pin"), 1;                // read pin, logic or analogue
001127  001229  // Syntax: pin_Read(PA0);
001128  001230  // Usage : arg1 := pin_Read(arg2);
001129  001231  // Notes : Read a pin in various ways. If the pin is
001130  001232  //       : set to an input, read the state of the input pin.
001131  001233  //       : If set to an output, read the state of the output latch.
001132  001234  //       : If set to analogue, read the 12 bit analogue value.
001133  001235        
001134  001236  func bus_Read(), 1;
001135  001237  // Syntax: bus_Read();
001136  001238  // Usage : arg1 := pin_ReadBus();
001137  001239  // Notes : Read the 16 bit port regardless of pin configurations.
001138  001240  //       : If a pin is configured as input or analogue, the pin is read directly as
001139  001241  //       : if it were a digital input. If a pin is configured as an output, the pin
001140  001242  //       : is also read directly, giving the output latch state.
001141  001243  //       : Bit 0 coresponds to PA0 through to bit15 which coresponds to PA15
001142  001244  //       : (Refer to 'port bit position masks')
001143  001245  //Returns: Returns the 16 bit value of the bus.
001144  001246        
001145  001247  func bus_SetPins("value"), 0;
001146  001248  // Syntax: bus_SetPins(value);
001147  001249  // Usage : arg1 := bus_SetPins(15); // set PA0 to PA3 to output bits, making them HI
001148  001250  // Notes : Any '1' bits in "value" set the coresponding port pin to an output
001149  001251  //       : and forces its state to a '1'. The state of its previous open drain
001150  001252  //       : configuration is not altered. Any zero bits in "value" will not affect the pin.
001151  001253  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001152  001254  //       : Bit 0 coresponds to PA0 through to bit13 which coresponds to PA13
001153  001255        
001154  001256  func bus_ClearPins("value"), 0;
001155  001257  // Syntax: bus_ClearPins(value);
001156  001258  // Usage : bus_ClearPins(0x03F0); // set PA0 to PA5 to output bits, making them LO
001157  001259  // Notes : Any '1' bits in "value" set the coresponding port pin to an output
001158  001260  //       : and forces its state to a '0. The state of its previous open drain
001159  001261  //       : configuration is not altered. Any zero bits in "value" will not affect the pin.
001160  001262  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001161  001263  //       : Bit 0 coresponds to PA0 through to bit13 which coresponds to PA13
001162  001264        
001163  001265  func bus_SetChangeInterrupt("function", "portmask"), 1;
001164  001266  // Syntax: bus_SetChangeInterrupt(value);
001165  001267  // Usage : bus_SetChangeInterrupt(scanKeypad, 0x00F0); // set PA4 to PA7 to interrupt on change
001166  001268  // Notes : Any '1' bits in "portmask" marks that pin to generate an interrupt on change.
001167  001269  //       : A level change on that pin will cause "function" to be executed. If "function" is
001168  001270  //       : zero, the display may be put into sleep mode, and any change will cause a wakeup reset.
001169  001271  //       : Wakeup will always re-start code running in FLASHBANK_0
001170  001272  //       : Bit 0 coresponds to PA0 through to bit15 which coresponds to PA15
001171  001273  //       : (Refer to 'port bit position masks')
001172  001274  //       : Once armed, "function" will only be executed once, it is necessary to
001173  001275  //       : re-arm for any further events.
001174  001276  //Returns: Return the current state of the pins that are selected in "portmask"
001175  001277  //       : This can be saved and later used in "function" to see which pin(s) actually changed.
001176  001278        
001177  001279  func bus_Write8("var"), 0;
001178  001280  // Syntax: bus_Write8(var);
001179  001281  // Usage : bus_Write8(arg1);
001180  001282  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
001181  001283  //       : a settling delay of approx 50nsec, the BUS_WR(PA2) pin is strobed
001182  001284  //       : LO for approx 50nsec then set back HI.
001183  001285  //       : The upper 8 bits of arg1 are ignored.
001184  001286  //       : NB:- the BUS_WR(PA2) pin must be preset to the desired output state
001185  001287  //       : as must the bus pins to ensure BUS write integrity.
001186  001288  //       :
001187  001289  //       : BUS_0 is PA4
001188  001290  //       : BUS_1 is PA5
001189  001291  //       : BUS_2 is PA6
001190  001292  //       : BUS_3 is PA7
001191  001293  //       : BUS_4 is PA8
001192  001294  //       : BUS_5 is PA9
001193  001295  //       : BUS_6 is PA10
001194  001296  //       : BUS_7 is PA11
001195  001297        
001196  001298  func bus_Read8(), 1;
001197  001299  // Syntax: bus_Read();
001198  001300  // Usage : arg1 := bus_Read8();
001199  001301  // Notes : The BUS_RD(PA3) pin set to LO, then, after a settling delay
001200  001302  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
001201  001303  //       : (the upper 8 bits being set to 0)
001202  001304  //       : the BUS_RD(PA3) pin is then set back to a HI level.
001203  001305  //       : NB:- the BUS_RD(PA3) pin must be preset to the desired output state
001204  001306  //       : as must the bus pins to ensure BUS read integrity.
001205  001307  //       :
001206  001308  //       : BUS_0 is PA4
001207  001309  //       : BUS_1 is PA5
001208  001310  //       : BUS_2 is PA6
001209  001311  //       : BUS_3 is PA7
001210  001312  //       : BUS_4 is PA8
001211  001313  //       : BUS_5 is PA9
001212  001314  //       : BUS_6 is PA10
001213  001315  //       : BUS_7 is PA11
001214  001316        
001215  001317  func __reserved13(), 0; // do not remove
001216  001318  func __reserved14(), 0; // do not remove
001217  001319  //------------------------------------------------------------------//
001218  001320  // Pin related constants                                            //
001219  001321  //------------------------------------------------------------------//
001220  001322        
001221  001323  // pin_Set(...) pin modes
001222  001324  #CONST
001223  001332  #END
001224  001333        
001225  001334        
001226  001335  // pin name             constant    connector H1 I/O Pin referencesnumbers
001227  001336  #CONST
001228  001357  #END
001229  001358        
001230  001359  // bit position masks
001231  001360  #CONST
001232  001377  #END
001233  001378        
001234  001379        
001235  001380        
001236  001381  //------------------------------------------------------------------//
001237  001382  //   Graphics Functions
001238  001383  //------------------------------------------------------------------//
001239  001384  func gfx_Set("mode", "value"), 0;            // set various graphics functions
001240  001385  // Syntax: gfx_Set(mode, value);
001241  001386  // Usage : gfx_Set(arg1, arg2);
001242  001387  // Notes : Sets various graphics parameters used by other functions
001243  001388  //       : This allows the features to be set programatically with a
001244  001389  //       : single function call.It is strongly recommended to use the
001245  001390  //       : pre-defined constants rather than the mode numbers.
001246  001391  //       : NB:- Although it is often required to be able to set graphics
001247  001392  //       : functions with a single function call for graphics engine
001248  001393  //       : related functions, there is a complete set of single parameter
001249  001394  //       : shortcut functions that have exactly the same function as
001250  001395  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
001251  001396  //       :
001252  001397  //       : mode = PEN_SIZE (mode 16)
001253  001398  //       : gfx_Set(PEN_SIZE, value);
001254  001399  //       : value = SOLID (value 0) rectangle and circle objects are solid
001255  001400  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
001256  001401  //       : Sets the mode of the Pen used by most graphics objects
001257  001402  //       :
001258  001403  //       : mode = BACKGROUND_COLOUR (mode 17)
001259  001404  //       : gfx_Set(BACKGROUND_COLOUR, value);
001260  001405  //       : value = 0 to 0xFFFF, Black to White
001261  001406  //       : Sets the Background colour of the screen
001262  001407  //       :
001263  001408  //       : mode = OBJECT_COLOUR (mode 18)
001264  001409  //       : gfx_Set(OBJECT_COLOUR, value);
001265  001410  //       : value = 0 to 0xFFFF, Black to White
001266  001411  //       : Sets the Object colour used in various functions
001267  001412  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
001268  001413  //       :
001269  001414  //       : mode = CLIPPING (mode 19)
001270  001415  //       : gfx_Set(CLIPPING, value);
001271  001416  //       : value = OFF (value 0) Clipping disabled
001272  001417  //       : value = ON (value 1) Clipping enabled
001273  001418  //       : Enables/Disables the Clipping feature
001274  001419  //       :
001275  001420  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
001276  001421  //       : gfx_Set(TRANSPARENT_COLOUR, value);
001277  001422  //       : value = 0 to 0xFFFF Black to White
001278  001423  //       : Sets Bitmap, Image or Animation Transparency Colour.
001279  001424  //       : NB not implemented
001280  001425  //       :
001281  001426  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
001282  001427  //       : gfx_Set(5, value);
001283  001428  //       : value = OFF (value 0) Transparency disabled
001284  001429  //       : value = ON (value 1) Transparency enabled
001285  001430  //       : Enables/Disables the Transparency feature
001286  001431  //       : NB not implemented
001287  001432  //       :
001288  001433  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
001289  001434  //       : gfx_Set(FRAME_DELAY, value);
001290  001435  //       : value = 0 to 65535 ms
001291  001436  //       : Sets the Video/Animation clip inter-frame delay. This setting will
001292  001437  //       : over-ride the embedded frame delay of the clip. After the event,
001293  001438  //       : the setting will auto disable and if further inter-frame delays need
001294  001439  //       : overriding the setting must be re-issued.
001295  001440  //       :
001296  001441  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
001297  001442  //       : gfx_Set(SCREEN_MODE, value);
001298  001443  //       : value = LANDSCAPE   (value 0)
001299  001444  //       : value = LANDSCAPE_R (value 1)
001300  001445  //       : value = PORTRAIT    (value 2)
001301  001446  //       : value = PORTRAIT_R  (value 3)
001302  001447  //       :
001303  001448  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
001304  001449  //       : gfx_Set(OUTLINE_COLOUR, value);
001305  001450  //       : value = 1 to 0xFFFF, if 0, featre is OFF
001306  001451  //       : Sets the filled Rectangle or Circle objects outline colour
001307  001452  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
001308  001453  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
001309  001454  //       :
001310  001455  //       : Only supports variable contrast for uOLED Modules
001311  001456  //       : mode = CONTRAST (mode 25) : Contrast
001312  001457  //       : gfx_Set(CONTRAST, value);
001313  001458  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
001314  001459  //       : when contrast=0, display is placed in low power mode.
001315  001460  //       : This function should be called with contrast=0 when
001316  001461  //       : powering down the module.
001317  001462  //       :
001318  001463  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
001319  001464  //       : gfx_Set(LINE_PATTERN, value);
001320  001465  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
001321  001466  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
001322  001467  //       : a value of 0 turns the feature off
001323  001468  //       :
001324  001469  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
001325  001470  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
001326  001471  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
001327  001472  //       : NB not implemented, default is COLOUR16
001328  001473  //       :
001329  001474  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
001330  001475  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
001331  001476  //       : sets the button and slider objects bevel width
001332  001477  //       :
001333  001478  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
001334  001479  //       : gfx_Set(BEVEL_SHADOW , 5);
001335  001480  //       : sets the button and slider objects darken and lighten depth for the bevel colour
001336  001481  //       :
001337  001482  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
001338  001483  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
001339  001484  //       : sets the origin of drawn objects to a position other than 0,0
001340  001485  //       :
001341  001486  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
001342  001487  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
001343  001488  //       : sets the origin of drawn objects to a position other than 0,0
001344  001489        
001345  001490  //------------------------------------------------------------------------------
001346  001491  //gfx_Set() related constants
001347  001492  //------------------------------------------------------------------------------
001348  001493  #CONST
001349  001510  #END
001350  001511        
001351  001512        
001352  001513  func gfx_Cls(), 0;                    // clear the screen
001353  001514  // Syntax: gfx_Cls();
001354  001515  // Usage : gfx_Cls();
001355  001516  // Notes : Clears the screen with current background colour
001356  001517        
001357  001518  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
001358  001519  // Syntax: gfx_MoveTo(x, y);
001359  001520  // Usage : gfx_MoveTo(arg1, arg2);
001360  001521  // Notes : Moves the origin to a new x,y position
001361  001522        
001362  001523  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
001363  001524  // Syntax: gfx_MoveRel(x, y);
001364  001525  // Usage : gfx_MoveRel(arg1, arg2);
001365  001526  // Notes : Moves the origin to a new x,y position
001366  001527  //       : relative to the current origing
001367  001528        
001368  001529  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
001369  001530  // Syntax: gfx_LineTo(x1, y1);
001370  001531  // Usage : gfx_LineTo(arg1, arg2);
001371  001532  // Notes : Draws a Line from the origin x,y to x1,y1.
001372  001533  //       : The new origin is then set to x1, y1. Line colour needs
001373  001534  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
001374  001535        
001375  001536  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
001376  001537  // Syntax: gfx_LineRel(x1, y1);
001377  001538  // Usage : gfx_LineRel(arg1, arg2);
001378  001539  // Notes : Draws a Line from the origin x,y to x1,y1.
001379  001540  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
001380  001541  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
001381  001542        
001382  001543  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
001383  001544  // Syntax: gfx_Line(x1, x2, y2, colr);
001384  001545  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
001385  001546  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
001386  001547        
001387  001548  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
001388  001549  // Syntax: gfx_Line(x1, x2, y, colr);
001389  001550  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
001390  001551  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
001391  001552        
001392  001553  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
001393  001554  // Syntax: gfx_Line(y1, y2, x, colr);
001394  001555  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
001395  001556  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
001396  001557        
001397  001558  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
001398  001559  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
001399  001560  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
001400  001561  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
001401  001562  //       : bottom corner (x2,y2) on the screen.
001402  001563        
001403  001564  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
001404  001565  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
001405  001566  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
001406  001567  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
001407  001568  //       : bottom corner (x2,y2) on the screen.
001408  001569        
001409  001570  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
001410  001571  // Syntax: gfx_Circle(x, y, rad, colr);
001411  001572  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
001412  001573  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
001413  001574        
001414  001575  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
001415  001576  // Syntax: gfx_Circle(x, y, rad, colr);
001416  001577  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
001417  001578  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
001418  001579        
001419  001580  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
001420  001581  // Syntax: gfx_PutPixel(x, y, colr);
001421  001582  // Usage : gfx_PutPixel(arg1, arg2, arg3);
001422  001583  // Notes : Plots a coloured pixel on the screen at x,y location
001423  001584        
001424  001585  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
001425  001586  // Syntax: gfx_GetPixel(x, y);
001426  001587  // Usage : var := gfx_GetPixel(arg1, arg2);
001427  001588  // Notes : Reads and returns the colour value of a pixel at location x,y
001428  001589        
001429  001590  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
001430  001591  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
001431  001592  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
001432  001593  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
001433  001594  //       : Vertices must be specified in an anti-clockwise fashion
001434  001595        
001435  001596  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
001436  001597  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
001437  001598  // Usage : gfx_OrbitInit(&arg1, &arg2);
001438  001599  // Notes : Sets up the Orbit function parameters.
001439  001600  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
001440  001601  //       : variables that get updated after calling gfx_Orbit(,,) function.
001441  001602  //       : The coordiantaes are calculated relative to the origin
001442  001603  //       : obtained by using the gfx_MoveTo(x, y) function.
001443  001604        
001444  001605  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
001445  001606  // Syntax: gfx_Orbit(angle, distance);
001446  001607  // Usage : gfx_Orbit(arg1, arg2);
001447  001608  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
001448  001609  //       : only known parameters are the angle and the distance from the current origin.
001449  001610        
001450  001611  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
001451  001612  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
001452  001613  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
001453  001614  // Notes : This function is very similar to the Ploygon function
001454  001615  //       : with the exception of the 1st and the last vertices not joined.
001455  001616        
001456  001617  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
001457  001618  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
001458  001619  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
001459  001620  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001460  001621  //       : Vertices must be minimum of 3 and can be specified in any fashion
001461  001622        
001462  001623  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
001463  001624  // Syntax: gfx_Dot();
001464  001625  // Usage : gfx_Dot();
001465  001626  // Notes : Places a coloured dot at the origin
001466  001627        
001467  001628        
001468  001629  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
001469  001630  // Syntax: gfx_Bullet();
001470  001631  // Usage : gfx_Bullet();
001471  001632  // Notes : Places a coloured circle at the origin
001472  001633  //       : filled or unfilled state is controlled by PenSize
001473  001634        
001474  001635  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
001475  001636  // Syntax: gfx_IncX();
001476  001637  // Usage : var := gfx_IncX();
001477  001638  // Notes : Increments the x coordinate of the origin
001478  001639        
001479  001640  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
001480  001641  // Syntax: gfx_IncY();
001481  001642  // Usage : var := gfx_IncY();
001482  001643  // Notes : Increments the y coordinate of the origin
001483  001644        
001484  001645  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
001485  001646  // Syntax: gfx_BoxTo(x1, y1);
001486  001647  // Usage : gfx_BoxTo(arg1, arg2);
001487  001648  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
001488  001649  //       : The new origin is then set to x1,y1. Rectangle colour needs
001489  001650  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
001490  001651  //       : and the PenSize setting determines if Box is solid or outline.
001491  001652        
001492  001653  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
001493  001654  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
001494  001655  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
001495  001656  // Notes : Specifies a clipping window region on the screen such that any objects
001496  001657  //       : and text placed onto the screen will be clipped and displayed only
001497  001658  //       : within that region. For the clipping window to take effect, "Clipping"
001498  001659  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
001499  001660        
001500  001661        
001501  001662  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
001502  001663  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
001503  001664  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
001504  001665  // *Notes:
001505  001666        
001506  001667  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
001507  001668  // Syntax: gfx_SetClipRegion();
001508  001669  // Usage : var := gfx_SetClipRegion();
001509  001670  // *Notes:
001510  001671        
001511  001672  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
001512  001673  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
001513  001674  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
001514  001675  // Notes : Plots a coloured Ellipse on the screen at centre x,y
001515  001676  //       : with xradius = xrad and yradius = yrad.
001516  001677  //       : if PenSize = 0 Ellipse is Solid
001517  001678  //       : if PenSize = 1 Ellipse is Outline
001518  001679        
001519  001680        
001520  001681  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
001521  001682  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
001522  001683  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
001523  001684  // Notes : Plots a coloured Ellipse on the screen at centre x,y
001524  001685  //       : with xradius = xrad and yradius = yrad.
001525  001686        
001526  001687        
001527  001688  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 1;
001528  001689  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
001529  001690  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
001530  001691  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001531  001692  //       : x,y arguments (top left corner). The size of the button depends on
001532  001693  //       : the font, width, height and length of the text.
001533  001694  //       : The button appearance will depend on the state parameter setting:
001534  001695  //       :         state = 0 : Button Pressed
001535  001696  //       :         state = 1 : Button Raised
001536  001697  //       : The button is automatically sized, determined by text.
001537  001698        
001538  001699        
001539  001700  func gfx_Button2("state", "x", "y", "Width", "Height", "buttonColour", "textColour", "text"), 0;
001540  001701  // Syntax: gfx_Button2(mode, x, y, width, height, buttoncolour, textcolour, text);
001541  001702  // Usage : gfx_Button2(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001542  001703  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001543  001704  //       : x,y arguments (top left corner). The size of the button is defined by the width
001544  001705  //       : and height parameters. The text is centered within those bounds.
001545  001706  //       : The button appearance will depend on the state parameter setting:
001546  001707  //       :         state = 0 : Button Pressed
001547  001708  //       :         state = 1 : Button Raised
001548  001709  //       : The button has square corners.
001549  001710        
001550  001711  func gfx_Button3("state", "x", "y", "Width", "Height", "buttonColour", "textColour", "text"), 0;
001551  001712  // Syntax: gfx_Button3(mode, x, y, width, height, buttoncolour, textcolour, text);
001552  001713  // Usage : gfx_Button3(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001553  001714  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001554  001715  //       : x,y arguments (top left corner). The size of the button is defined by the width
001555  001716  //       : and height parameters. The text is centered within those bounds.
001556  001717  //       : The button appearance will depend on the state parameter setting:
001557  001718  //       :         state = 0 : Button Pressed
001558  001719  //       :         state = 1 : Button Raised
001559  001720  //       : The button has rounded corners depending upon gfx_BevelRadius.
001560  001721        
001561  001722  func gfx_CheckBox("state", "x", "y", "Width", "Height", "boxColour", "textColour", "text"), 0;
001562  001723  // Syntax: gfx_CheckBox(state, x, y, Width, Height, boxColour, textColour, text);
001563  001724  // Usage : gfx_CheckBox(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001564  001725  // Notes : Draws a CheckBox at screen location defined by x,y arguments (top left corner).
001565  001726  //       : The size of the button is defined by the width and height parameters.
001566  001727  //       : The text is to the right of the checkbox and truncated if necessary.
001567  001728  //       : The check appearance will depend on the state parameter setting:
001568  001729  //       :         state = 0 = CHECKED    : Checkbox Checked
001569  001730  //       :         state = 1 = UNCHECKED  : CheckBox Unchecked
001570  001731        
001571  001732  func gfx_RadioButton("state", "x", "y", "Width", "Height", "boxColour", "textColour", "text"), 0;
001572  001733  // Syntax: gfx_RadioButton(state, x, y, Width, Height, boxColour, textColour, text);
001573  001734  // Usage : gfx_RadioButton(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001574  001735  // Notes : Draws a RadioButton at screen location defined by x,y arguments (top left corner).
001575  001736  //       : The size of the button is defined by the width and height parameters.
001576  001737  //       : The text is to the right of the radiobutton and truncated if necessary.
001577  001738  //       : The check appearance will depend on the state parameter setting:
001578  001739  //       :         state = 0 = CHECKED    : Radiobutton Checked
001579  001740  //       :         state = 1 = UNCHECKED  : Radiobutton Unchecked
001580  001741        
001581  001742  func gfx_Slider2("mode", "x1", "y1", "width", "height", "colour", "scale", "value"), 1;
001582  001743  // Syntax: gfx_Slider2(mode, x, y, width, height, colour, scale, value);
001583  001744  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001584  001745  // Notes : Draws a 3 dimensional Slider Bar on the screen.
001585  001746  //       : Slider parameters are as follows:
001586  001747  //       :         mode = 0 : Slider recessed
001587  001748  //       :         mode = 1 : Slider raised
001588  001749  //       :         x1, y1 = top left corner
001589  001750  //       :         x2, y2 = bottom right corner
001590  001751  //       :         scale = n : sets the full scale range from 0 to n
001591  001752  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
001592  001753  //returns: scaled value of thumb position
001593  001754        
001594  001755        
001595  001756        
001596  001757        
001597  001758  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
001598  001759  // Syntax: gfx_Panel(style, x, y, width, height, colour);
001599  001760  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
001600  001761  // Notes : Draws a panel (groupbox) at screen location defined by
001601  001762  //       : x, y, width and height with colour "colour".
001602  001763  //       :         state = 0 : sunken
001603  001764  //       :         state = 1 : raised
001604  001765  //       :         state = 2 : hide (draw object in background colour)
001605  001766  //returns: nothing
001606  001767        
001607  001768        
001608  001769        
001609  001770  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
001610  001771  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
001611  001772  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001612  001773  // Notes : Draws a 3 dimensional Slider Bar on the screen.
001613  001774  //       : Slider parameters are as follows:
001614  001775  //       :         mode = 0 : Slider recessed
001615  001776  //       :         mode = 1 : Slider raised
001616  001777  //       :         x1, y1 = top left corner
001617  001778  //       :         x2, y2 = bottom right corner
001618  001779  //       :         scale = n : sets the full scale range from 0 to n
001619  001780  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
001620  001781  //returns: scaled value of thumb position
001621  001782        
001622  001783        
001623  001784        
001624  001785  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
001625  001786  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
001626  001787  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
001627  001788  // Notes : Copies an area of a screen from xs,ys of size given by width and height
001628  001789  //       : and pastes it to another location determined by xd, yd.
001629  001790        
001630  001791  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
001631  001792  // Syntax: gfx_RGBto565(red, green, blue);
001632  001793  // Usage : gfx_RGBto565(arg1, arg2, arg3);
001633  001794  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
001634  001795        
001635  001796  func gfx_332to565("COLOUR8BIT"), 1;
001636  001797  // Syntax: gfx_332to565(colour);
001637  001798  // Usage : gfx_332to565(arg);
001638  001799  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
001639  001800        
001640  001801  func gfx_565to332("COLOUR16BIT"), 1;
001641  001802  // Syntax: gfx_565to332(colour);
001642  001803  // Usage : clor332 := gfx_565to332(arg);
001643  001804  // Notes : Returns the 8bit (332 format) colour value of an 16 bit (565 format) colour
001644  001805        
001645  001806  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
001646  001807  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
001647  001808  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
001648  001809  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
001649  001810  //       : Vertices must be specified in an anti-clockwise fashion
001650  001811        
001651  001812        
001652  001813  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
001653  001814  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
001654  001815  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001655  001816  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001656  001817  //       : Vertices must be minimum of 3 and can be specified in any fashion
001657  001818        
001658  001819        
001659  001820  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001660  001821  // Syntax: gfx_Offset(x, y);
001661  001822  // Usage : gfx_Offset(arg1, arg2);
001662  001823  // Notes : Set the screen offset
001663  001824        
001664  001825        
001665  001826        
001666  001827  func gfx_FillPattern("patptr", "mode"), 1;
001667  001828  // Syntax  : gfx_FillPattern(patternpointer);
001668  001829  // Usage   : gfx_FillPattern(PTN_BRICKS);
001669  001830  //         : Provides graphics fill pattern, (8 linear bytes, 1=pixel off)
001670  001831  // Notes   : "patptr" points to an 8x8 tile for rendering filled areas.
001671  001832  //         : Rendering is turned off with gfx_FillPattern(0);
001672  001833  //         : or gfx_FillPattern(OFF);
001673  001834  //         : "mode" maybe TRANSPARENT or OPAQUE (0 or 1), for OPAQUE
001674  001835  //         : mode, the current screen colour is used for the 'off'
001675  001836  //         : pixels, for transparent mode, the 'off' pixels are not drawn.
001676  001837  //         : gfx_FillPattern affects all filled object, including polygons.
001677  001838  //         : There are 32 builtin patterns, these are obtained using the
001678  001839  //         : pre-defined constants FILLPATTERN_0 to FILLPATTERN_31, or the
001679  001840  //         : names, eg PTN_BRICKS, PTN_CARGONET, PTN_CIRCUITS, etc.
001680  001841  //         : Note that the constants range from 0xFFE0 to 0xFFFF, any
001681  001842  //         : other value is assumed to be a pointer to a users 8 byte
001682  001843  //         : block pattern.
001683  001844  // Returns : returns the handle of the previous pattern.
001684  001845        
001685  001846        
001686  001847  func gfx_PieSlice("cx", "cy", "spread", "radius", "step", "startangle", "endangle", "mode", "colour"), 0;
001687  001848  // Syntax  : gfx_PieSlice(cx, cy, spread, radius, step, startangle, endangle, mode, colour);
001688  001849  // Usage   : gfx_PieSlice(120, 120, 0, 100, 8, 75, 145, 0, YELLOW);
001689  001850  // Notes   : Draws a 'pie slice' (filled arc) at "cx":"cy" with radius "radius", starting at "startangle"
001690  001851  //         : and ending at "endangle". "spread" is used to offset the centrepoint of the pieslice
001691  001852  //         : to shift a pie chart piece away from the centrepoint.
001692  001853  //         : Rendering can be obtained with gfx_FillPattern(PATTRN);
001693  001854  //         : or gfx_FillPattern(OFF); for no fill pattern.
001694  001855  //         : Step is the stepping angle increment for the fineness of the pie Slice.
001695  001856  //         : "mode" has the following effect
001696  001857  //         :   if mode = 0, no outline
001697  001858  //         :   if mode = 1, outer circumference line (using current object colour)
001698  001859  //         :   if mode = 2, outer circumference and slice lines ( (using current object colour)
001699  001860  // Returns : nothing.
001700  001861        
001701  001862        
001702  001863  func gfx_Arc("xc", "yc", "radius", "step", "startangle", "endangle", "mode"), 0;
001703  001864  // Syntax  : gfx_Arc(cx, cy, radius, step, startangle, endangle, mode);
001704  001865  // Usage   : gfx_Arc(120, 120, 0, 100, 8, 75, 145, 0);
001705  001866  // Notes   : Draws an arc at "cx":"cy" with radius "radius", starting at "startangle"
001706  001867  //         : and ending at "endangle". Colour is determined by curent object colour.
001707  001868  //         : Step is the stepping angle increment for the fineness of the arc.
001708  001869  //         : "mode" has the following effect
001709  001870  //         :   if mode = 0, outer circumference line only
001710  001871  //         :   if mode = 1, outer circumference and lines back to cy:cy
001711  001872  // Returns : nothing.
001712  001873        
001713  001874        
001714  001875  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
001715  001876  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
001716  001877  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
001717  001878  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
001718  001879  //         : determined by "radius".
001719  001880  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
001720  001881  // Returns : nothing.
001721  001882        
001722  001883        
001723  001884  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
001724  001885  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
001725  001886  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
001726  001887  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
001727  001888  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
001728  001889  //         : If "radius1" is zero, the inner rectangle will have square corners.
001729  001890  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
001730  001891  // Returns : nothing.
001731  001892        
001732  001893        
001733  001894  func gfx_RoundPanel("state", "x", "y", "width", "height", "radius", "bevelwidth", "colour"), 0;
001734  001895  // Syntax  : gfx_RoundPanel(style, x, y, width, height, radius, bevelwidth, colour);
001735  001896  // Usage   : gfx_RoundPanel(PANEL_RAISED, 100, 100, 30, 20, GRAY);
001736  001897  // Notes   : Draws a rounded panel at x, y, width and height may be zero allowing the function
001737  001898  //         : to be used for rounded panels, rounded buttons, circular buttons.
001738  001899  //         :         state = 0 : sunken
001739  001900  //         :         state = 1 : raised
001740  001901  //         :         state = 2 : hide (draw object in background colour)
001741  001902  //         : Bounding rectangle is x1-radius-bevelwidth, y1-radius-bevelwidth, x2+radius+bevelwidth, y2+radius+bevelwidth.
001742  001903  // Returns : nothing.
001743  001904        
001744  001905        
001745  001906  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
001746  001907  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
001747  001908  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
001748  001909  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
001749  001910  //         : "style" specifies the drawing mode
001750  001911  //         :     GRAD_DOWN         // gradient changes in the vertical direction
001751  001912  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
001752  001913  //         :     GRAD_UP           // gradient changes in the vertical direction
001753  001914  //         :     GRAD_LEFT         // gradient change in the horizontal direction
001754  001915  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
001755  001916  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
001756  001917  // Returns : nothing.
001757  001918        
001758  001919        
001759  001920  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
001760  001921  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
001761  001922  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
001762  001923  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
001763  001924  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
001764  001925  //         : to be used for rounded panels, rounded buttons, circular buttons.
001765  001926  //         : "style" specifies the drawing mode
001766  001927  //         :     GRAD_DOWN         // gradient changes in the vertical direction
001767  001928  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
001768  001929  //         :     GRAD_UP           // gradient changes in the vertical direction
001769  001930  //         :     GRAD_LEFT         // gradient change in the horizontal direction
001770  001931  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
001771  001932  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
001772  001933  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
001773  001934  // Returns : nothing.
001774  001935        
001775  001936        
001776  001937  func gfx_ReadBresLine("x1", "y1", "x2", "y2", "ptr"), 1;
001777  001938  // Syntax  : gfx_readBrezLine(x1, y1, x2, y2, ptr);
001778  001939  // Usage   : anArrayPtr := gfx_readBrezLine(10, 10, 50, 50, 0);  // read arbitrary line to array, let the function make the array for me
001779  001940  // Notes   : reads an arbitrary line from the display to an array.
001780  001941  //         : If "ptr" is 0, the correctly sized array is created, in which case
001781  001942  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
001782  001943  //         : is expected to point to a correctly sized array.
001783  001944  //         : NB if an array is supplied, its size must be large enough, and may
001784  001945  //         : be calculated:-
001785  001946  //         : bytecount := (MAX(ABS(x2-x1), ABS(y2-y1) + 1) * 2; // calc array size for mem_Alloc (which allocates byte storage)
001786  001947  //         : wordcount := (MAX(ABS(x2-x1), ABS(y2-y1) + 1);     // calc array size for fixed word array
001787  001948  // Returns : A pointer to the created aray, or the users array.
001788  001949  //         : In the case of ptr=0, if there is insufficient
001789  001950  //         : memory to create the array, zero is returned
001790  001951        
001791  001952        
001792  001953  func gfx_WriteBresLine("x1", "y1", "x2", "y2", "ptr"), 0;
001793  001954  // Syntax  : gfx_writeBrezLine(x1, y1, x2, y2, ptr), 0;
001794  001955  // Usage   : gfx_writeBrezLine(20, 20, 50, 50, anArrayPtr);   // write an array back to the arbitrary line
001795  001956  // Notes   : cast pixel values from array to arbitrary line "x1", "y1", "x2", "y2"
001796  001957  //         : "ptr" points to the array to be written.
001797  001958  // Returns : nothing
001798  001959        
001799  001960        
001800  001961  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
001801  001962  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
001802  001963  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
001803  001964  // Notes   : reads an arbitrary rectangular area from the display to an array.
001804  001965  //         : If "ptr" is 0, the correctly sized array is created, in which case
001805  001966  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
001806  001967  //         : is expected to point to a correctly sized array.
001807  001968  //         : NB if an array is supplied, its size must be large enough, and may
001808  001969  //         : be calculated:-
001809  001970  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
001810  001971  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
001811  001972  // Returns : A pointer to the created aray, or the users array.
001812  001973  //         : In the case of ptr=0, if there is insufficient
001813  001974  //         : memory to create the array, zero is returned
001814  001975        
001815  001976        
001816  001977  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
001817  001978  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
001818  001979  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
001819  001980  // Notes   : "ptr" points to the array to be written.
001820  001981  // Returns : nothing
001821  001982        
001822  001983        
001823  001984  func gfx_Get("mode"), 1;
001824  001985  // Syntax: gfx_Get(mode);
001825  001986  // Usage : arg1 := gfx_Get(arg);
001826  001987  // Notes : Returns various parameters to caller
001827  001988  //       :
001828  001989  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001829  001990  //       : var := gfx_Get(X_MAX);
001830  001991  //       : Returns the maximum horizontal value of the display
001831  001992  //       :
001832  001993  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001833  001994  //       : var := gfx_Get(Y_MAX);
001834  001995  //       : Returns the maximum vertical value of the display
001835  001996  //       :
001836  001997  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001837  001998  //       : var := gfx_Get(LEFT_POS);
001838  001999  //       : Returns the left location of the last drawn object
001839  002000  //       : such as a slider or button or an image/video
001840  002001  //       :
001841  002002  //       : mode = TOP_POS (mode 3) : Top location of Object
001842  002003  //       : var := gfx_Get(TOP_POS);
001843  002004  //       : Returns the top location of the last drawn object
001844  002005  //       : such as a slider or button or an image/video
001845  002006  //       :
001846  002007  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001847  002008  //       : var := gfx_Get(RIGHT_POS);
001848  002009  //       : Returns the right location of the last drawn object
001849  002010  //       : such as a slider or button or an image/video
001850  002011  //       :
001851  002012  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001852  002013  //       : var := gfx_Get(BOTTOM_POS );
001853  002014  //       : Returns the bottom location of the last drawn object
001854  002015  //       : such as a slider or button or an image/video
001855  002016  //       :
001856  002017  //       : mode = X_ORG (mode 6) : get current internal X position
001857  002018  //       : var := gfx_Get(X_ORG);
001858  002019  //       : Returns the internal X position that was set with
001859  002020  //       : gfx_MoveTo(x, y); or gfx_Set(X_ORG, pos);
001860  002021  //       :
001861  002022  //       : mode = Y_ORG (mode 7) : get current internal Y position
001862  002023  //       : var := gfx_Get(Y_ORG);
001863  002024  //       : Returns the internal X position that was set with
001864  002025  //       : gfx_MoveTo(x, y); or gfx_Set(Y_ORG, pos);
001865  002026  //       :
001866  002027        
001867  002028        
001868  002029  //------------------------------------------------------------------//
001869  002030  // Single parameter short-cuts                                      //
001870  002031  // for the gfx_Set functions                                        //
001871  002032  // These functions return the existing value before                 //
001872  002033  // the change is made.                                              //
001873  002034  //------------------------------------------------------------------//
001874  002035  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001875  002036  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001876  002037  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001877  002038  func gfx_Clipping("mode"), 1;                       // 3  graphics clipping ON/OFF
001878  002039  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001879  002040  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001880  002041  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001881  002042  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001882  002043  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001883  002044  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001884  002045  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001885  002046  func gfx_BevelRadius("radius"), 1;                  // 11 graphics button bevel radius
001886  002047  func gfx_BevelWidth("value"), 1;                    // 12 graphics button bevel width
001887  002048  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001888  002049  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001889  002050  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001890  002051        
001891  002052        
001892  002053  func gfx_PointWithinBox("x", "y", "&rectr"), 1;
001893  002054  // Syntax   : gfx_PointWithinBox(x, y, rect);
001894  002055  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=20; r[3]:=30;
001895  002056  //          : result := gfx_PointWithinBox(x, y, r); // check area at 100,200,119,229
001896  002057  // Notes    : rect is an array of 4 vars, x1, y1, width, height - using width co-ordinates
001897  002058  // returns  : Returns true if last touch co-ordinates are within the box test area.
001898  002059        
001899  002060        
001900  002061  func gfx_PointWithinRectangle("x", "y", "&recta"), 1;
001901  002062  // Syntax   : gfx_PointWithinRectangle(x, y, recta);
001902  002063  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=119; r[3]:=129;
001903  002064  //          : result := gfx_PointWithinRectangle(x, y, r); // check if point within area at 100,200,119,229
001904  002065  // Notes    : rect is an array of 4 vars, x1, y1, x2, y2 using absolute co-ordinates
001905  002066  // returns  : Returns true if x:y co-ordinates are within the rectangle test area.
001906  002067        
001907  002068        
001908  002069  func __reserved17(), 0; // do not remove
001909  002070  func __reserved18(), 0; // do not remove
001910  002071  func __reserved19(), 0; // do not remove
001911  002072  func __reserved20(), 0; // do not remove
001912  002073  func __reserved21(), 0; // do not remove
001913  002074  func __reserved22(), 0; // do not remove
001914  002075        
001915  002076        
001916  002077  // built in fill pattern constants for function gfx_FillPattern
001917  002078  #CONST
001918  002111  #END
001919  002112        
001920  002113  #CONST
001921  002146  #END
001922  002147        
001923  002148  //------------------------------------------------------------------//
001924  002149  //     gradient control constants                                   //
001925  002150  //------------------------------------------------------------------//
001926  002151  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
001927  002151  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
001928  002152  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
001929  002152  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
001930  002153  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
001931  002153  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
001932  002154  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
001933  002154  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
001934  002155  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
001935  002155  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
001936  002156  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
001937  002156  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
001938  002157        
001939  002158        
001940  002159        
001941  002160        
001942  002161  //------------------------------------------------------------------//
001943  002162  // uSD/FLASH Function Prototypes                                    //
001944  002163  //------------------------------------------------------------------//
001945  002164  func media_Video("x", "y"), 0;                      // display movie at position x y
001946  002165  // Syntax: media_Video(x, y);
001947  002166  // Usage : media_Video(arg1, arg2);
001948  002167  // Notes : Play a Video/Animation clip from the uSD card at screen location
001949  002168  //       : specified by x,y (top left corner). The location of the clip in the
001950  002169  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001951  002170        
001952  002171  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001953  002172  // Syntax: media_VideoFrame(Frame_number);
001954  002173  // Usage : arg1 := media_VideoFrame();
001955  002174  // Notes : After a pointer to a valid video has been set with media_SetSector,
001956  002175  //       : calling this function shows each fram sequentially, returning
001957  002176  //       : the number of frames remaining. The position of the image is
001958  002177  //     : at the current origin as set with gfx_MoveTo(...);
001959  002178        
001960  002179  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001961  002180  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001962  002181  // Usage : media_SetAdd(arg1, arg2);
001963  002182  // Notes : Set uSD internal Address pointer for bytewise access
001964  002183        
001965  002184  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001966  002185  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001967  002186  // Usage : media_SetSector(arg1, arg2);
001968  002187  // Notes : Set uSD internal Sector pointer for sector block access
001969  002188        
001970  002189  func media_RdSector("*destination"), 1;
001971  002190  // Syntax: media_RdSector(*destination);
001972  002191  // Usage : media_RdSector(rdblock);
001973  002192  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001974  002193  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001975  002194  //       : After the read the Sector pointer is automatically incremented by 1.
001976  002195  //       : Returns TRUE if uSD response was TRUE
001977  002196        
001978  002197  func media_WrSector("*source"), 1;
001979  002198  // Syntax: media_WrSector(*source);
001980  002199  // Usage : media_WrSector(wrblock);
001981  002200  // Notes : Writes 512 bytes (256 words) from a source memory block
001982  002201  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001983  002202  //       : pointer is automatically incremented by 1.
001984  002203  //       : Returns TRUE if uSD response was TRUE
001985  002204        
001986  002205  func media_ReadByte(), 1;                // read a byte at the current stream position
001987  002206  // Syntax: media_RdByte();
001988  002207  // Usage : var := media_RdByte();
001989  002208  // Notes : Reads and Returns a single byte of data from the
001990  002209  //       : uSD card pointed to by the internal Address pointer.
001991  002210  //       : After the read the Address pointer is automatically
001992  002211  //       : incremented by 1.
001993  002212        
001994  002213  func media_ReadWord(), 1;                // read a word at the current stream position
001995  002214  // Syntax: media_ReadWord();
001996  002215  // Usage : var := media_ReadWord();
001997  002216  // *Notes : Reads and Returns a single word of data from the
001998  002217  //       : uSD card pointed to by the internal Address pointer.
001999  002218  //       : After the read the Address pointer is automatically
002000  002219  //       : incremented by 2.
002001  002220        
002002  002221  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
002003  002222  // Syntax: media_WriteByte(arg1);
002004  002223  // Usage : var := media_WriteByte(arg1);
002005  002224  // *Notes : Writes and Returns xxxxx
002006  002225  //       : After the write the Address pointer is automatically
002007  002226  //       : incremented by 1.
002008  002227        
002009  002228  func media_WriteWord("word"), 1;            // write a word to the current stream position
002010  002229  // Syntax: media_WriteWord(arg1);
002011  002230  // Usage : var := media_WriteWord(arg1);
002012  002231  // *Notes : Writes and Returns xxxxx
002013  002232  //       : After the write the Address pointer is automatically
002014  002233  //       : incremented by 2.
002015  002234        
002016  002235  func media_Image("x", "y"), 0;            // display image at position x y
002017  002236  // Syntax: media_Image(x, y);
002018  002237  // Usage : media_Image(arg1, arg2);
002019  002238  // Notes : Display an image from the uSD card at screen location
002020  002239  //       : specified by x,y (top left corner). The location of the
002021  002240  //       : Image in the uSD card must be specified by
002022  002241  //       : media_setSector(Image_Sector_Add) function.
002023  002242        
002024  002243  func media_Flush(), 1;                    // after writing to media, flush the sector and write
002025  002244  // Syntax: media_Flush();
002026  002245  // Usage : var := media_Flush();
002027  002246  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
002028  002247  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
002029  002248        
002030  002249  func media_Init(), 1;                    // initialize uSD card
002031  002250  // Usage : media_Init();
002032  002251  // Notes : Initialise uSD CARD
002033  002252  //       : Response: 0 = No Card
002034  002253  //       :           1 = Card Initialised
002035  002254        
002036  002255  func __reserved23(), 0; // do not remove
002037  002256  func __reserved24(), 0; // do not remove
002038  002257  func __reserved25(), 0; // do not remove
002039  002258  func __reserved26(), 0; // do not remove
002040  002259        
002041  002260  //==============================================//
002042  002261  // Communications Function Prototypes           //
002043  002262  // NB Primary COM port has fixed pins,          //
002044  002263  // COM1, COM2 and COM3 must have pins assigned. //
002045  002264  //==============================================//
002046  002265  func setbaud("baudnum"), 0;            // set baud rate of COM0
002047  002266  // Syntax: setbaud(baud_number);
002048  002267  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
002049  002268  // *Notes : argument specifies the baud rate using pre-defined constant.
002050  002269  //       : The pre-defined constant is a value of 0-19 , and internally
002051  002270  //       : this is used as a table pointer to get the baud rate divisor
002052  002271  //       : value for one of the 20 selected baud rates, control is then
002053  002272  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
002054  002273  //       : The pre-defined constants equate to a value of 0-19.
002055  002274  //       : If a value other than 0-19 is used, a run time error (eror 25)
002056  002275  //       : will occur.
002057  002276        
002058  002277  // baud divisor rates for legacy setbaud(n);
002059  002278  #CONST
002060  002300  #END
002061  002301        
002062  002302        
002063  002303  func com_SetBaud("comport","baudrate/10"), 1;
002064  002304  // Syntax: com_SetBaud("comport","baudrate/10");
002065  002305  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
002066  002306  // Notes : sets to any viable baud rate from 160 to 655350
002067  002307  // return true if baud rate was acceptable
002068  002308        
002069  002309        
002070  002310  func COM1_RX_pin("pin"), 1;        // select the hardware pin for the COM1 receive line
002071  002311  // Usage : COM1_RX_pin(PA0); // set COM1 RX to PA0 pin
002072  002312  // Notes : Selects the hardware pin for COM1 receive line.
002073  002313  //       : Note that only a single pin can be mapped to COM1 RX.
002074  002314  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002075  002315  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002076  002316  //       : If the pin argument is 0 the function has no effect
002077  002317  //       : The pin is automatically set to an input.
002078  002318  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002079  002319  //       : it is necessary to configure the input pin first, eg
002080  002320  //       :     COM1_RX_pin(PA7);     // configure COM1 RX to PA7 (this disconnects anything else)
002081  002321  //       :     COM1_TX_pin(PA7));    // configure COM1 TX to PA7
002082  002322  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002083  002323        
002084  002324  func COM2_RX_pin("pin"), 1;        // select the hardware pin for the COM2 receive line
002085  002325  // Usage : COM2_RX_pin(PA0); // set COM2 RX to PA0 pin
002086  002326  // Notes : Selects the hardware pin for COM2 receive line.
002087  002327  //       : Note that only a single pin can be mapped to COM2 RX.
002088  002328  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002089  002329  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002090  002330  //       : If the pin argument is 0 the function has no effect
002091  002331  //       : The pin is automatically set to an input.
002092  002332  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002093  002333  //       : it is necessary to configure the input pin first, eg
002094  002334  //       :     COM2_RX_pin(PA7);     // configure COM2 RX to PA7 (this disconnects anything else)
002095  002335  //       :     COM2_TX_pin(PA7));    // configure COM2 TX to PA7
002096  002336  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002097  002337        
002098  002338  func COM3_RX_pin("pin"), 1;        // select the hardware pin for the COM3 receive line
002099  002339  // Usage : COM3_RX_pin(PA0); // set COM3 RX to PA0 pin
002100  002340  // Notes : Selects the hardware pin for COM3 receive line.
002101  002341  //       : Note that only a single pin can be mapped to COM3 RX.
002102  002342  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002103  002343  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002104  002344  //       : If the pin argument is 0 the function has no effect
002105  002345  //       : The pin is automatically set to an input.
002106  002346  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002107  002347  //       : it is necessary to configure the input pin first, eg
002108  002348  //       :     COM3_RX_pin(PA7);     // configure COM3 RX to PA7 (this disconnects anything else)
002109  002349  //       :     COM3_TX_pin(PA7));    // configure COM3 TX to PA7
002110  002350  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002111  002351        
002112  002352        
002113  002353  func COM1_TX_pin("pin"), 1;        // select the hardware pin for COM1 transmit line
002114  002354  // Syntax: COM1_TX_pin(pin);
002115  002355  // Usage : COM1_TX_pin(PA2); // set COM1 TX to PA2 pin
002116  002356  // Notes : Select the hardware pin for COMx transmit line.
002117  002357  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002118  002358  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002119  002359  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002120  002360  //       : The pin is automatically set to an output.
002121  002361  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002122  002362        
002123  002363  func COM2_TX_pin("pin"), 1;        // select the hardware pin for COM2 transmit line
002124  002364  // Syntax: COM2_TX_pin(pin);
002125  002365  // Usage : COM2_TX_pin(PA2); // set COM2 TX to PA2 pin
002126  002366  // Notes : Select the hardware pin for COMx transmit line.
002127  002367  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002128  002368  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002129  002369  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002130  002370  //       : The pin is automatically set to an output.
002131  002371  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002132  002372        
002133  002373  func COM3_TX_pin("pin"), 1;        // select the hardware pin for COM3 transmit line
002134  002374  // Syntax: COM3_TX_pin(pin);
002135  002375  // Usage : COM3_TX_pin(PA2); // set COM3 TX to PA2 pin
002136  002376  // Notes : Select the hardware pin for COMx transmit line.
002137  002377  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002138  002378  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002139  002379  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002140  002380  //       : The pin is automatically set to an output.
002141  002381  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002142  002382        
002143  002383  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
002144  002384  // Syntax: com_Init(buffer, bufsize, qualifier);
002145  002385  // Usage1: com_Init(mybuf, 20, 0);
002146  002386  // Usage2: com_Init(mybuf, 20, ':');
002147  002387  // Notes : initialize a serial capture buffer for the comms input
002148  002388  //       : The program must declare a var array as a circular buffer.
002149  002389  //       : Usage1 declares a circular buffer which will continually
002150  002390  //       : buffer characters.
002151  002391  //       : Usage2 must receive ':' before any characters will
002152  002392  //       : accumulate in the buffer.
002153  002393        
002154  002394  func com1_Init("buf","bufsize","qualifier"), 0;
002155  002395  // Syntax: com1_Init(buffer, bufsize, qualifier);
002156  002396  // Usage1: com1_Init(mybuf, 20, 0);
002157  002397  // Usage2: com1_Init(mybuf, 20, ':');
002158  002398  // Notes : initialize a serial capture buffer for the comms input
002159  002399  //       : The program must declare a var array as a circular buffer.
002160  002400  //       : Usage1 declares a circular buffer which will continually
002161  002401  //       : buffer characters.
002162  002402  //       : Usage2 must receive ':' before any characters will
002163  002403  //       : accumulate in the buffer.
002164  002404        
002165  002405  func com2_Init("buf","bufsize","qualifier"), 0;
002166  002406  // Syntax: com2_Init(buffer, bufsize, qualifier);
002167  002407  // Usage1: com2_Init(mybuf, 20, 0);
002168  002408  // Usage2: com2_Init(mybuf, 20, ':');
002169  002409  // Notes : initialize a serial capture buffer for the comms input
002170  002410  //       : The program must declare a var array as a circular buffer.
002171  002411  //       : Usage1 declares a circular buffer which will continually
002172  002412  //       : buffer characters.
002173  002413  //       : Usage2 must receive ':' before any characters will
002174  002414  //       : accumulate in the buffer.
002175  002415        
002176  002416  func com3_Init("buf","bufsize","qualifier"), 0;
002177  002417  // Syntax: com3_Init(buffer, bufsize, qualifier);
002178  002418  // Usage1: com3_Init(mybuf, 20, 0);
002179  002419  // Usage2: com3_Init(mybuf, 20, ':');
002180  002420  // Notes : initialize a serial capture buffer for the comms input
002181  002421  //       : The program must declare a var array as a circular buffer.
002182  002422  //       : Usage1 declares a circular buffer which will continually
002183  002423  //       : buffer characters.
002184  002424  //       : Usage2 must receive ':' before any characters will
002185  002425  //       : accumulate in the buffer.
002186  002426        
002187  002427        
002188  002428  func serin(), 1;                // read a byte from primary com port COM0
002189  002429  // Syntax: serin();
002190  002430  // Usage : char := serin();
002191  002431  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
002192  002432  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002193  002433  //     : The default Baud Rate for COM0 is 115,200 bits per second or 115,200 baud.
002194  002434  //     : The baud rate can be changed under program control by using the setbaud(...)
002195  002435  //     : or the com_SetBaud(...) function.
002196  002436  //     : COM0 pins cannot be mapped, and are fixed as pins 42 and 33 (host adaptor / programming)
002197  002437  //     : serin may be buffered (refer to com_Init function above)
002198  002438  //     : Returns: -1 if no character is available
002199  002439  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002200  002440  //     : Returns: positive value 0 to 255 for a valid character received
002201  002441        
002202  002442  func serin1(), 1;
002203  002443  // Syntax: serinx();
002204  002444  // Usage : char := serinx();
002205  002445  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002206  002446  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002207  002447  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002208  002448  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002209  002449  //     : serinx may be buffered (refer to comx_Init function above)
002210  002450  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002211  002451  //     : Returns: -1 if no character is available
002212  002452  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002213  002453  //     : Returns: positive value 0 to 255 for a valid character received
002214  002454        
002215  002455  func serin2(), 1;
002216  002456  // Syntax: serinx();
002217  002457  // Usage : char := serinx();
002218  002458  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002219  002459  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002220  002460  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002221  002461  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002222  002462  //     : serinx may be buffered (refer to comx_Init function above)
002223  002463  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002224  002464  //     : Returns: -1 if no character is available
002225  002465  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002226  002466  //     : Returns: positive value 0 to 255 for a valid character received
002227  002467        
002228  002468  func serin3(), 1;
002229  002469  // Syntax: serinx();
002230  002470  // Usage : char := serinx();
002231  002471  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002232  002472  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002233  002473  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002234  002474  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002235  002475  //     : serinx may be buffered (refer to comx_Init function above)
002236  002476  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002237  002477  //     : Returns: -1 if no character is available
002238  002478  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002239  002479  //     : Returns: positive value 0 to 255 for a valid character received
002240  002480        
002241  002481  func serout("char"), 0;                // write a byte to COM0
002242  002482  // Syntax: serout1("char");
002243  002483  // Usage : serout1(ch);
002244  002484  // Notes : send character to COM0
002245  002485        
002246  002486  func serout1("char"), 0;
002247  002487  // Syntax: seroutx("char");
002248  002488  // Usage : serout1(ch);
002249  002489  // Notes : send character to COMx
002250  002490        
002251  002491  func serout2("char"), 0;
002252  002492  // Syntax: seroutx("char");
002253  002493  // Usage : serout1(ch);
002254  002494  // Notes : send character to COMx
002255  002495        
002256  002496  func serout3("char"), 0;
002257  002497  // Syntax: seroutx("char");
002258  002498  // Usage : serout1(ch);
002259  002499  // Notes : send character to COMx
002260  002500        
002261  002501  func com_Reset(), 0;                 // reset the comms receiver
002262  002502  // Syntax: com_Reset();
002263  002503  // Usage : com_Reset();
002264  002504  // Notes : reset comms to default polled mode
002265  002505        
002266  002506  func com1_Reset(), 0;
002267  002507  // Syntax: com_Reset();
002268  002508  // Usage : com_Reset();
002269  002509  // Notes : reset comms to default polled mode
002270  002510        
002271  002511  func com2_Reset(), 0;
002272  002512  // Syntax: com_Reset();
002273  002513  // Usage : com_Reset();
002274  002514  // Notes : reset comms to default polled mode
002275  002515        
002276  002516  func com3_Reset(), 0;
002277  002517  // Syntax: com_Reset();
002278  002518  // Usage : com_Reset();
002279  002519  // Notes : reset comms to default polled mode
002280  002520        
002281  002521  func com_Count(), 1;                // return count of characters in receive buffer
002282  002522  // Syntax: com_Count();
002283  002523  // Usage : arg := com_Count();
002284  002524  // Notes : return count of buffered characters in buffer attachment
002285  002525        
002286  002526  func com1_Count(), 1;
002287  002527  // Syntax: com_Count();
002288  002528  // Usage : arg := com_Count();
002289  002529  // Notes : return count of buffered characters in buffer attachment
002290  002530        
002291  002531  func com2_Count(), 1;
002292  002532  // Syntax: com_Count();
002293  002533  // Usage : arg := com_Count();
002294  002534  // Notes : return count of buffered characters in buffer attachment
002295  002535        
002296  002536  func com3_Count(), 1;
002297  002537  // Syntax: com_Count();
002298  002538  // Usage : arg := com_Count();
002299  002539  // Notes : return count of buffered characters in buffer attachment
002300  002540        
002301  002541  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
002302  002542  // Syntax: com_Full();
002303  002543  // Usage : if (com_Full() ,,,, go read buffer;
002304  002544  // Notes : return true if buffer full (not necessarily an error if
002305  002545  //       : buffer is sized to a packet size)
002306  002546        
002307  002547  func com1_Full(), 1;
002308  002548  // Syntax: com_Full();
002309  002549  // Usage : if (com_Full() ,,,, go read buffer;
002310  002550  // Notes : return true if buffer full (not necessarily an error if
002311  002551  //       : buffer is sized to a packet size)
002312  002552        
002313  002553  func com2_Full(), 1;
002314  002554  // Syntax: com_Full();
002315  002555  // Usage : if (com_Full() ,,,, go read buffer;
002316  002556  // Notes : return true if buffer full (not necessarily an error if
002317  002557  //       : buffer is sized to a packet size)
002318  002558        
002319  002559  func com3_Full(), 1;
002320  002560  // Syntax: com_Full();
002321  002561  // Usage : if (com_Full() ,,,, go read buffer;
002322  002562  // Notes : return true if buffer full (not necessarily an error if
002323  002563  //       : buffer is sized to a packet size)
002324  002564        
002325  002565  func com_Error(), 1;                // return comms errors comms error occurred
002326  002566  // Syntax: comx_Error();
002327  002567  // Usage : if (com_Error() ) ...... take recovery action;
002328  002568  // Notes : return non zero if any errors low level comms errors occured
002329  002569  // returns :
002330  002570  // bit0 = Receiver Overflow Error
002331  002571  // bit1 = Receiver Framing Error
002332  002572  // bit2 = Transmit Buffer Overflow
002333  002573        
002334  002574  func com1_Error(), 1;
002335  002575  // Syntax: comx_Error();
002336  002576  // Usage : if (com_Error() ) ...... take recovery action;
002337  002577  // Notes : return non zero if any errors low level comms errors occured
002338  002578  // returns :
002339  002579  // bit0 = Receiver Overflow Error
002340  002580  // bit1 = Receiver Framing Error
002341  002581  // bit2 = Transmit Buffer Overflow
002342  002582        
002343  002583  func com2_Error(), 1;
002344  002584  // Syntax: comx_Error();
002345  002585  // Usage : if (com_Error() ) ...... take recovery action;
002346  002586  // Notes : return non zero if any errors low level comms errors occured
002347  002587  // returns :
002348  002588  // bit0 = Receiver Overflow Error
002349  002589  // bit1 = Receiver Framing Error
002350  002590  // bit2 = Transmit Buffer Overflow
002351  002591        
002352  002592  func com3_Error(), 1;
002353  002593  // Syntax: comx_Error();
002354  002594  // Usage : if (com_Error() ) ...... take recovery action;
002355  002595  // Notes : return non zero if any errors low level comms errors occured
002356  002596  // returns :
002357  002597  // bit0 = Receiver Overflow Error
002358  002598  // bit1 = Receiver Framing Error
002359  002599  // bit2 = Transmit Buffer Overflow
002360  002600        
002361  002601  func com_Sync(), 1;                // returns TRUE if qualifier has been received
002362  002602  // Usage : comx_Sync();
002363  002603  // return true if sync character has been received in com_Init("...") mode
002364  002604        
002365  002605  func com1_Sync(), 1;
002366  002606  // Usage : comx_Sync();
002367  002607  // return true if sync character has been received in com_Init("...") mode
002368  002608        
002369  002609  func com2_Sync(), 1;
002370  002610  // Usage : comx_Sync();
002371  002611  // return true if sync character has been received in com_Init("...") mode
002372  002612        
002373  002613  func com3_Sync(), 1;
002374  002614  // Usage : comx_Sync();
002375  002615  // return true if sync character has been received in com_Init("...") mode
002376  002616        
002377  002617        
002378  002618  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
002379  002619  // Usage : com_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002380  002620  // Usage : com_TXbuffer(0, 0, 0);             // revert to non buffered service
002381  002621  // Notes : initialize a serial buffer for the COM0 output.
002382  002622  //       : The program must declare a var array as a circular buffer.
002383  002623  //       : When a TX buffer is declared for comms, the transmission
002384  002624  //       : of characters becomes non blocking. If the buffer has
002385  002625  //       : insufficient space to accept the next character from a
002386  002626  //       : serout_x() function, the excess characters will be ignored,
002387  002627  //       : and the com_Full_x() error will be asserted.   If the
002388  002628  //       : TX buffer is no longer required, just set the buffer pointer
002389  002629  //       : to zero, the size in this case doesnt matter and is ignored.
002390  002630  //       : The function can resize or reallocated to another buffer at
002391  002631  //       : any time. The buffer is flushed before any changes are made.
002392  002632  //       : "pin" designates an IO pin to control a bi-directional
002393  002633  //       : control device for half duplex mode. "pin" will go HI at the
002394  002634  //       : start of a transmission, and will return low after the final
002395  002635  //       : byte is transmitted. If not required, just set "pin" to zero.
002396  002636        
002397  002637  func com1_TXbuffer("buf", "bufsize", "pin"), 0;
002398  002638  // Usage : com1_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002399  002639  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
002400  002640  // Notes : initialize a serial buffer for the COM0 output.
002401  002641  //       : The program must declare a var array as a circular buffer.
002402  002642  //       : When a TX buffer is declared for comms, the transmission
002403  002643  //       : of characters becomes non blocking. If the buffer has
002404  002644  //       : insufficient space to accept the next character from a
002405  002645  //       : serout_x() function, the excess characters will be ignored,
002406  002646  //       : and the com_Full_x() error will be asserted.   If the
002407  002647  //       : TX buffer is no longer required, just set the buffer pointer
002408  002648  //       : to zero, the size in this case doesnt matter and is ignored.
002409  002649  //       : The function can resize or reallocated to another buffer at
002410  002650  //       : any time. The buffer is flushed before any changes are made.
002411  002651  //       : "pin" designates an IO pin to control a bi-directional
002412  002652  //       : control device for half duplex mode. "pin" will go HI at the
002413  002653  //       : start of a transmission, and will return low after the final
002414  002654  //       : byte is transmitted. If not required, just set "pin" to zero.
002415  002655        
002416  002656  func com2_TXbuffer("buf", "bufsize", "pin"), 0;
002417  002657  // Usage : com2_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002418  002658  // Usage : com2_TXbuffer(0, 0, 0);              // revert to non buffered service
002419  002659  // Notes : initialize a serial buffer for the COM0 output.
002420  002660  //       : The program must declare a var array as a circular buffer.
002421  002661  //       : When a TX buffer is declared for comms, the transmission
002422  002662  //       : of characters becomes non blocking. If the buffer has
002423  002663  //       : insufficient space to accept the next character from a
002424  002664  //       : serout_x() function, the excess characters will be ignored,
002425  002665  //       : and the com_Full_x() error will be asserted.   If the
002426  002666  //       : TX buffer is no longer required, just set the buffer pointer
002427  002667  //       : to zero, the size in this case doesnt matter and is ignored.
002428  002668  //       : The function can resize or reallocated to another buffer at
002429  002669  //       : any time. The buffer is flushed before any changes are made.
002430  002670  //       : "pin" designates an IO pin to control a bi-directional
002431  002671  //       : control device for half duplex mode. "pin" will go HI at the
002432  002672  //       : start of a transmission, and will return low after the final
002433  002673  //       : byte is transmitted. If not required, just set "pin" to zero.
002434  002674        
002435  002675  func com3_TXbuffer("buf", "bufsize", "pin"), 0;
002436  002676  // Usage : com3_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002437  002677  // Usage : com3_TXbuffer(0, 0, 0);              // revert to non buffered service
002438  002678  // Notes : initialize a serial buffer for the COM0 output.
002439  002679  //       : The program must declare a var array as a circular buffer.
002440  002680  //       : When a TX buffer is declared for comms, the transmission
002441  002681  //       : of characters becomes non blocking. If the buffer has
002442  002682  //       : insufficient space to accept the next character from a
002443  002683  //       : serout_x() function, the excess characters will be ignored,
002444  002684  //       : and the com_Full_x() error will be asserted.   If the
002445  002685  //       : TX buffer is no longer required, just set the buffer pointer
002446  002686  //       : to zero, the size in this case doesnt matter and is ignored.
002447  002687  //       : The function can resize or reallocated to another buffer at
002448  002688  //       : any time. The buffer is flushed before any changes are made.
002449  002689  //       : "pin" designates an IO pin to control a bi-directional
002450  002690  //       : control device for half duplex mode. "pin" will go HI at the
002451  002691  //       : start of a transmission, and will return low after the final
002452  002692  //       : byte is transmitted. If not required, just set "pin" to zero.
002453  002693        
002454  002694        
002455  002695  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
002456  002696  // Syntax: com_TXcount();
002457  002697  // Usage : arg := com_Count();
002458  002698  // Notes : return count of characters remaining in COM0 transmit buffer
002459  002699  //       : that was previously allocated with com_TXbuffer(...);
002460  002700        
002461  002701  func com1_TXcount(), 1;
002462  002702  // Syntax: com_TXcount();
002463  002703  // Usage : arg := com_Count();
002464  002704  // Notes : return count of characters remaining in COM0 transmit buffer
002465  002705  //       : that was previously allocated with com_TXbuffer(...);
002466  002706        
002467  002707  func com2_TXcount(), 1;
002468  002708  // Syntax: com_TXcount();
002469  002709  // Usage : arg := com_Count();
002470  002710  // Notes : return count of characters remaining in COM0 transmit buffer
002471  002711  //       : that was previously allocated with com_TXbuffer(...);
002472  002712        
002473  002713  func com3_TXcount(), 1;
002474  002714  // Syntax: com_TXcount();
002475  002715  // Usage : arg := com_Count();
002476  002716  // Notes : return count of characters remaining in COM0 transmit buffer
002477  002717  //       : that was previously allocated with com_TXbuffer(...);
002478  002718        
002479  002719  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
002480  002720  // Usage : arg := com_TXemptyEvent();
002481  002721  // Notes : If a comms TX buffer that was previously allocated with
002482  002722  //       : com_TXbuffer(...);, this function can be used to set up
002483  002723  //       : a function to be called when the COM0 TX buffer is empty.
002484  002724  //       : This is useful for either reloading the TX buffer, setting
002485  002725  //       : or clearing a pin to change the direction of eg a RS485
002486  002726  //       : line driver, or any other form of traffic control.
002487  002727  //       : The event function must not have any parameters.
002488  002728  //       : To disable the event, simply call com_TXemptyEvent(0).
002489  002729  //       : com_TXbuffer(...); also resets any active event.
002490  002730  //       : com_TXemptyEvent returns any previous event function
002491  002731  //       : address, or zero if there was no previous function.
002492  002732        
002493  002733  func com1_TXemptyEvent("function"), 1;
002494  002734  // Usage : arg := com1_TXemptyEvent();
002495  002735  // Notes : If a comms TX buffer that was previously allocated with
002496  002736  //       : com_TXbuffer(...);, this function can be used to set up
002497  002737  //       : a function to be called when the COM0 TX buffer is empty.
002498  002738  //       : This is useful for either reloading the TX buffer, setting
002499  002739  //       : or clearing a pin to change the direction of eg a RS485
002500  002740  //       : line driver, or any other form of traffic control.
002501  002741  //       : The event function must not have any parameters.
002502  002742  //       : To disable the event, simply call com_TXemptyEvent(0).
002503  002743  //       : com_TXbuffer(...); also resets any active event.
002504  002744  //       : com_TXemptyEvent returns any previous event function
002505  002745  //       : address, or zero if there was no previous function.
002506  002746        
002507  002747  func com2_TXemptyEvent("function"), 1;
002508  002748  // Usage : arg := com2_TXemptyEvent();
002509  002749  // Notes : If a comms TX buffer that was previously allocated with
002510  002750  //       : com_TXbuffer(...);, this function can be used to set up
002511  002751  //       : a function to be called when the COM0 TX buffer is empty.
002512  002752  //       : This is useful for either reloading the TX buffer, setting
002513  002753  //       : or clearing a pin to change the direction of eg a RS485
002514  002754  //       : line driver, or any other form of traffic control.
002515  002755  //       : The event function must not have any parameters.
002516  002756  //       : To disable the event, simply call com_TXemptyEvent(0).
002517  002757  //       : com_TXbuffer(...); also resets any active event.
002518  002758  //       : com_TXemptyEvent returns any previous event function
002519  002759  //       : address, or zero if there was no previous function.
002520  002760        
002521  002761  func com3_TXemptyEvent("function"), 1;
002522  002762  // Usage : arg := com3_TXemptyEvent();
002523  002763  // Notes : If a comms TX buffer that was previously allocated with
002524  002764  //       : com_TXbuffer(...);, this function can be used to set up
002525  002765  //       : a function to be called when the COM0 TX buffer is empty.
002526  002766  //       : This is useful for either reloading the TX buffer, setting
002527  002767  //       : or clearing a pin to change the direction of eg a RS485
002528  002768  //       : line driver, or any other form of traffic control.
002529  002769  //       : The event function must not have any parameters.
002530  002770  //       : To disable the event, simply call com_TXemptyEvent(0).
002531  002771  //       : com_TXbuffer(...); also resets any active event.
002532  002772  //       : com_TXemptyEvent returns any previous event function
002533  002773  //       : address, or zero if there was no previous function.
002534  002774        
002535  002775  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
002536  002776  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
002537  002777  // Notes : Expecting that a comms TX buffer that was previously allocated with
002538  002778  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002539  002779  //       : the buffer being sent wile it is being loaded. Mormally, when
002540  002780  //       : using buffered comms, the transmit process will begin
002541  002781  //       : immediately. This is often undesirable for 2 reasons,
002542  002782  //       : 1] you may wish to build a packet then send it later
002543  002783  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002544  002784  //       : as the FIFO buffer is constantly trying to empty while
002545  002785  //       : you are busy tring to fill it.
002546  002786  // return -1 if function is called illegally when TX comms is not buffered.
002547  002787  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002548  002788  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002549  002789        
002550  002790  func com1_TXbufferHold("state"), 1;
002551  002791  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
002552  002792  // Notes : Expecting that a comms TX buffer that was previously allocated with
002553  002793  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002554  002794  //       : the buffer being sent wile it is being loaded. Mormally, when
002555  002795  //       : using buffered comms, the transmit process will begin
002556  002796  //       : immediately. This is often undesirable for 2 reasons,
002557  002797  //       : 1] you may wish to build a packet then send it later
002558  002798  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002559  002799  //       : as the FIFO buffer is constantly trying to empty while
002560  002800  //       : you are busy tring to fill it.
002561  002801  // return -1 if function is called illegally when TX comms is not buffered.
002562  002802  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002563  002803  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002564  002804        
002565  002805  func com2_TXbufferHold("state"), 1;
002566  002806  // Usage : arg := com2_TXbufferHold(OFF);  // start sending the buffer
002567  002807  // Notes : Expecting that a comms TX buffer that was previously allocated with
002568  002808  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002569  002809  //       : the buffer being sent wile it is being loaded. Mormally, when
002570  002810  //       : using buffered comms, the transmit process will begin
002571  002811  //       : immediately. This is often undesirable for 2 reasons,
002572  002812  //       : 1] you may wish to build a packet then send it later
002573  002813  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002574  002814  //       : as the FIFO buffer is constantly trying to empty while
002575  002815  //       : you are busy tring to fill it.
002576  002816  // return -1 if function is called illegally when TX comms is not buffered.
002577  002817  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002578  002818  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002579  002819        
002580  002820  func com3_TXbufferHold("state"), 1;
002581  002821  // Usage : arg := com3_TXbufferHold(OFF);  // start sending the buffer
002582  002822  // Notes : Expecting that a comms TX buffer that was previously allocated with
002583  002823  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002584  002824  //       : the buffer being sent wile it is being loaded. Mormally, when
002585  002825  //       : using buffered comms, the transmit process will begin
002586  002826  //       : immediately. This is often undesirable for 2 reasons,
002587  002827  //       : 1] you may wish to build a packet then send it later
002588  002828  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002589  002829  //       : as the FIFO buffer is constantly trying to empty while
002590  002830  //       : you are busy tring to fill it.
002591  002831  // return -1 if function is called illegally when TX comms is not buffered.
002592  002832  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002593  002833  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002594  002834        
002595  002835  func com_Mode("8" ,"N", "1", "comport"), 1 ;
002596  002836  // Syntax   : comx_Mode("databits", "parity", "Stopbits", "comport");
002597  002837  // Usage    : comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
002598  002838  // *Notes   : Data Bits must be 8
002599  002839  //          : Parity may be 'N', 'O' or 'E'.
002600  002840  //          : Stop Bits may be 1 or 2.
002601  002841  // returns true if mode was acceptable
002602  002842        
002603  002843  func com_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
002604  002844  // Syntax   : com_TXblock("buf", "bufsize");
002605  002845  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
002606  002846  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
002607  002847  //          : if a transmit buffer is active and space is available this function will return almost
002608  002848  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
002609  002849        
002610  002850  func com_RXblock("buf", "bufsize"), 0;                       // commence a block reception
002611  002851  // Syntax   : com_RXblock("buf", "bufsize");
002612  002852  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
002613  002853  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
002614  002854  //          : if a receive buffer is active and bufsize characters are available this function will return almost
002615  002855  //          : immediately otherwise it will block until until the required bytes are received.
002616  002856        
002617  002857  func __reserved30(), 0; // do not remove
002618  002858        
002619  002859  //------------------------------------------------------------------//
002620  002860  //        Function Prototypes for I2C
002621  002861  //------------------------------------------------------------------//
002622  002862  func I2C1_Open("speed", "SCLpin", "SDApin"), 1;
002623  002863  // Syntax : I2C1_Openx(speed, SCLpin, SDApin),
002624  002864  // Usage  : I2C1_Open(I2C_MED, PA2, PA3);
002625  002865  // Notes  : configures the required I2C module
002626  002866  //        : see 'I2C timing related constants' and 'pin constants'
002627  002867  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002628  002868  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002629  002869  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002630  002870  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002631  002871  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002632  002872  // Returns: True if successful
002633  002873        
002634  002874        
002635  002875  func I2C2_Open("speed", "SCLpin", "SDApin"), 1;
002636  002876  // Syntax : I2C2_Openx(speed, SCLpin, SDApin),
002637  002877  // Usage  : I2C2_Open(I2C_MED, PA2, PA3);
002638  002878  // Notes  : configures the required I2C module
002639  002879  //        : see 'I2C timing related constants' and 'pin constants'
002640  002880  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002641  002881  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002642  002882  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002643  002883  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002644  002884  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002645  002885  // Returns: True if successful
002646  002886        
002647  002887        
002648  002888  func I2C3_Open("speed", "SCLpin", "SDApin"), 1;
002649  002889  // Syntax : I2C3_Openx(speed, SCLpin, SDApin),
002650  002890  // Usage  : I2C3_Open(I2C_MED, PA2, PA3);
002651  002891  // Notes  : configures the required I2C module
002652  002892  //        : see 'I2C timing related constants' and 'pin constants'
002653  002893  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002654  002894  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002655  002895  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002656  002896  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002657  002897  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002658  002898  // Returns: True if successful
002659  002899        
002660  002900        
002661  002901  func I2C1_Close(), 0;
002662  002902  // Usage : I2C1_Close();
002663  002903  // Notes : disables the I2C1 module.
002664  002904        
002665  002905  func I2C2_Close(), 0;
002666  002906  // Usage : I2C2_Close();
002667  002907  // Notes : disables the I2C2 module.
002668  002908        
002669  002909  func I2C3_Close(), 0;
002670  002910  // Usage : I2C3_Close();
002671  002911  // Notes : disables the I2C3 module.
002672  002912        
002673  002913  func I2C1_Start(), 1;
002674  002914  // Syntax: I2C1_Start();
002675  002915  // Usage : I2C1_Start();
002676  002916  // Notes : generates a Start condition.
002677  002917  //       : returns true if successful (usually ignored)
002678  002918        
002679  002919  func I2C2_Start(), 1;
002680  002920  // Syntax: I2C2_Start();
002681  002921  // Usage : I2C2_Start();
002682  002922  // Notes : generates a Start condition.
002683  002923  //       : returns true if successful (usually ignored)
002684  002924        
002685  002925  func I2C3_Start(), 1;
002686  002926  // Syntax: I2C3_Start();
002687  002927  // Usage : I2C3_Start();
002688  002928  // Notes : generates a Start condition.
002689  002929  //       : returns true if successful (usually ignored)
002690  002930        
002691  002931  func I2C1_Stop(), 1;
002692  002932  // Syntax: I2C1_Stop();
002693  002933  // Usage : I2C1_Stop();
002694  002934  // Notes : generates a Stop condition.
002695  002935  //       : returns true if successful (usually ignored)
002696  002936        
002697  002937  func I2C2_Stop(), 1;
002698  002938  // Syntax: I2C2_Stop();
002699  002939  // Usage : I2C2_Stop();
002700  002940  // Notes : generates a Stop condition.
002701  002941  //       : returns true if successful (usually ignored)
002702  002942        
002703  002943  func I2C3_Stop(), 1;
002704  002944  // Syntax: I2C3_Stop();
002705  002945  // Usage : I2C3_Stop();
002706  002946  // Notes : generates a Stop condition.
002707  002947  //       : returns true if successful (usually ignored)
002708  002948        
002709  002949  func I2C1_Restart(), 1;
002710  002950  // Syntax: I2C1_Restart();
002711  002951  // Usage : I2C1_Restart();
002712  002952  // Notes : generates a Restart condition.
002713  002953  //       : returns true if successful (usually ignored)
002714  002954        
002715  002955  func I2C2_Restart(), 1;
002716  002956  // Syntax: I2C2_Restart();
002717  002957  // Usage : I2C2_Restart();
002718  002958  // Notes : generates a Restart condition.
002719  002959  //       : returns true if successful (usually ignored)
002720  002960        
002721  002961  func I2C3_Restart(), 1;
002722  002962  // Syntax: I2C3_Restart();
002723  002963  // Usage : I2C3_Restart();
002724  002964  // Notes : generates a Restart condition.
002725  002965  //       : returns true if successful (usually ignored)
002726  002966        
002727  002967  func I2C1_Read(), 1;
002728  002968  // Syntax: I2C1_Read();
002729  002969  // Usage : ch := I2C1_Read();
002730  002970  // Notes : reads a single byte from the I2C Bus.
002731  002971        
002732  002972  func I2C2_Read(), 1;
002733  002973  // Syntax: I2C2_Read();
002734  002974  // Usage : ch := I2C2_Read();
002735  002975  // Notes : reads a single byte from the I2C Bus.
002736  002976        
002737  002977  func I2C3_Read(), 1;
002738  002978  // Syntax: I2C3_Read();
002739  002979  // Usage : ch := I2C3_Read();
002740  002980  // Notes : reads a single byte from the I2C Bus.
002741  002981        
002742  002982  func I2C1_Write("byte"), 1;
002743  002983  // Syntax: I2C1_Write(byte);
002744  002984  // Usage : r := I2C1_Write(ch);
002745  002985  // Notes : is used to write a byte to the I2C bus.
002746  002986  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002747  002987        
002748  002988  func I2C2_Write("byte"), 1;
002749  002989  // Syntax: I2C2_Write(byte);
002750  002990  // Usage : r := I2C2_Write(ch);
002751  002991  // Notes : is used to write a byte to the I2C bus.
002752  002992  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002753  002993        
002754  002994  func I2C3_Write("byte"), 1;
002755  002995  // Syntax: I2C3_Write(byte);
002756  002996  // Usage : r := I2C3_Write(ch);
002757  002997  // Notes : is used to write a byte to the I2C bus.
002758  002998  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002759  002999        
002760  003000  func I2C1_Ack(), 0;
002761  003001  // Syntax: I2C1_Ack();
002762  003002  // Usage : I2C1_Ack();
002763  003003  // Notes : generates the acknowledge condition.
002764  003004        
002765  003005  func I2C2_Ack(), 0;
002766  003006  // Syntax: I2C2_Ack();
002767  003007  // Usage : I2C2_Ack();
002768  003008  // Notes : generates the acknowledge condition.
002769  003009        
002770  003010  func I2C3_Ack(), 0;
002771  003011  // Syntax: I2C3_Ack();
002772  003012  // Usage : I2C3_Ack();
002773  003013  // Notes : generates the acknowledge condition.
002774  003014        
002775  003015  func I2C1_Nack(), 0;
002776  003016  // Syntax: I2C1_Nack();
002777  003017  // Usage : I2C1_Nack();
002778  003018  // Notes : generates the negative acknowledge condition.
002779  003019        
002780  003020  func I2C2_Nack(), 0;
002781  003021  // Syntax: I2C2_Nack();
002782  003022  // Usage : I2C2_Nack();
002783  003023  // Notes : generates the negative acknowledge condition.
002784  003024        
002785  003025  func I2C3_Nack(), 0;
002786  003026  // Syntax: I2C3_Nack();
002787  003027  // Usage : I2C3_Nack();
002788  003028  // Notes : generates the negative acknowledge condition.
002789  003029        
002790  003030  func I2C1_AckStatus(), 1;
002791  003031  // Syntax: I2C1_AckStatus();
002792  003032  // Usage : r := I2C1_AckStatus();
002793  003033  // Notes : returns the ACK status from the device.
002794  003034        
002795  003035  func I2C2_AckStatus(), 1;
002796  003036  // Syntax: I2C2_AckStatus();
002797  003037  // Usage : r := I2C2_AckStatus();
002798  003038  // Notes : returns the ACK status from the device.
002799  003039        
002800  003040  func I2C3_AckStatus(), 1;
002801  003041  // Syntax: I2C3_AckStatus();
002802  003042  // Usage : r := I2C3_AckStatus();
002803  003043  // Notes : returns the ACK status from the device.
002804  003044        
002805  003045  func I2C1_AckPoll("control"), 1;
002806  003046  // Syntax: I2C1_AckPoll();
002807  003047  // Usage : r := I2C1_AckPoll(0xA0);
002808  003048  // Notes : waits for a device to return from ACK polling.
002809  003049        
002810  003050  func I2C2_AckPoll("control"), 1;
002811  003051  // Syntax: I2C2_AckPoll();
002812  003052  // Usage : r := I2C2_AckPoll(0xA0);
002813  003053  // Notes : waits for a device to return from ACK polling.
002814  003054        
002815  003055  func I2C3_AckPoll("control"), 1;
002816  003056  // Syntax: I2C3_AckPoll();
002817  003057  // Usage : r := I2C3_AckPoll(0xA0);
002818  003058  // Notes : waits for a device to return from ACK polling.
002819  003059        
002820  003060  func I2C1_Idle(), 1;
002821  003061  // Syntax : I2C1_Idle();
002822  003062  // Usage  : r := I2C1_Idle();
002823  003063  // Notes  : waits until the I2C Bus is Inactive.
002824  003064  //        : Times out if bus not idle within 1 second
002825  003065  // Returns: TRUE if successful, else failed (timed out)
002826  003066        
002827  003067  func I2C2_Idle(), 1;
002828  003068  // Syntax : I2C2_Idle();
002829  003069  // Usage  : r := I2C2_Idle();
002830  003070  // Notes  : waits until the I2C Bus is Inactive.
002831  003071  //        : Times out if bus not idle within 1 second
002832  003072  // Returns: TRUE if successful, else failed (timed out)
002833  003073        
002834  003074  func I2C3_Idle(), 1;
002835  003075  // Syntax : I2C3_Idle();
002836  003076  // Usage  : r := I2C3_Idle();
002837  003077  // Notes  : waits until the I2C Bus is Inactive.
002838  003078  //        : Times out if bus not idle within 1 second
002839  003079  // Returns: TRUE if successful, else failed (timed out)
002840  003080        
002841  003081        
002842  003082  func I2C1_Gets("buffer", "size"), 1;
002843  003083  // Syntax: I2C1_Gets("buffer", "size");
002844  003084  // Usage : r := I2C1_Gets(mybuf, 16);
002845  003085  // Notes : only reads up to "size" characters into "buffer"
002846  003086  //       : Reads up to asciiz terminator including terminator
002847  003087        
002848  003088  func I2C2_Gets("buffer", "size"), 1;
002849  003089  // Syntax: I2C2_Gets("buffer", "size");
002850  003090  // Usage : r := I2C2_Gets(mybuf, 16);
002851  003091  // Notes : only reads up to "size" characters into "buffer"
002852  003092  //       : Reads up to asciiz terminator including terminator
002853  003093        
002854  003094  func I2C3_Gets("buffer", "size"), 1;
002855  003095  // Syntax: I2C3_Gets("buffer", "size");
002856  003096  // Usage : r := I2C3_Gets(mybuf, 16);
002857  003097  // Notes : only reads up to "size" characters into "buffer"
002858  003098  //       : Reads up to asciiz terminator including terminator
002859  003099        
002860  003100  func I2C1_Getn("buffer", "size"), 1;
002861  003101  // Syntax: I2C1_Gets("buffer", "size");
002862  003102  // Usage : r := I2C1_Gets(mybuf, 16);
002863  003103  // Notes : reads "size" bytes into "buffer"
002864  003104  //       :
002865  003105        
002866  003106  func I2C2_Getn("buffer", "size"), 1;
002867  003107  // Syntax: I2C2_Gets("buffer", "size");
002868  003108  // Usage : r := I2C2_Gets(mybuf, 16);
002869  003109  // Notes : reads "size" bytes into "buffer"
002870  003110  //       :
002871  003111        
002872  003112  func I2C3_Getn("buffer", "size"), 1;
002873  003113  // Syntax: I2C3_Gets("buffer", "size");
002874  003114  // Usage : r := I2C3_Gets(mybuf, 16);
002875  003115  // Notes : reads "size" bytes into "buffer"
002876  003116  //       :
002877  003117        
002878  003118  func I2C1_Puts("buffer"), 1;
002879  003119  // Syntax: I2C1_Puts("buffer");
002880  003120  // Usage : r := I2C1_Puts(mybuf);
002881  003121  // Notes : writes an asciiz string to the I2C device
002882  003122  //       : returns count of characters written
002883  003123        
002884  003124  func I2C2_Puts("buffer"), 1;
002885  003125  // Syntax: I2C2_Puts("buffer");
002886  003126  // Usage : r := I2C2_Puts(mybuf);
002887  003127  // Notes : writes an asciiz string to the I2C device
002888  003128  //       : returns count of characters written
002889  003129        
002890  003130  func I2C3_Puts("buffer"), 1;
002891  003131  // Syntax: I2C3_Puts("buffer");
002892  003132  // Usage : r := I2C3_Puts(mybuf);
002893  003133  // Notes : writes an asciiz string to the I2C device
002894  003134  //       : returns count of characters written
002895  003135        
002896  003136  func I2C1_Putn("buffer", "count"), 1;
002897  003137  // Syntax: I2C1_Putn("buffer","count");
002898  003138  // Usage : r := I2C1_Puts(mybuf,10);
002899  003139  // Notes : writes up to "size" bytes to the I2C device
002900  003140  //       : returns number of bytes written
002901  003141        
002902  003142  func I2C2_Putn("buffer", "count"), 1;
002903  003143  // Syntax: I2C2_Putn("buffer","count");
002904  003144  // Usage : r := I2C2_Puts(mybuf,10);
002905  003145  // Notes : writes up to "size" bytes to the I2C device
002906  003146  //       : returns number of bytes written
002907  003147        
002908  003148  func I2C3_Putn("buffer", "count"), 1;
002909  003149  // Syntax: I2C3_Putn("buffer","count");
002910  003150  // Usage : r := I2C3_Puts(mybuf,10);
002911  003151  // Notes : writes up to "size" bytes to the I2C device
002912  003152  //       : returns number of bytes written
002913  003153        
002914  003154        
002915  003155  func spi_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002916  003156  // Syntax   : spi_ReadBlock("buf", "bufsize");
002917  003157  // Usage    : spi_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002918  003158  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002919  003159        
002920  003160  func spi1_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002921  003161  // Syntax   : spi1_ReadBlock("buf", "bufsize");
002922  003162  // Usage    : spi1_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002923  003163  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002924  003164        
002925  003165  func spi2_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002926  003166  // Syntax   : spi2_ReadBlock("buf", "bufsize");
002927  003167  // Usage    : spi2_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002928  003168  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002929  003169        
002930  003170  func spi3_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002931  003171  // Syntax   : spi3_ReadBlock("buf", "bufsize");
002932  003172  // Usage    : spi3_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002933  003173  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002934  003174        
002935  003175  // I2C timing related constants
002936  003176  #CONST
002937  003184  #END
002938  003185        
002939  003186        
002940  003187        
002941  003188  //------------------------------------------------------------------//
002942  003189  // Direct uSD (SPI0) card SPI functions                             //
002943  003190  //------------------------------------------------------------------//
002944  003191  func spi_Init("speed","mode"), 0;  // set the SPI port, not used if uSD active
002945  003192  // Syntax   : spi_Init(SPI_FAST,0);
002946  003193  // Usage    : spi_Init(SPI_FAST,0);              // init SPI at maximum speed
002947  003194  // *Notes   : mode needs to be SPI_ADDRESS_MODE4 for flash devices with more than 16MB of capacity
002948  003195        
002949  003196  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
002950  003197  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
002951  003198  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
002952  003199                                                  //
002953  003200        
002954  003201  //------------------------------------------------------------------//
002955  003202  // Function prototypes for SPI1, SPI2 and SPI3                      //
002956  003203  //------------------------------------------------------------------//
002957  003204  func SPI1_SDO_pin("pin"), 1;                // select the hardware pin for SPI1 transmit line
002958  003205  // Syntax: SPI_SDO_pin(pin);
002959  003206  // Usage : SPI_SDO_pin(PA1); // set SPI SDO to PA1 pin
002960  003207  // Notes : Select the hardware pin for SPIx transmit line.
002961  003208  //       : Note that multiple pins can be connected simmultaneously.
002962  003209  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002963  003210  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002964  003211  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002965  003212  //       : The pin is automatically set to an output.
002966  003213  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002967  003214        
002968  003215  func SPI2_SDO_pin("pin"), 1;                // select the hardware pin for SPI2 transmit line
002969  003216  // Syntax: SPI2_SDO_pin(pin);
002970  003217  // Usage : SPI2_SDO_pin(PA1); // set SPI2 SDO to PA1 pin
002971  003218  // Notes : Select the hardware pin for SPIx transmit line.
002972  003219  //       : Note that multiple pins can be connected simmultaneously.
002973  003220  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002974  003221  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002975  003222  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002976  003223  //       : The pin is automatically set to an output.
002977  003224  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002978  003225        
002979  003226  func SPI3_SDO_pin("pin"), 1;                // select the hardware pin for SPI3 transmit line
002980  003227  // Syntax: SPI3_SDO_pin(pin);
002981  003228  // Usage : SPI3_SDO_pin(PA1); // set SPI3 SDO to PA1 pin
002982  003229  // Notes : Select the hardware pin for SPIx transmit line.
002983  003230  //       : Note that multiple pins can be connected simmultaneously.
002984  003231  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002985  003232  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002986  003233  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002987  003234  //       : The pin is automatically set to an output.
002988  003235  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002989  003236        
002990  003237  func SPI1_SDI_pin("pin"), 1;                // select the hardware pin for SPI1 receive line
002991  003238  // Syntax: SPI1_SDI_pin(pin);
002992  003239  // Usage : SPI1_SDI_pin(PA3); // set SPI1 SDI to PA3 pin
002993  003240  // Notes : Selects the hardware pin for SPIx receive line.
002994  003241  //       : Note that only a single pin can be mapped to SPI SDI.
002995  003242  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
002996  003243  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
002997  003244  //       : If the pin argument is 0 the function has no effect
002998  003245  //       : The pin is automatically set to an input.
002999  003246  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003000  003247  //       : it is necessary to configure the SDI pin first, eg
003001  003248  //       :     SPI1_SDI_pin(PA3);     // configure SPI1 SDI to PA3 (this disconnects anything else)
003002  003249  //       :     SPI1_SDO_pin(PA3));    // configure SPI1 SDO to PA3
003003  003250  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003004  003251        
003005  003252  func SPI2_SDI_pin("pin"), 1;                // select the hardware pin for SPI2 receive line
003006  003253  // Syntax: SPI2_SDI_pin(pin);
003007  003254  // Usage : SPI2_SDI_pin(PA3); // set SPI2 SDI to PA3 pin
003008  003255  // Notes : Selects the hardware pin for SPIx receive line.
003009  003256  //       : Note that only a single pin can be mapped to SPI SDI.
003010  003257  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003011  003258  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003012  003259  //       : If the pin argument is 0 the function has no effect
003013  003260  //       : The pin is automatically set to an input.
003014  003261  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003015  003262  //       : it is necessary to configure the SDI pin first, eg
003016  003263  //       :     SPI2_SDI_pin(PA3);     // configure SPI2 SDI to PA3 (this disconnects anything else)
003017  003264  //       :     SPI2_SDO_pin(PA3));    // configure SPI2 SDO to PA3
003018  003265  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003019  003266        
003020  003267  func SPI3_SDI_pin("pin"), 1;                // select the hardware pin for SPI2 receive line
003021  003268  // Syntax: SPI3_SDI_pin(pin);
003022  003269  // Usage : SPI3_SDI_pin(PA3); // set SPI3 SDI to PA3 pin
003023  003270  // Notes : Selects the hardware pin for SPIx receive line.
003024  003271  //       : Note that only a single pin can be mapped to SPI SDI.
003025  003272  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003026  003273  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003027  003274  //       : If the pin argument is 0 the function has no effect
003028  003275  //       : The pin is automatically set to an input.
003029  003276  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003030  003277  //       : it is necessary to configure the SDI pin first, eg
003031  003278  //       :     SPI3_SDI_pin(PA3);     // configure SPI3 SDI to PA3 (this disconnects anything else)
003032  003279  //       :     SPI3_SDO_pin(PA3));    // configure SPI3 SDO to PA3
003033  003280  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003034  003281        
003035  003282  func SPI1_SCK_pin("pin"), 1;                // select the hardware pin for SPI1 clock line
003036  003283  // Syntax: SPI1_SCK_pin(pin);
003037  003284  // Usage : SPI1_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003038  003285  // Notes : Selects the hardware pin for SPI clock line.
003039  003286  //       : Note that only a single pin should be mapped to spi SCK.
003040  003287  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003041  003288  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003042  003289  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003043  003290  //       : The pin is automatically set to an output.
003044  003291  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003045  003292        
003046  003293  func SPI2_SCK_pin("pin"), 1;                // select the hardware pin for SPI2 clock line
003047  003294  // Syntax: SPI2_SCK_pin(pin);
003048  003295  // Usage : SPI2_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003049  003296  // Notes : Selects the hardware pin for SPI clock line.
003050  003297  //       : Note that only a single pin should be mapped to spi SCK.
003051  003298  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003052  003299  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003053  003300  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003054  003301  //       : The pin is automatically set to an output.
003055  003302  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003056  003303        
003057  003304  func SPI3_SCK_pin("pin"), 1;                // select the hardware pin for SPI3 clock line
003058  003305  // Syntax: SPI3_SCK_pin(pin);
003059  003306  // Usage : SPI3_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003060  003307  // Notes : Selects the hardware pin for SPI clock line.
003061  003308  //       : Note that only a single pin should be mapped to spi SCK.
003062  003309  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003063  003310  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003064  003311  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003065  003312  //       : The pin is automatically set to an output.
003066  003313  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003067  003314        
003068  003315        
003069  003316  func SPI1_Init("speed","mode", "enablepin"), 1;              // set the SPI1 port
003070  003317  func SPI2_Init("speed","mode", "enablepin"), 1;              // set the SPI2 port
003071  003318  func SPI3_Init("speed","mode", "enablepin"), 1;              // set the SPI3 port
003072  003319        
003073  003320        
003074  003321  //------------------------------------------------------------------------------
003075  003322  // Constants for SPI1, SPI2 an SPI3 "mode"
003076  003323  //------------------------------------------------------------------------------
003077  003324  #CONST
003078  003342  #END
003079  003343        
003080  003344  //------------------------------------------------------------------------------
003081  003345  // Constants for SPI1, SPI2 an SPI3 "speed"
003082  003346  //------------------------------------------------------------------------------
003083  003347  #CONST
003084  003368  #END
003085  003369        
003086  003370        
003087  003371  func SPI1_Read(), 1;                                 // read a raw byte from SPI1
003088  003372  func SPI2_Read(), 1;                                 // read a raw byte from SPI2
003089  003373  func SPI3_Read(), 1;                                 // read a raw byte from SPI3
003090  003374        
003091  003375  func SPI1_Write("byte"), 1;                          // write a raw byte to SPI1
003092  003376  func SPI2_Write("byte"), 1;                          // write a raw byte to SPI2
003093  003377  func SPI3_Write("byte"), 1;                          // write a raw byte to SPI3
003094  003378        
003095  003379  func spi_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003096  003380  // Syntax   : spi_WriteBlock("buf", "bufsize");
003097  003381  // Usage    : spi_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003098  003382  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003099  003383        
003100  003384  func spi1_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003101  003385  // Syntax   : spi1_WriteBlock("buf", "bufsize");
003102  003386  // Usage    : spi1_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003103  003387  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003104  003388        
003105  003389  func spi2_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003106  003390  // Syntax   : spi2_WriteBlock("buf", "bufsize");
003107  003391  // Usage    : spi2_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003108  003392  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003109  003393        
003110  003394  func spi3_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003111  003395  // Syntax   : spi3_WriteBlock("buf", "bufsize");
003112  003396  // Usage    : spi3_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003113  003397  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003114  003398        
003115  003399  //------------------------------------------------------------------//
003116  003400  // Display Access                                                   //
003117  003401  //------------------------------------------------------------------//
003118  003402  func disp_SetReg("register", "data"), 0;
003119  003403  // Syntax: display_SetReg(register, data);
003120  003404  // Usage : display_SetReg(arg1, arg2);
003121  003405  // Notes : Sets uLCD specific display driver registers. Refer
003122  003406  //       : to appropriate display driver data sheet.
003123  003407        
003124  003408  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
003125  003409  // Syntax: disp_setGRAM(x1, y1, x2, y2);
003126  003410  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
003127  003411  // Notes : Prepares the GRAM area for user access.
003128  003412  //       : Data can now be written with disp_GRAM.
003129  003413  //       : GRAM will be set accordingly for the correct screen mode.
003130  003414  //       : the LO word of the 32 bit pixel count is returned. This is
003131  003415  //       : usually all that is needed unlse GRAM area exceeds 256^2
003132  003416  //       : A copy of the 32bit value can be found in
003133  003417  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
003134  003418        
003135  003419  func disp_WrGRAM("colour"), 0;
003136  003420  // Syntax: display_WrGRAM(colour);
003137  003421  // Usage : display_WrGRAM(arg);
003138  003422  // Notes : Data can be written to the GRAM consecutively using
003139  003423  //       : this function once the GRAM access window has been setup.
003140  003424        
003141  003425  func disp_WriteControl("value"), 0;             // write a control byte to the display
003142  003426        
003143  003427  func disp_WriteWord("value"), 0;                // write a word to the display
003144  003428        
003145  003429        
003146  003430  func disp_ReadWord(), 1;                        // read a word from the display
003147  003431  // Syntax: disp_ReadWord();
003148  003432  // Usage : x:=disp_ReadWord();
003149  003433  // Notes : Read a word from the controller
003150  003434  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
003151  003435  //       : print(disp_ReadWord());        // print ID
003152  003436  //       : (Many displays are write only)
003153  003437        
003154  003438        
003155  003439  // NB only available on certain displays, check individual data sheets
003156  003440  func sys_StoreTouchCalibration(), 1;
003157  003441  // Syntax: sys_StoreTouchCalibration();
003158  003442  // Usage : r := sys_StoreTouchCalibration();
003159  003443  // Notes : Store the touch calibration values in non-volatile memory.
003160  003444  //       : Returns true if the values have been accepted and stored,
003161  003445  //       : else returns false if write could not be performed, or
003162  003446  //       : touch calibration values are improbable.
003163  003447  //       : The values that are stored are obtained from:-
003164  003448  //       : TOUCH_XMINCAL             78  // touch calibration value
003165  003449  //       : TOUCH_YMINCAL             79  // touch calibration value
003166  003450  //       : TOUCH_XMAXCAL             80  // touch calibration value
003167  003451  //       : TOUCH_YMAXCAL             81  // touch calibration value
003168  003452  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
003169  003453  //       : This function is not supported on uVGA, Capacitive touch
003170  003454  //       : and 4.3" resistive touch modules.
003171  003455        
003172  003456  // NB only available on certain displays, check individual data sheets
003173  003457  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
003174  003458  // Syntax: disp_Sync(line);
003175  003459  // Usage : disp_Sync(480);
003176  003460  // Notes : Waits till the hardware gets to a certain line.
003177  003461  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
003178  003462  //       : Some experimentation may be needed to find an optimum line for disp_Sync
003179  003463  //       : depending on the graphics operation. The higher the value, the slower
003180  003464  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
003181  003465  //       : within the vertical retrace period) where it will just 'hang up' stopping the
003182  003466  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
003183  003467  //       : be slowest (as its actually right at the end of the blanking period) and 508
003184  003468  //       : will cause a hangup situation as it is above the highes scanline value.
003185  003469  //       : Currently, this function is only supported on displays with SSD1963 driver.
003186  003470        
003187  003471  func disp_Init(), 0;                           // initialize display with required tables. New in v0.7
003188  003472  // Syntax: disp_Init();                        New in v0.7
003189  003473  // Usage : disp_Init();
003190  003474  // Notes : Initialises or reinitialises the display.
003191  003475  //       : Normally used after restoration of peripheral power
003192  003476  //       : and after DeepSleep.
003193  003477        
003194  003478  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v0.7
003195  003479  // Syntax: disp_Disconnect();                  New in v0.7
003196  003480  // Usage : disp_Disconnect();
003197  003481  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
003198  003482  //       : its lowest possible power consumption. Use after disabling peripheral power
003199  003483  //       : to ensure the minimal power usage by the display.
003200  003484  //       : disp_Init() should be used to reinitialise the display.
003201  003485        
003202  003486  func disp_BlitPixelsFromCOM0(), 0;                     // Writes current GRAM window pixels to the display from the COM port
003203  003487  // Syntax: disp_BlitPixelsFromCOM0();                  New in v1.1
003204  003488  // Usage : disp_BlitPixelsFromCOM0();
003205  003489  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
003206  003490  //       : display from the specified com port.
003207  003491        
003208  003492  func __reserved42(), 0; // do not remove
003209  003493        
003210  003494        
003211  003495  //------------------------------------------------------------------//
003212  003496  //        Image Control Function Prototypes                         //
003213  003497  //------------------------------------------------------------------//
003214  003498  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
003215  003499  // Syntax: img_SetPosition(handle, index, xpos, ypos);
003216  003500  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
003217  003501  // Notes : set the position where the image will be displayed
003218  003502  //       : returns true if index was ok and function was successful.
003219  003503  //       : you may turn off an image so when img_Refresh is called,
003220  003504  //       : the image will not be shown
003221  003505        
003222  003506  func img_Enable("handle", "index"), 1;
003223  003507  // Syntax: img_Enable(handle, index);
003224  003508  // Usage : r := img_Enable(hImageList, imagenum);
003225  003509  // Notes : enable image in a image list
003226  003510  //       : returns true if index was ok and function was successful.
003227  003511  //       : this is the default state so when img_Refresh is called,
003228  003512  //       : all the images in the list will be shown
003229  003513  //       : if index is set to -1, all of the images are enabled
003230  003514        
003231  003515  func img_Disable("handle", "index"), 1;
003232  003516  // Syntax: img_Disable(handle, index);
003233  003517  // Usage : r := img_Disable(hImageList, imagenum);
003234  003518  // Notes : disable image in a image list
003235  003519  //       : returns true if index was ok and function was successful.
003236  003520  //       : you must turn off an image so when img_Refresh is called,
003237  003521  //       : the image will not be shown.
003238  003522  //       : if index is set to -1, all of the images are disabled
003239  003523        
003240  003524        
003241  003525  func img_Darken("handle", "index"), 1;
003242  003526  // Syntax: img_Darken(handle, index);
003243  003527  // Usage : r := img_Darken(hImageList, imagenum);
003244  003528  // Notes : darken image in a image list
003245  003529  //       : returns true if index was ok and function was successful.
003246  003530  //       : if index is set to -1, all of the images are darkened
003247  003531  //       : NB:- this feature will only work for the next refresh, then
003248  003532  //       : the image reverts back to normal when displayed again.
003249  003533        
003250  003534        
003251  003535  func img_Lighten("handle", "index"), 1;
003252  003536  // Syntax: img_Lighten(handle, index);
003253  003537  // Usage : r := img_Lighten(hImageList, imagenum);
003254  003538  // Notes : lighten image in a image list
003255  003539  //       : returns true if index was ok and function was successful.
003256  003540  //       : if index is set to -1, all of the images are lightened
003257  003541  //       : NB:- this feature will only work for the next refresh, then
003258  003542  //       : the image reverts back to normal when displayed again.
003259  003543        
003260  003544  func img_SetWord("handle", "index", "offset", "word"), 1;
003261  003545  // Syntax: img_SetWord(handle, index, offset, word);
003262  003546  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
003263  003547  // Notes : set specified word (0-7) in a image entry
003264  003548  //       : returns TRUE if successful, return value usually ignored.
003265  003549        
003266  003550  func img_GetWord("handle", "index", "offset"), 1;
003267  003551  // Syntax: myvar := img_GetWord("handle", "index", "offset");
003268  003552  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
003269  003553  // Notes : returns specified word (0-14) from an image entry
003270  003554  //       : refer to image control entry offsets.
003271  003555        
003272  003556  func img_Show("handle", "index"), 1;
003273  003557  // Syntax: img_Show(handle, index);
003274  003558  // Usage : display image entry (regardless of enable/disable)
003275  003559  //       : returns TRUE if successful, return value usually ignored.
003276  003560        
003277  003561  func img_SetAttributes("handle", "index","value"), 1;
003278  003562  // Syntax: img_SetAttributes("handle", "index","offset");
003279  003563  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
003280  003564  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
003281  003565  //       : of an image control entry. "value" refers to various bits in
003282  003566  //       : the image control entry (see image attribute flags).
003283  003567  //       : A '1' bit in the "value" field SETS the respective bit
003284  003568  //       : in the IMAGE_FLAGS field of the image control entry.
003285  003569  //       : returns TRUE if successful, return value usually ignored.
003286  003570        
003287  003571  func img_ClearAttributes("handle", "index","value"), 1;
003288  003572  // Syntax: img_ClearAttributes("handle", "index","offset");
003289  003573  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
003290  003574  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
003291  003575  //       : of an image control entry. "value" refers to various bits in
003292  003576  //       : the image control entry (see image attribute flags)
003293  003577  //       : a '1' bit in the "value" field CLEARS the respective bit
003294  003578  //       : in the IMAGE_FLAGS field of the image control entry.
003295  003579  //       : returns TRUE if successful, return value usually ignored.
003296  003580        
003297  003581  func img_Touched("handle", "index"), 1;
003298  003582  // Syntax: r := img_Touched(handle, index);
003299  003583  // Usage : img_Touched(hndl, 17);
003300  003584  //       : returns -1 if image not touched, or returns index
003301  003585  // Notes : if index is passed as -1, function tests all images,
003302  003586  //       : and returns -1 if image not touched, or returns index.
003303  003587        
003304  003588        
003305  003589  func img_SelectReadPosition("handle", "index", "frame", "x", "y"), 1;
003306  003590  // Syntax: img_SelectReadPosition(handle, index, frame, xpos, ypos);
003307  003591  // Usage : r := img_SelectReadPosition(hImageList, imagenum, frame, x, y);
003308  003592  // Notes : set a position in an image control for sequential reading
003309  003593  //       : of pixels from the uSD card (fat16 or raw modes supported)
003310  003594  //       : No image window area is set, the image will not be shown
003311  003595  //       : This function provides a means of preparing to load an image,
003312  003596  //       : or part of an image, to an array. (see img_SequentialRead)
003313  003597  //Returns: returns true if index was ok and function was successful.
003314  003598        
003315  003599        
003316  003600  func img_SequentialRead("count", "ptr"), 1;  // read pixels from selected read position of an image
003317  003601  // Syntax: img_SequentialRead(count, ptr);
003318  003602  // Usage1: r := img_SequentialRead(imgwidth, myArray);    // read 1 line from image control to array
003319  003603  // Usage2: r := img_SequentialRead(123, 0);            // skip 123 words from sequential stream
003320  003604  // Usage3: r := img_SequentialRead(20, 1);            // write 20 pixels to current GRAM position from stream
003321  003605  // Notes : once a position has ben set with the img_SelectReadPosition function,
003322  003606  //       : this function can then used for sequential reading of pixels from
003323  003607  //       : image storage.
003324  003608  //       : if "ptr" is 0, "count" pixels from the stream are simply skipped.
003325  003609  //       : if "ptr" is 1, "count" pixels are written to the GRAM area,
003326  003610  //       : else "ptr" must point to a valid array that is at least
003327  003611  //       : the size of "count".
003328  003612  //       : or part of an image, to an array. (see img_SequentialRead)
003329  003613  //       : returns TRUE if function succeded.
003330  003614        
003331  003615  func __reserved43(), 0; // do not remove
003332  003616  func __reserved44(), 0; // do not remove
003333  003617  func __reserved45(), 0; // do not remove
003334  003618  func __reserved46(), 0; // do not remove
003335  003619        
003336  003620  // image control header offsets
003337  003621  #CONST
003338  003628  #END
003339  003629        
003340  003630  // image control entry offsets
003341  003631  #CONST
003342  003646  #END
003343  003647        
003344  003648  // image attribute flags (in IMAGE_FLAGS)
003345  003649  // for img_SetAttributes(...) and img_ClearAttributes(...)
003346  003650  #CONST
003347  003664  #END
003348  003665        
003349  003666        
003350  003667  //------------------------------------------------------------------//
003351  003668  //        Timer Function Prototypes
003352  003669  //------------------------------------------------------------------//
003353  003670  func sys_T(), 1;
003354  003671  // Syntax: sys_T();
003355  003672  // Usage : t := sys_T();
003356  003673  // Notes : return the current value of the rolling system timer (1msec) LO word
003357  003674        
003358  003675  func sys_T_HI(), 1;
003359  003676  // Syntax: sys_T_HI();
003360  003677  // Usage : t := sys_T_HI();
003361  003678  // Notes : return the current value of the rolling system timer (1msec) HI word
003362  003679        
003363  003680  func sys_SetTimer("timernum","value"), 0;
003364  003681  // Syntax: sys_SetTimer("timernum", "value");
003365  003682  // Usage : sys_SetTimer(TIMER5, 10000);
003366  003683  // Notes : set a countdown on the selected timer, or 'top up' if required.
003367  003684  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
003368  003685  //       : Maximum timeout period is 65.535 seconds
003369  003686  //       : A timer can be read with the sys_GetTimer("timernum") function
003370  003687        
003371  003688  func sys_GetTimer("timernum"), 1;
003372  003689  // Syntax: t := sys_GetTimer("timernum");
003373  003690  // Usage : t := sys_GetTimer(TIMER3);
003374  003691  // Notes : returns 0 if timer has expired, or the current countdown value.
003375  003692  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
003376  003693  //       : Maximum timeout period is 65.535 seconds
003377  003694  //       : A timer must be set with the sys_SetTimer("timernum","value") function
003378  003695        
003379  003696  func sys_SetTimerEvent("timernum","function"), 1;
003380  003697  // Syntax: sys_SetTimerFunction("timernum", "function");
003381  003698  // Usage : sys_SetTimer(TIMER5, myfunc);
003382  003699  // Notes : set a function to be called for selected timer.
003383  003700  //       : When the timer reaches zero, the function is called.
003384  003701  //       : The called function must not have any parameters
003385  003702  //       : sys_SetTimerEvent returns any previous event function
003386  003703  //       : address, or zero if there was no previous function.
003387  003704        
003388  003705  func sys_EventQueue(), 1;
003389  003706  // Syntax: sys_EventQueue();
003390  003707  // Usage : tasks := sys_EventQueue();
003391  003708  // Notes : returns the max number of events that were pending
003392  003709  //       : in the timer queue since the last call to this function.
003393  003710  //       : This can be used to assess timer event overhead burden,
003394  003711  //       : especially after or during a sys_EventsPostpone action.
003395  003712        
003396  003713  func sys_EventsPostpone(), 0;
003397  003714  // Syntax: sys_EventPostpone();
003398  003715  // Usage : sys_EventPostpone();   // postpone the event queue
003399  003716  // Notes : postpone any events until the sys_EventResume function is executed
003400  003717  //       : The timer event queue will continue to queue events, but no action
003401  003718  //       : will take place untill a sys_EventResume function is encountered.
003402  003719  //       : The queue will continue to receive up to 32 events before discarding
003403  003720  //       : any further events. This function is required to allow a sequence of
003404  003721  //       : instructions or functions to occur that would otherwise be corrupted
003405  003722  //       : by an event occuring during the sequence of instructions or functions.
003406  003723  //       : A good example of this is when you set a position to print, if there
003407  003724  //       : was no way of locking the current sequence, an event may occur which
003408  003725  //       : does a similar thing, and a contention would occur - printing to
003409  003726  //       : the wrong position. This function should be used wisely, if any action
003410  003727  //       : that is required would take considerable time, it is better to disable
003411  003728  //       : any conflicting event functions with a bypass flag, then restart the
003412  003729  //       : conflicting event by re-issuing a timer value.
003413  003730        
003414  003731  func sys_EventsResume(), 0;
003415  003732  // Syntax: sys_EventsResume();
003416  003733  // Usage : sys_EventsResume();   // resume the event queue
003417  003734  // Notes : resume any postponed events. The queue will try to execute any timer
003418  003735  //       : events that were incurred during the postponed period.
003419  003736        
003420  003737        
003421  003738  func sys_GetTime(), 0;
003422  003739  // Syntax: sys_GetTime();
003423  003740  // Usage : to(mystring); sys_GetTime();   // save current time string to buffer
003424  003741  // Notes : print the system time in the format eg "6:10:45"
003425  003742  //       : Can be captured to a buffer using the to( function
003426  003743  //       : Returns nothing.
003427  003744        
003428  003745  func sys_SetTime("hours", "mins", "secs"), 1;
003429  003746  // Syntax: sys_SetTime(h, m, s);
003430  003747  // Usage : sys_SetTime(10, 0, 0);   // set the system time
003431  003748  // Notes : Used to set clock to correct time after power up or suspension
003432  003749  //Returns: Returns true if valid time.
003433  003750        
003434  003751  func sys_GetDate(), 0;
003435  003752  // Syntax: sys_GetDate();
003436  003753  // Usage : to(mystring); sys_GetDate();   // save current time string to buffer
003437  003754  // Notes : print the system date in the format eg "25-09-2012"
003438  003755  //       : Can be captured to a buffer using the to( function
003439  003756  //       : Returns nothing.
003440  003757        
003441  003758  func sys_SetDate("year", "month", "day"), 1;
003442  003759  // Syntax: sys_SetDate(y, m, d);
003443  003760  // Usage : sys_SetDate(10, 0, 0);   // set the system time
003444  003761  // Notes : Used to set clock to correct date after power up or suspension
003445  003762  //Returns: Returns true if valid date.
003446  003763        
003447  003764  func sys_Sleep("units"), 1;
003448  003765  // Syntax: t := sys_Sleep("units");
003449  003766  // Usage : t := sys_Sleep(10);
003450  003767  // Notes : sets the display into low power mode for a period of time.
003451  003768  //       : Touching the touch screen will also wake from sleep.
003452  003769  //       : as will bus Change Interrupts.
003453  003770  //       : Returns remaining sleep units.
003454  003771        
003455  003772  func iterator("offset"), 0;
003456  003773  // Syntax: t :=  iterator("offset");
003457  003774  // Usage : t :=  iterator(10);
003458  003775  // Notes : set the iterator size for ++/--
003459  003776  //       : The next postinc,postdec,preinc of predec will alter
003460  003777  //       : by the specified value.
003461  003778  //       : The offset will return to 1 after the next operation.
003462  003779        
003463  003780  func sys_DeepSleep("units"), 1;               // put the module into its lowest power consumption mode. New in v0.7
003464  003781  // Syntax: t := sys_DeepSleep("units");    New in v0.7
003465  003782  // Usage : t := sys_DeepSleep(10);
003466  003783  // Notes : sets the display and processor into lowest power mode for a period of time.
003467  003784  //       : When returning from DeepSleep the display should be reinitialised
003468  003785  //       : with disp_Init().
003469  003786  //       : Touching the touch screen will also wake from sleep.
003470  003787  //       : Returns remaining sleep units.
003471  003788        
003472  003789  //------------------------------------------------------------------//
003473  003790  //         Touch Screen Function Prototypes
003474  003791  //------------------------------------------------------------------//
003475  003792        
003476  003793  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
003477  003794  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
003478  003795  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
003479  003796  // Notes : Specifies a new touch detect region on the screen
003480  003797  //       : such that only touch activity in that region will
003481  003798  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
003482  003799        
003483  003800  func touch_Set("mode"), 0;
003484  003801  // Syntax: touch_Set(mode);
003485  003802  // Usage : touch_Set(arg);
003486  003803  // Notes : Sets various Touch Screen related parameters
003487  003804  //       :
003488  003805  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
003489  003806  //       : touch_Set(TOUCH_ENABLE);
003490  003807  //       : Enables and initialises Touch Screen hardware
003491  003808  //       :
003492  003809  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
003493  003810  //       : touch_Set(TOUCH_DISABLE );
003494  003811  //       : Disables the Touch Screen
003495  003812  //       : Note: Touch Screen runs in the background and disabling
003496  003813  //       : it when not in use will free up extra resources
003497  003814  //       : such as 4DVM CPU cycles.
003498  003815  //       :
003499  003816  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
003500  003817  //       : touch_Set(TOUCH_REGIONDEFAULT);
003501  003818  //       : This will reset the current active region to default
003502  003819  //       : to the full screen without the application having to
003503  003820  //       : set a new active region for the full screen.
003504  003821  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
003505  003822  //       : that requre to be interfaced with an external pointing
003506  003823  //       : device, values that are poked into TOUCH_DRIVE will be
003507  003824  //       : read with the touch_Get() function)
003508  003825        
003509  003826        
003510  003827  func touch_Get("mode"), 1;
003511  003828  // Syntax: touch_Get(mode);
003512  003829  // Usage : arg1 := touch_Get(arg);
003513  003830  // Notes : Returns various Touch Screen parameters to caller
003514  003831  //       :
003515  003832  //       : mode = TOUCH_STATUS  (mode 0)
003516  003833  //       : var := touch_Get(TOUCH_STATUS);
003517  003834  //       : Returns the various states of the touch screen
003518  003835  //       : 0 = NOTOUCH
003519  003836  //       : 1 = TOUCH_PRESSED
003520  003837  //       : 2 = TOUCH_RELEASED
003521  003838  //       : 3 = TOUCH_MOVING
003522  003839  //       :
003523  003840  //       : mode = TOUCH_GETX   (mode 1)
003524  003841  //       : var := touch_Get(TOUCH_GETX);
003525  003842  //       : Returns the X coordinates of the touch
003526  003843  //       :
003527  003844  //       : mode = TOUCH_GETY   (mode 2)
003528  003845  //       : var := touch_Get(TOUCH_GETY);
003529  003846  //       : Returns the Y coordinates of the touch
003530  003847        
003531  003848        
003532  003849  //touch_Set() related constants
003533  003850  #CONST
003534  003854  #END
003535  003855        
003536  003856  //touch_Get() related constants
003537  003857  #CONST
003538  003865  #END
003539  003866        
003540  003867  func touch_TestBox("&rect"), 1;
003541  003868  // Syntax   : touch_Test(rect);
003542  003869  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=20; r[3]:=30;
003543  003870  //          : result := touch_Test(r); // check area at 100,200,119,229
003544  003871  // Notes    : rect is an array of 4 vars, x1, y1, width, height (using boxed co-ordinates)
003545  003872  // returns  : Returns true if last touch co-ordinates are within the boxed test area.
003546  003873        
003547  003874  func touch_TestArea("&rect"), 1;
003548  003875  // Syntax   : touch_Test(rect);
003549  003876  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=119; r[3]:=129;
003550  003877  //          : result := touch_Test(r); // check area at 100,200,119,229
003551  003878  // Notes    : rect is an array of 4 vars, x1, y1, x2, y2 (using absolute co-ordinates)
003552  003879  // returns  : Returns true if last touch co-ordinates are within the absolute co-ordinate test area.
003553  003880        
003554  003881        
003555  003882  func __reserved51(), 0; // do not remove
003556  003883  func __reserved52(), 0; // do not remove
003557  003884        
003558  003885  //------------------------------------------------------------------//
003559  003886  //        Memory Allocation Function Prototypes
003560  003887  //------------------------------------------------------------------//
003561  003888        
003562  003889  func mem_Alloc("size"), 1;
003563  003890  // Syntax: mem_Alloc(bytesize);
003564  003891  // Usage : myvar := mem_Alloc(100);
003565  003892  // Notes : Allocate a block of memory to pointer myvar
003566  003893  //       : The allocated memory contains garbage but is a fast allocation.
003567  003894  //       : The block must later be released with mem_Free();
003568  003895  //       : returns 0 if function fails
003569  003896        
003570  003897  func mem_AllocV("size"), 1;
003571  003898  // Syntax: mem_AllocV(bytesize);
003572  003899  // Usage : myvar := mem_AllocV(100);
003573  003900  // Notes : Allocate a block of memory to pointer myvar
003574  003901  //       : The block of memory is filled with signature values
003575  003902  //       : the block starts with A5,5A then fills with incrementing
003576  003903  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
003577  003904  //       : This can be helpful when debugging
003578  003905  //       : The block must later be released with mem_Free();
003579  003906  //       : returns 0 if function fails
003580  003907        
003581  003908  func mem_AllocZ("size"), 1;
003582  003909  // Syntax: mem_AllocZ(bytesize);
003583  003910  // Usage : myvar := mem_AllocC(100);
003584  003911  // Notes : Allocate a zeroed block of memory to pointer myvar
003585  003912  //       : The block of memory is filled with zeroes
003586  003913  //       : The block must later be released with mem_Free();
003587  003914  //       : returns 0 if function fails
003588  003915        
003589  003916  func mem_Realloc("ptr", "size"), 1;
003590  003917  // Syntax: myvar := mem_Realloc("ptr", "size");
003591  003918  // Usage : myvar := mem_Realloc(ptr, size);
003592  003919  // Notes : The function may move the memory block to a new location,
003593  003920  //       : in which case the new location is returned.
003594  003921  //       : The content of the memory block is preserved up to the lesser
003595  003922  //       : of the new and old sizes, even if the block is moved.
003596  003923  //       : If the new size is larger, the value of the newly allocated
003597  003924  //       : portion is indeterminate. In case that ptr is NULL,
003598  003925  //       : the function behaves exactly as mem_Alloc, assigning a new block
003599  003926  //       : of size bytes and returning a pointer to the beginning of it.
003600  003927  //       : In case that the size is 0, the memory previously allocated in
003601  003928  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
003602  003929  //       : pointer is returned.
003603  003930        
003604  003931  func mem_Free("allocation"), 1;
003605  003932  // Syntax: myvar := mem_Free(allocation);
003606  003933  // Usage : myvar := mem_Free(myvar);
003607  003934  // Notes : De-allocate a block of memory previously created with
003608  003935  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
003609  003936  //       : returns 0 if function fails
003610  003937        
003611  003938  func mem_Heap(), 1;
003612  003939  // Syntax: myvar := mem_Heap();
003613  003940  // Usage : myvar := mem_Heap();
003614  003941  // Notes : returns bytecount available in heap
003615  003942  //       :
003616  003943        
003617  003944  func mem_Set("ptr","char","size"), 1;
003618  003945  // Syntax: mem_Set(ptr,char,bytesize);
003619  003946  // Usage : mem_Set(p, 'A', 100);
003620  003947  // Notes : fill a block of memory with a byte value
003621  003948  //       : Note that count is a byte count, this facilitates
003622  003949  //       : clearing word aligned byte arrays when using word
003623  003950  //       : aligned packed strings.
003624  003951  //       : returns ptr
003625  003952        
003626  003953  func mem_Copy("src", "dest", "bytecount"), 1;
003627  003954  // Syntax: myvar := mem_Copy(src, dest, bytesize);
003628  003955  // Usage : myvar := mem_Copy(p1, p2, 100);
003629  003956  // Notes : copy a word aligned block of memory from src to dest
003630  003957  //       : Note that count is a byte count, this facilitates
003631  003958  //       : copying word aligned byte arrays when using word
003632  003959  //       : aligned packed strings.
003633  003960  //       : returns src
003634  003961        
003635  003962  func mem_Compare("ptr1","ptr2","count"), 1;
003636  003963  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
003637  003964  // Usage : myvar := mem_Compare(p1, p2, 100);
003638  003965  // Notes : compare word aligned blocks of memory at src, dest
003639  003966  //       : Note that count is a byte count, this facilitates
003640  003967  //       : comparing word aligned byte arrays when using word
003641  003968  //       : aligned packed strings.
003642  003969  //       : returns 0 if we have a match
003643  003970        
003644  003971  func __reserved53(), 0; // do not remove
003645  003972  func __reserved54(), 0; // do not remove
003646  003973        
003647  003974  //------------------------------------------------------------------//
003648  003975  //        FAT16 Function Prototypes
003649  003976  //------------------------------------------------------------------//
003650  003977        
003651  003978  func file_Error(), 1;
003652  003979  // Syntax: myvar := file_Error();
003653  003980  // Usage : e := file_Error();
003654  003981  // Notes : return the most recent file error.
003655  003982  //       :
003656  003983        
003657  003984  func file_Count("filename"), 1;
003658  003985  // Syntax: count := file_Count("filename");
003659  003986  // Usage : count := file_Count("*.4dg");
003660  003987  // Notes : returns number of files found that match the criteria
003661  003988        
003662  003989  func file_Dir("filename"), 1;
003663  003990  // Syntax: count := file_Dir("filename");
003664  003991  // Usage : count := file_Dir("*.4dg");
003665  003992  // Notes : streams a string of filenames that agree with the search key
003666  003993  //       : returns number of files found that match the criteria
003667  003994        
003668  003995  func file_FindFirst("fname"), 1;
003669  003996  // Syntax: res := file_FindFirst("fname");
003670  003997  // Usage : if (file_FindFirst("*.4xe") ....
003671  003998  // Notes : returns true if at least 1 file exists
003672  003999  //       : that satisfies the file argument.
003673  004000  //       : Wildcards are usually used so if
003674  004001  //       : file_FindFirst returns true, further
003675  004002  //       : tests can be made using file_FindNext();
003676  004003  //       : to find all the files that match the
003677  004004  //       : wildcard class. Note that the stream behaviour
003678  004005  //       : is the same as file_Dir.
003679  004006  //       :
003680  004007        
003681  004008  func file_FindNext(), 1;
003682  004009  // Syntax: res := file_FindNext();
003683  004010  // Usage : while ((file_FindNext()) ....
003684  004011  // Notes : returns true if more file exists
003685  004012  //       : that satisfies the file argument
003686  004013  //       : that was given for  file_FindFirst.
003687  004014  //       : Wildcards must be used for
003688  004015  //       : file_FindFirst, else this function will
003689  004016  //       : always return zero as the only occurence
003690  004017  //       : will have already been found.
003691  004018  //       : Note that the stream behaviour
003692  004019  //       : is the same as file_Dir.
003693  004020  //       :
003694  004021        
003695  004022  func file_Exists("fname"), 1;
003696  004023  // Syntax: res := file_Exists("fname"),
003697  004024  // Usage : if(file_Exists("myfile") ....
003698  004025  // Notes : returns true if file exists
003699  004026  //       :
003700  004027        
003701  004028  func file_Open("fname", "mode"), 1;
003702  004029  // Syntax: handle := file_Open("fname","mode"),
003703  004030  // Usage : handle := file_Open("myfile.txt", 'r');
003704  004031  // Notes : returns handle if file exists
003705  004032  //       :
003706  004033        
003707  004034  func file_Close("handle"), 1;
003708  004035  // Syntax: res := file_Close("handle");
003709  004036  // Usage : res := file_Close(hnd1);
003710  004037  // Notes : returns true if file closed ok
003711  004038  //       :
003712  004039        
003713  004040  func file_Read("*dest", "size", "handle"), 1;
003714  004041  // Syntax: res := file_Read("*dest", "size", "handle"),
003715  004042  // Usage : res := file_Read(memblock,20,hnd1);
003716  004043  // Notes : returns number of characters read
003717  004044  //       : if "dest" is zero, data is read direct to GRAM window
003718  004045  //       :
003719  004046        
003720  004047        
003721  004048  func file_Seek("handle", "HiWord", "LoWord"), 1;
003722  004049  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
003723  004050  // Usage : res := file_Seek(hSource, 0, 0x1234);
003724  004051  // Notes : set file position to 0x00001234 (byte position 4660)
003725  004052  //       : for the file handle so subsequent data may be read
003726  004053  //       : from that position onwards with file_GetC(...),
003727  004054  //       : file_GetW(...) or file_GetS(...), or an image
003728  004055  //       : can be displayed with file_Image(...)
003729  004056  // Notes : returns true if ok, usually ignored
003730  004057        
003731  004058  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
003732  004059  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
003733  004060  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
003734  004061  // Notes : set file seek position to 123000
003735  004062  //       : for the file handle so subsequent data may be read
003736  004063  //       : from that record position onwards with file_GetC(...),
003737  004064  //       : file_GetW(...) or file_GetS(...), or an image
003738  004065  //       : can be displayed with file_Image(...)
003739  004066  // Notes : returns true if ok, usually ignored
003740  004067        
003741  004068  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
003742  004069  // Syntax: file_Tell("handle", &HiWord, &LoWord);
003743  004070  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
003744  004071  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003745  004072  //       : returns true if function succeeded
003746  004073        
003747  004074  func file_Write("*source", "size", "handle"), 1;
003748  004075  // Syntax: res := fwrite("*source", "size", "handle"),
003749  004076  // Usage : res := fwrite(memblock, 20, hnd1);
003750  004077  // Notes : returns number of bytes written
003751  004078  //       :
003752  004079        
003753  004080  func file_Size("handle", "&HiWord", "&LoWord"), 1;
003754  004081  // Syntax: file_Size("handle", &HiWord, &LoWord);
003755  004082  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
003756  004083  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003757  004084  //       : returns true if function succeeded
003758  004085        
003759  004086  func file_Image("x", "y", "handle"), 1;
003760  004087  // Syntax: file_Image(x, y, handle);
003761  004088  // Usage : file_Image(10, 10, hnd1);
003762  004089  // Notes : Display an image from a file at the current file position.
003763  004090  //       : The image is displayed at x,y (with respect to top left corner).
003764  004091  //       : If there is more than 1 image in the file, it can be
003765  004092  //       : accessed with file_Seek(...)
003766  004093        
003767  004094  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
003768  004095  // Syntax: file_ScreenCapture(x, y, w, h, handle);
003769  004096  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
003770  004097  // Notes : Save a image from screen to file at the current file position.
003771  004098  //       : The image can later be displayed with file_Image(...);
003772  004099  //       : The file may be opened in append mode to accumulate multiple
003773  004100  //       : images. Later, the images can be accessed with file_Seek(...);
003774  004101  //       : Note that the image will be sector aligned.
003775  004102  //       : All image headers must start on a sector boundary.
003776  004103  //       : The image is saved from x, y (with respect to top left corner)
003777  004104  //       : and the capture area is determined by "width" and "height".
003778  004105  //       : returns 0 if function succeeded
003779  004106        
003780  004107  func file_PutC("char","handle"), 1;
003781  004108  // Syntax: file_PutC("char", "handle");
003782  004109  // Usage : file_PutC('x', hndl);
003783  004110  // Notes : returns true if function succeeded
003784  004111        
003785  004112  func file_GetC("handle"), 1;
003786  004113  // Syntax: file_GetC("handle");
003787  004114  // Usage : mychar := fgetC("handle");
003788  004115  // Notes : returns next char from file
003789  004116        
003790  004117  func file_PutW("word","handle"), 1;
003791  004118  // Syntax: file_PutW("word","handle");
003792  004119  // Usage : file_PutW(0x1234, hndl);
003793  004120  // Notes : returns true if function succeeded
003794  004121        
003795  004122  func file_GetW("handle"), 1;
003796  004123  // Syntax: file_GetW("handle");
003797  004124  // Usage : myword := fgetW("handle");
003798  004125  // Notes : returns next word in file
003799  004126        
003800  004127  func file_PutS("*source", "handle"), 1;
003801  004128  // Syntax: res := file_Puts("*source", "handle"),
003802  004129  // Usage : res := file_Puts(mystring, hnd1);
003803  004130  // Notes : returns number of characters written
003804  004131  //       :
003805  004132        
003806  004133  func file_GetS("*string", "size", "handle"), 1;
003807  004134  // Syntax: res := file_Gets("*string", "size", "handle");
003808  004135  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
003809  004136  // Notes : get a string from a file
003810  004137  //       : returns pointer to string or null if failed.
003811  004138  //       : file_GetS(...) automatically appends a null-terminator to the data read.
003812  004139  //       : NB:- only reads up to "size-1" characters into "string"
003813  004140  //       : file_GetS(...) will stop reading when any of the following conditions are true:
003814  004141  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003815  004142  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003816  004143  //       : C] It reaches the end of file
003817  004144  //       : D] A read error occurs.
003818  004145        
003819  004146        
003820  004147  func file_Erase("fname"), 1;
003821  004148  // Syntax: res := file_Erase("fname");
003822  004149  // Usage : res := file_Erase("myfile.txt");
003823  004150  // Notes : returns true if successful
003824  004151  //       :
003825  004152        
003826  004153  func file_Rewind("handle"), 1;
003827  004154  // Syntax: res := file_Rewind("handle");
003828  004155  // Usage : res := file_Rewind(hnd1);
003829  004156  // Notes : returns true if file rewound ok (usually ignored)
003830  004157  //       : resets the file pointer the the beginning of the open file.
003831  004158        
003832  004159  func file_LoadFunction("fname.4xe"), 1;
003833  004160  // Syntax: res := file_LoadFunction("fname.4fn");
003834  004161  // Usage : myfunc := file_LoadFunction(myfuncname);
003835  004162  // Notes : Load a function or program from disk and
003836  004163  //       : return a function pointer to the allocation.
003837  004164  //       : The function can then be invoked just like any other
003838  004165  //       : function would be called via a function pointer.
003839  004166  //       : Parameters may be passed to it in a conventional way.
003840  004167  //       : The function may be discarded at any time when no
003841  004168  //       : longer required, thus freeing its memory resources.
003842  004169  //       : The loaded function can be discarded with mem_Free(..)
003843  004170  //       : eg:
003844  004171  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
003845  004172  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003846  004173  //       : then elsewhere in your program:-
003847  004174  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003848  004175  //       : if(res == QUIT_APPLICATION) goto exitApp;
003849  004176  //       : Later in your program, when popupWindow is no longer
003850  004177  //       : required for the application:-
003851  004178  //       : res := mem_Free(popupWindow);
003852  004179  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003853  004180  //       : The callers stack is shared by the loaded function,
003854  004181  //       : however any global variables in the loaded function
003855  004182  //       : are private to that function.
003856  004183  //
003857  004184        
003858  004185  func file_Run("fname.4xe", "arglistptr"), 1;
003859  004186  // Syntax: res := file_Run("fname.4xe","arglistptr");
003860  004187  // Usage : res := file_Run(fname, argptr);
003861  004188  // Notes : current program releases any allocated memory but
003862  004189  //       : retains the stack and global memory.
003863  004190  //       : If arglistptr is 0, no arguments are passed, else
003864  004191  //       : arglist points to an array, the first element being
003865  004192  //       : the number of elements in the array.
003866  004193  //       : func 'main' in the called program accepts
003867  004194  //       : the arguments, if any. The arguments can only
003868  004195  //       : be passed by value, no pointers or references can be
003869  004196  //       : used as all memory is cleared before the file
003870  004197  //       : is loaded. Refer to file_Exec and file_LoadFunction
003871  004198  //       : for functions that can pass by reference.
003872  004199        
003873  004200  func file_Exec("fname.4xe", "arglistptr"), 1;
003874  004201  // Syntax: res := file_Exec("fname.4xe","arglistptr");
003875  004202  // Usage : res := file_Exec("fname.4xe","arglistptr");
003876  004203  // Notes : returns like a function, current program
003877  004204  //       : calling program is kept active and control returns to it.
003878  004205  //       : If arglistptr is 0, no arguments are passed, else
003879  004206  //       : arglist points to an array, the first element being
003880  004207  //       : the number of elements in the array.
003881  004208  //       : func 'main' in the called program accepts the arguments.
003882  004209  //       : This function is similar to file_LoadFunction(...), however,
003883  004210  //       : the function argument list is passed by pointer, and
003884  004211  //       : the memory consumed by the function is released as
003885  004212  //       : soon as the function completes.
003886  004213        
003887  004214  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
003888  004215  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
003889  004216  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
003890  004217  // Notes : Reads a control file to create an image list.
003891  004218  //       : Returns NULL if function fails.
003892  004219  //       : Returns a handle (pointer to the memory allocation) to the
003893  004220  //       : image control list that has been created.
003894  004221  //       : "fname1" is the control list filename "*.dat"
003895  004222  //       : "fname2" is the image filename "*.gci"
003896  004223        
003897  004224  // Notes : This function Calculates the size of a chunk of memory required for
003898  004225  //       : a image list and populates it from the image control file ("*.dat")
003899  004226  //       : therefore, when imagelist is no longer required, you must de-allocate
003900  004227  //       : the image list memory by using eg:- mem_Free(hImagelist);
003901  004228  //       : to restore the heap.
003902  004229  //       :
003903  004230  //       : mode 0:- it is assumed that there is a graphics file with the
003904  004231  //       : file extension "fname2.gci". In this case, the images have been stored
003905  004232  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
003906  004233  //       : "fname1.dat" file are saved in the image control so that the image control
003907  004234  //       : can open the file (*.gci) and us file_Seek to get to the position of the
003908  004235  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
003909  004236  //       : mode 0 builds the image control quickly as it only scans the *.dat file
003910  004237  //       : for the file offsets and save them in the relevant entries in the image control.
003911  004238  //       : The penalty is that images take longer to find when displayed due to file_Seek
003912  004239  //       : overheads.
003913  004240  //
003914  004241  //       : mode 1:- it is assumed that there is a graphics file with the
003915  004242  //       : file extension "fname2.gci". In this case, the images have been stored
003916  004243  //       : in a FAT16 file concurrently, and the offset of the images are saved
003917  004244  //       : in the image control so that image file (*.gci) can be mapped to directly.
003918  004245  //       : The absolute cluster/sector is mapped so file seek does not need to be called
003919  004246  //       : internally. This means that there is no seek time penalty, however, the
003920  004247  //       : image list takes a lot longer to build, as all the seeking is done at control
003921  004248  //       : build time.
003922  004249        
003923  004250  //       : mode 2:- the graphics file with the is placed in a partitioned area
003924  004251  //       : In this case, the images have been stored in a in a known raw area of the FAT16
003925  004252  //       : disk, and the absolute address of the images are saved in the DAT file
003926  004253  //       : This is the fastest operation of the image control as there is no seeking
003927  004254  //       : or other disk activity taking place.
003928  004255        
003929  004256  func file_Mount(), 1;
003930  004257  // Syntax: r := file_Mount();
003931  004258  // Usage : r := file_Mount();
003932  004259  // Notes : Create a control block for FAT16 and mount the File System
003933  004260        
003934  004261  func file_Unmount(), 0;
003935  004262  // Syntax: file_Unmount();
003936  004263  // Usage : file_Unmount();
003937  004264  // Notes : release any control block and buffers for FAT16
003938  004265  //       : and unmount the File System
003939  004266        
003940  004267  func file_PlayWAV("fname1"), 1;
003941  004268  // Syntax: file_PlayWAV("fname1");
003942  004269  // Usage : file_PlayWAV("ding.wav");
003943  004270  // Notes : Play a wave file with filename "fname1"
003944  004271  //       : This function automatically grabs a chunk
003945  004272  //       : of memory for a file buffer, and a wave
003946  004273  //       : buffer. The minimum memory requirement is
003947  004274  //       : about 580 bytes for the disk io service and
003948  004275  //       : a minimum wave buffer size of 1024. The siz
003949  004276  //       : of the wave buffer allocation
003950  004277  //       : can be increased by the snd_BufSize function.
003951  004278  //       : The default size 1024 bytes.
003952  004279  //       : NB the memory is only required during the
003953  004280  //       : duration of play, and is automatically
003954  004281  //       : released while not in use.
003955  004282  //       : See the Sound Class services for other associated controls.
003956  004283  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003957  004284  //       : If errors occured, the folling is returned
003958  004285  //       : -7  : Insufficient memory available for WAV buffer and file
003959  004286  //       : -6  : cant play this rate
003960  004287  //       : -5  : no data chunk found in first rsector
003961  004288  //       : -4  : no format data
003962  004289  //       : -3  : no wave chunk signature
003963  004290  //       : -2  : bad wave file format
003964  004291  //       : -1  : file not found
003965  004292        
003966  004293  func file_Rename("fname1", "fname2"), 1;     // rename a file
003967  004294  // Syntax: file_Rename ("oldname", "newname"),
003968  004295  // Usage : file_Rename ("file.txt", "file.bak");
003969  004296  // Notes : Renames a file on uSD.
003970  004297  //       : Returns FALSE if function fails. (file does not exist, or new filename already exists)
003971  004298  //       : Returns TRUE, if successful.
003972  004299        
003973  004300  func file_SetDate("handle", "year", "month", "day", "hour", "Minute", "Second") , 1; // Sets date and time for an open file
003974  004301  // Syntax: res := file_SetDate("handle", "year", "month", "day", "hour", "Minute", "Second) ;
003975  004302  // Usage : res := file_SetDate(hndl, 2014, 10, 31, 10, 0, 0)
003976  004303  // Notes : year is a 4 digit year
003977  004304  //       : Due to limitations of FAT16 only even seconds are stored
003978  004305  //       : The handle must be closed before the file information is updated
003979  004306  //       : returns TRUE if date + time + handle valid
003980  004307  //       : returns FLAST if handle invalid, or date or time not valid (only simple checking performed).
003981  004308        
003982  004309  func __reserved57(), 0; // do not remove
003983  004310  func __reserved58(), 0; // do not remove
003984  004311        
003985  004312  //------------------------------------------------------------------------------
003986  004313  // FILEIO Error Code Constants
003987  004314  //------------------------------------------------------------------------------
003988  004315  #CONST
003989  004341  #END
003990  004342        
003991  004343  //------------------------------------------------------------------------------
003992  004344  // DISK struct offsets
003993  004345  //------------------------------------------------------------------------------
003994  004346  #CONST
003995  004363  #END
003996  004364        
003997  004365  //------------------------------------------------------------------------------
003998  004366  // FILE struct offsets
003999  004367  //------------------------------------------------------------------------------
004000  004368  #CONST
004001  004387  #END
004002  004388        
004003  004389        
004004  004390  //------------------------------------------------------------------//
004005  004391  //        Sound Class Services
004006  004392  //------------------------------------------------------------------//
004007  004393        
004008  004394  func snd_Volume("var"), 0;
004009  004395  // Syntax: snd_Volume("var");
004010  004396  // Usage : snd_Volume(30);
004011  004397  // Notes : set sound playback volume.  Var must
004012  004398  //       : be in the range from 8 (min volume)
004013  004399  //       : to 127 (max volume). If var is less
004014  004400  //       : than 8 volume is set to 8, and if
004015  004401  //       : var > 127 it is set to 127.
004016  004402        
004017  004403  func snd_Pitch("pitch"), 1;
004018  004404  // func snd_Pitch("freq"), 1;
004019  004405  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
004020  004406  // Notes : sets the samples playback rate to a different frequency
004021  004407  //       : The minimum value is 4khz
004022  004408  //       : Setting the pitch to zero restores the original sample rate
004023  004409  //       : Return value is the samples original sample rate.
004024  004410        
004025  004411  func snd_BufSize("var"), 0;
004026  004412  // Syntax: snd_BufSize("var");
004027  004413  // Usage : snd_BufSize(2);
004028  004414  // Notes : specify the a memory chunk size for the wavefile buffer.
004029  004415  //       : default size 1024 bytes.
004030  004416  //       : 0 = 1024 bytes (default)
004031  004417  //       : 1 = 2048 bytes
004032  004418  //       : 2 = 4096 bytes
004033  004419  //       : 3 = 8192 bytes
004034  004420        
004035  004421  func snd_Stop(), 0;
004036  004422  // Syntax: snd_Stop();
004037  004423  // Usage : snd_Stop();
004038  004424  // Notes : stop any sound that is playing, releasing
004039  004425  //       : buffers and closes any open wav file.
004040  004426        
004041  004427  func snd_Pause(), 0;
004042  004428  // Syntax: snd_Pause();
004043  004429  // Usage : snd_Pause();
004044  004430  // Notes : pauses any sound that is playing, does nothing
004045  004431  //       : until sound is resumed with snd_Continue().
004046  004432  //       : The sample cam be terminated with snd_Stop.
004047  004433  //       : buffers and closes any open wav file.
004048  004434        
004049  004435  func snd_Continue(), 0;
004050  004436  // Syntax: snd_Continue();
004051  004437  // Usage : snd_Continue();
004052  004438  // Notes : resume any sound that is paused by snd_Pause.
004053  004439        
004054  004440  func snd_Playing(), 1;
004055  004441  // Syntax: snd_Playing();
004056  004442  // Usage : r := snd_Playing();
004057  004443  // Notes : returns 0 if sound has finished playing,
004058  004444  //       : else return number of 512 byte blocks to go.
004059  004445        
004060  004446  func snd_Freq("Freq", "Duration"), 1;
004061  004447  // Syntax: snd_Freq("Freq", "Duration");
004062  004448  // Usage : r := snd_Freq(1000, 2000);
004063  004449  // Notes : Returns 0 if note cannot be played because a wav file is playing
004064  004450  //       : else return True.
004065  004451  //       : Minimum Freq is 20
004066  004452  //       : This will produce a pure Square wave and is designed for driving
004067  004453  //       : Piezo transducers which require this sort of drive. It can also be
004068  004454  //       : used to drive the amp on displays with audio.
004069  004455        
004070  004456        
004071  004457  func __reserved60(), 0; // do not remove
004072  004458  func __reserved61(), 0; // do not remove
004073  004459  func __reserved62(), 0; // do not remove
004074  004460        
004075  004461  //=========================================================================================================
004076  004462  // String functions
004077  004463  //=========================================================================================================
004078  004464        
004079  004465  func str_Ptr("&var"), 1;
004080  004466  // Syntax: str_Ptr(&var);
004081  004467  // Usage : p := str_Ptr(&var);
004082  004468  // Notes : return a byte pointer to a word region
004083  004469        
004084  004470  func str_GetD("&ptr", "&var"), 1;
004085  004471  // Syntax: str_GetD(&ptr, &var);
004086  004472  // Usage : ok := str_GetD(&ptr, &var);
004087  004473  // Notes : convert number in a string to DWORD ( myvar[2] )
004088  004474  //       : returns true if function succeeds, advancing ptr
004089  004475        
004090  004476  func str_GetW("&ptr", "&var"), 1;
004091  004477  // Syntax: str_GetW(&ptr, &var);
004092  004478  // Usage : ok := str_GetW(&ptr, &var);
004093  004479  // Notes : convert number in a string to WORD ( myvar )
004094  004480  //       : returns true if function succeeds, advancing ptr
004095  004481        
004096  004482  func str_GetHexW("&ptr", "&var"), 1;
004097  004483  // Syntax: str_GetHexW(&ptr, &var);
004098  004484  // Usage : ok := str_GetHexW(&ptr, &var);
004099  004485  // Notes : convert HEX number in a string to WORD ( myvar )
004100  004486  //       : returns true if function succeeds, advancing ptr
004101  004487        
004102  004488  func str_GetC("&ptr", "&var"), 1;
004103  004489  // Syntax: str_GetC(&ptr, &var);
004104  004490  // Usage : ok := str_GetC(&ptr, &var);
004105  004491  // Notes : get a valid ascii char in a string to WORD ( myvar )
004106  004492  //       : returns true if function succeeds, advancing ptr
004107  004493        
004108  004494  func str_GetByte("ptr"), 1;
004109  004495  // Syntax: str_GetByte(ptr);
004110  004496  // Usage : myvar := str_GetByte(ptr);
004111  004497  // Notes : get a byte to myvar
004112  004498  //       : returns value
004113  004499        
004114  004500  func str_GetWord("ptr"), 1;
004115  004501  // Syntax: GetWord(ptr);
004116  004502  // Usage : GetWord(ptr);
004117  004503  // Notes : get a word to myvar
004118  004504  //       : returns value
004119  004505        
004120  004506  func str_PutByte("ptr","val"), 0;
004121  004507  // Syntax: str_PutByte(ptr);
004122  004508  // Usage : myvar := str_PutByte(ptr);
004123  004509  // Notes : put a byte at ptr
004124  004510  //       : returns value
004125  004511        
004126  004512  func str_PutWord("ptr","val"), 0;
004127  004513  // Syntax: str_PutWord("ptr","val");
004128  004514  // Usage : str_PutWord(p,100);
004129  004515  // Notes : put word 100 at current pointer location
004130  004516  //       : returns value
004131  004517        
004132  004518  func str_Match("&ptr", "*str"), 1;
004133  004519  // Syntax: str_Match(&ptr, *str);
004134  004520  // Usage : r := str_Match(&p, "hello");
004135  004521  // Notes : Case sensitive match
004136  004522  //       : returns true if function succeded, andvancing pointer to position past
004137  004523  //       : the matched item. Note that any whitespace characters are skipped
004138  004524  //       : in the source string prior to the test.
004139  004525        
004140  004526  func str_MatchI("&ptr", "*str"), 1;
004141  004527  // Syntax: str_MatchI(&ptr, *str);
004142  004528  // Usage : r := str_MatchI(&p, "hello");
004143  004529  // Notes : Case insensitive match
004144  004530  //       : returns true if function succeded, andvancing pointer to position past
004145  004531  //       : the matched item. Note that any whitespace characters are skipped
004146  004532  //       : in the source string prior to the test.
004147  004533        
004148  004534  func str_Find("&ptr", "*str"), 1;
004149  004535  // Syntax: str_Find(&ptr, *str);
004150  004536  // Usage : n := str_Find(&p, "hello");
004151  004537  // Notes : given the address of a pointer to a source string as the
004152  004538  //       : first argument, and a pointer to a test string as the second
004153  004539  //       : argument, attempt to find the position of the matching string
004154  004540  //       : in the source string. The test is performed with case sensitivity.
004155  004541  //       : return 0 if not found, else returns the address of the first
004156  004542  //       : character of the match. NB:- The source pointer is not altered.
004157  004543        
004158  004544  func str_FindI("&ptr", "*str"), 1;
004159  004545  // Syntax: str_Find(&ptr, *str);
004160  004546  // Usage : n := str_Find(&p, "hello");
004161  004547  // Notes : given the address of a pointer to a source string as the
004162  004548  //       : first argument, and a pointer to a test string as the second
004163  004549  //       : argument, attempt to find the position of the matching string
004164  004550  //       : in the source string. The test is performed with no case
004165  004551  //       : sensitivity, eg upper and lower case chars are accepted.
004166  004552  //       : return 0 if not found, else returns the address of the first
004167  004553  //       : character of the match. NB:- The source pointer is not altered.
004168  004554        
004169  004555  func str_Length("ptr"), 1;
004170  004556  // Syntax: str_Length(ptr);
004171  004557  // Usage : len := str_Ptr(mystring);
004172  004558  // Notes : return the length of a byte aligned string excluding terminator
004173  004559        
004174  004560  func str_Printf("&ptr", "*format"), 1;
004175  004561  // Syntax: str_Printf("&ptr", "*format");
004176  004562  // Usage : r := str_Printf(&p, "hello");
004177  004563  // Notes : refer to documentation
004178  004564  //       :
004179  004565        
004180  004566  func str_Cat("dest","src"), 1;
004181  004567  // Syntax: str_Append("&dest","&src");
004182  004568  // Usage : str_Append(&buf,"Hello");
004183  004569  // Notes : Appends a copy of the source string to the destination string.
004184  004570  //       : The terminating null character in destination is overwritten by
004185  004571  //       : the first character of source, and a new null-character is appended
004186  004572  //       : at the end of the new string formed by the concatenation of both in destination.
004187  004573  //       : returns destination.
004188  004574        
004189  004575  func str_CatN("dest","src","count"), 1;
004190  004576  // Syntax: str_Append("&dest","&src","count");
004191  004577  // Usage : str_Append(&buf,"Monday",3);
004192  004578  // Notes : Appends a copy of the source string to the destination string.
004193  004579  //       : The number of characters copied is limited by "count".
004194  004580  //       : The terminating null character in destination is overwritten by
004195  004581  //       : the first character of source, and a new null-character is appended
004196  004582  //       : at the end of the new string formed by the concatenation of both in destination.
004197  004583  //       : returns destination.
004198  004584        
004199  004585        
004200  004586  func str_ByteMove("src", "dest", "count"), 1;
004201  004587  // Syntax   : str_ByteMove(src, dest, bytecount);
004202  004588  // Input    : STR *source points to byte aligned source.
004203  004589  //          : STR *dest   points to byte aligned destination.
004204  004590  //          : VAR count   number of bytes to transfer.
004205  004591  // Usage    : nextpos := str_ByteMove(s, d, 100);
004206  004592  // Notes    : copy bytes from "src" to "dest", stopping only
004207  004593  //          : when "count" is exhausted.
004208  004594  //          : No terminator is appended, it is purely a
004209  004595  //          : byte copy, and any zeroes encountered will
004210  004596  //          : also be copied.
004211  004597  // Returns  : returns a pointer to the end of the destination
004212  004598  //          : (which is "dest" + "count")
004213  004599        
004214  004600        
004215  004601  func str_Copy("dest", "src"), 1;
004216  004602  // Syntax   : str_Copy(dest, src);
004217  004603  // Input    : STR *dest   points to byte aligned destination.
004218  004604  //          : STR *source points to byte aligned source.
004219  004605  // Usage    : nextplace := str_Copy(d, s);
004220  004606  // Notes    : copy a string from "src" to "dest", stopping only
004221  004607  //          : when the end of source string "src" is encountered
004222  004608  //          : (0x00 terminator).
004223  004609  //          : The terminator is always appended, even if "src" is
004224  004610  //          : an empty string.
004225  004611  // Returns  : returns a pointer to the 0x00 string terminator at
004226  004612  //          : end of "dest" (which is "dest" + str_Length(src); )
004227  004613        
004228  004614        
004229  004615  func str_CopyN("dest", "src", "count"), 1;
004230  004616  // Syntax   : str_CopyN(dest, src, bytecount);
004231  004617  // Input    : STR *dest   points to byte aligned destination.
004232  004618  //          : STR *source points to byte aligned source.
004233  004619  //          : VAR count   max number of chars to copy.
004234  004620  // Usage    : nextplace := str_CopyN(d, s, 100);
004235  004621  // Notes    : copy a string from "src" to "dest", stopping only
004236  004622  //          : when "count" is exhausted, or end of source
004237  004623  //          : string "str" is encountered (0x00 string terminator).
004238  004624  //          : The terminator is always appended, even if
004239  004625  //          : "count" is zero, or "src" is a null string.
004240  004626  // Returns  : returns a pointer to the 0x00 string terminator
004241  004627  //          : (which is "dest" + whatever was copied)
004242  004628        
004243  004629        
004244  004630  func __reserved63(), 0; // do not remove
004245  004631  func __reserved64(), 0; // do not remove
004246  004632  func __reserved65(), 0; // do not remove
004247  004633  func __reserved66(), 0; // do not remove
004248  004634        
004249  004635  //=========================================================================================================
004250  004636  // FLASH memory functions
004251  004637  //=========================================================================================================
004252  004638  func flash_GetByte("bank", "ptr"), 1;
004253  004639  // Syntax   : flash_GetByte(bank, ptr);
004254  004640  // Usage    : myvar := flash_GetByte(FLASHBANK_2, 0x0017); // read first byte in data statement of bank 2
004255  004641  // Notes    : Reads a single byte from any flash location.
004256  004642  //          : If the bank is read protected, only the first 2 bytes can be read (0x55, 0xAA)
004257  004643  //          : which is the header signature for a valid program.
004258  004644  // Returns  : the byte value from the location
004259  004645        
004260  004646        
004261  004647  func flash_GetWord("bank", "ptr"), 1;
004262  004648  // Syntax   : flash_GetWord(bank, ptr);
004263  004649  // Usage    : myvar := flash_GetWord(FLASHBANK_2, 0x0000); // read first word in flash bank  (0xAA55)
004264  004650  // Notes    : Reads a single word from any flash location.
004265  004651  //          : The pointer is byte aligned.
004266  004652  //          : If the bank is read protected, only the first word can be read
004267  004653  //          : which is the header signature for a valid program (0xAA55).
004268  004654  // Returns  : the byte value from the location
004269  004655        
004270  004656        
004271  004657  func flash_Copy("bank", "ptr", "dest", "count"), 1;
004272  004658  // Syntax   : flash_Copy(bank, ptr);
004273  004659  // Usage    : myvar := flash_Copy(FLASHBANK_2, 0x1234, mybuf, 20); // read 20 bytes from FLASHBANK_2 starting from 0x1234
004274  004660  // Notes    : Copies bytes from any flash locations to a user buffer.
004275  004661  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
004276  004662  //          : If the bank is read protected, 0 bytes will be read
004277  004663  //          : which is the header signature for a valid program (0xAA55).
004278  004664  // Returns  : the count of bytes transferred.
004279  004665        
004280  004666        
004281  004667  func flash_Run("bank"), 1;
004282  004668  // Syntax    : flash_Run(bankx);
004283  004669  // Usage     : res := flash_Run(FLASHBANK_5);
004284  004670  // Notes     : Restarts the processor, running code from the required
004285  004671  //           : flash bank. bank may be a variable, or one of the
004286  004672  //           : pre-defined constants:-
004287  004673  //           :    FLASHBANK_0                 //0x00
004288  004674  //           :    FLASHBANK_1                 //0x01
004289  004675  //           :    FLASHBANK_2                 //0x02
004290  004676  //           :    FLASHBANK_3                 //0x03
004291  004677  //           :    FLASHBANK_4                 //0x04
004292  004678  //           :    FLASHBANK_5                 //0x05
004293  004679  // returns    : This function should net return as it restarts
004294  004680  //        : the processor and jumps to the required bank,
004295  004681  //        : If it does return, -1 indicates incorrect/invalid
004296  004682  //        : bank number, and -2 indicates no valid program
004297  004683  //        : in the selected bank.
004298  004684        
004299  004685  func flash_Bank(), 1;
004300  004686  // Syntax   : flash_Bank();
004301  004687  // Usage    : myvar := flash_Bank();
004302  004688  // Notes    : Identifies which flash bank the code is running from.
004303  004689  // Returns  : The FLASH bank that code is currently running from, 0-5.
004304  004690        
004305  004691        
004306  004692  func flash_EraseBank("bank", "confirmation"), 1;
004307  004693  // Syntax   : flash_EraseBank(bank, confirmation);
004308  004694  // Usage    : result := flash_EraseBank(FLASHBANK_3, 0xDEAD); // erase an entire flash bank, confirm overwrite of protected program
004309  004695  // Notes    : This function should be used with extreme caution.
004310  004696  //          : The selected bank will be completely erased regardless of FLASH_WRITE_PROTECT status
004311  004697  //          : if the confirmation value is set to hex 0xDEAD. If confirmation is any other value,
004312  004698  //          : a protected bank will not be erased, and function will return with 0
004313  004699  //          : If the destination bank is the same as the execution bank, the processor will reset
004314  004700  //          : upon completion of erase. If the "bank" argument is set to ALL (-1) and confirmation is set to 0xDEAD
004315  004701  //          : FLASHBANK_0 thru FLASHBANK_5 are cleared.
004316  004702  //          : Used with caution, this is a good way to 'clean up' the entire flash when starting new projects.
004317  004703  // Returns  : returns true if the function succeeded
004318  004704  //          : NB:- reset processor if program is erasing itself, or the ALL bank option is selected.
004319  004705        
004320  004706  func flash_LoadFile("bank", "filename"), 1;
004321  004707  // Syntax   : flash_LoadFile(bank, ptr);
004322  004708  // Usage    : result := flash_LoadFile(FLASHBANK_2, "TETRIS10.EXE"); // load the file from disk into FLASHBANK_2
004323  004709  // Notes    : Copies a file from uSD to the required flashbank.
004324  004710  //          : The destination bank cannont be the execution bank, or a bank that is write protected
004325  004711  // Returns  : returns true if the function succeeded.
004326  004712        
004327  004713        
004328  004714  func flash_WriteBlock("sourceptr", "bank", "page"), 1;
004329  004715  // Syntax   : flash_WriteBlock(pbuf, bank, page);
004330  004716  // Usage    : result := flash_WriteBlock(buffer, FLASHBANK_5, 8); // store the 2k buffer to FLASHBANK_5, location 16384
004331  004717  // Notes    : Copies a 2kbyte buffer to the required flashbank in block 0-15.
004332  004718  //          : The address of each block is 0, 2048, 4096 etc, determined by the page number 0-15.
004333  004719  //          : The destination bank cannot be an execution bank, or a program bank that is write protected.
004334  004720  // Returns  : returns true if the function succeeded.
004335  004721        
004336  004722        
004337  004723  func flash_putstr("bank", "ptr"), 1;
004338  004724  // Syntax   : flash_putstr(bank, ptr);
004339  004725  // Usage    : flash_Copy(FLASHBANK_2, 350); // print a string from FLASHBANK_2, location 350
004340  004726  // Notes    : Works the same as putstr, however, the source of the asciiz string is in FLASH storage
004341  004727  //          : Output may be redirected with the to(..) function. Bit15 of ptr is assumed 0.
004342  004728  // Returns  : True if function succeeds, usually ignored. 0 if bank is read protected
004343  004729        
004344  004730  func flash_Blit16("bank", "offset", "count"), 1;
004345  004731  // Syntax   : flash_Blit16(bank, offset, pixelcount);
004346  004732  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit16(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (800 bytes)
004347  004733  // Notes    : Blit an image to a GRAM window from FLASH storage.
004348  004734  //          : Image is stored 16bits per pixel (565) in a linear fashion to suit the GRAM mechanism
004349  004735  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004350  004736        
004351  004737  func flash_Blit8("bank", "offset", "count"), 1;
004352  004738  // Syntax   : flash_Blit8(bank, offset, pixelcount);
004353  004739  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit8(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (400 bytes)
004354  004740  // Notes    : Blit an image to a GRAM window from FLASH storage.
004355  004741  //          : Image is stored 8 bits per pixel (332 format) in a linear fashion to suit the GRAM mechanism
004356  004742  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004357  004743        
004358  004744  func flash_Blit4("bank", "offset", "count", "palette16colour"), 1;
004359  004745  // Syntax   : flash_Blit16(bank, offset, pixelcount, pal16);
004360  004746  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit4(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (200 bytes packed 4:4)
004361  004747  // Notes    : Blit an image to a GRAM window from FLASH storage.
004362  004748  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 16 x 16bit colours
004363  004749  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004364  004750        
004365  004751  func flash_Blit2("bank", "offset", "count", "palette4colour"), 1;
004366  004752  // Syntax   : flash_Blit16(bank, offset, pixelcount, pal4);
004367  004753  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit2(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (100 bytes packed 2:2:2:2)
004368  004754  // Notes    : Blit an image to a GRAM window from FLASH storage.
004369  004755  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 4 x 16bit colours
004370  004756  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004371  004757        
004372  004758  func flash_Blit1("bank", "offset", "count", "pallete2colour"), 1;
004373  004759  // Syntax   : flash_Blit1(bank, offset, pixelcount, pal2);
004374  004760  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit1(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (50 bytes packed 1:1:1:1:1:1:1:1)
004375  004761  // Notes    : Blit an image to a GRAM window from FLASH storage.
004376  004762  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 2 x 16bit colours
004377  004763  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004378  004764        
004379  004765  func flash_Exec("bank", "arglistptr"), 1;
004380  004766  // Syntax: res := flash_Exec("bank","arglistptr");
004381  004767  // Usage : res := flash_Exec("bank","arglistptr");
004382  004768  // Notes : returns like a function, current program
004383  004769  //       : calling program is kept active and control returns to it.
004384  004770  //       : If arglistptr is 0, no arguments are passed, else
004385  004771  //       : arglist points to an array, the first element being
004386  004772  //       : the number of elements in the array.
004387  004773  //       : func 'main' in the called bank accepts the arguments.
004388  004774  // WARNING Not currently implemented!
004389  004775        
004390  004776        
004391  004777  func __reserved68(), 0; // do not remove
004392  004778  func __reserved69(), 0; // do not remove
004393  004779  func __reserved70(), 0; // do not remove
004394  004780        
004395  004781  //=========================================================================================================
004396  004782  // I/O and hardware functions
004397  004783  //=========================================================================================================
004398  004784        
004399  004785        
004400  004786        
004401  004787        
004402  004788  func pin_Pulseout("pin", "value"), 1;        // non blocking (program execution continues during pulse)
004403  004789  func pin_PulseoutB("pin", "value"), 1;    // blocking (program execution suspended during pulse)
004404  004790  // Syntax: pin_Pulseout(pin, value);
004405  004791  // Usage : pin_Pulseout(PA3, 100);                 // output 100msec pulse on PA3
004406  004792  // Notes : only available on PA0 to PA9
004407  004793  //       : Invert the state of an output for "value" milliseconds.
004408  004794  //       : pulseout is non blocking, that is, code execution may continue while
004409  004795  //       : a pulse is occuring, and pulses can occur on multiple pins simultaneously.
004410  004796  //       : If not already an output, pin is automatically made a push/pull output,
004411  004797  //       : and the last state of its output latch will determine pulse polarity.
004412  004798  //       : It's its open drain state is not altered if the pin was already an output.
004413  004799  //       : If pulseout is called while pulseout is still active, the pulse timer
004414  004800  //       : will simply be updated with the new "value" and the pulse will continue
004415  004801  //       : with the extended value.
004416  004802  //       : returns true if the pin number is legal (usually ignored)
004417  004803        
004418  004804        
004419  004805  func pin_Counter("pin", "mode", "OVFfunction"), 1;
004420  004806  // Syntax: pin_Counter(pin, mode, userfunc);
004421  004807  // Usage : pin_Counter(PA5, 1, stopfunc);         // count rising edge pulses on pin PA5, call stopfunc on overflow
004422  004808  // Notes : only available on PA4 to PA9
004423  004809  //       : Connect a counter to a pin to count transistions, and optionally call an event function
004424  004810  //       : when the 16bit counter wraps from 0xFFFF to zero. The counter can be read or written
004425  004811  //       : to at any time with peekW and pokeW, therefore, the count may be set to eg 0xFFF0 so that eg:
004426  004812  //       : user function "OVFfuction" will be called after 16 pulses. If "OVFfunction" is set to zero, only the
004427  004813  //       : counter will increment, and simply wrap back to zero from 0xFFFF. If "OVFfunction" points to a user
004428  004814  //       : function, wnen the event fires, pin_Counter will be disabled, and will need to be re-armed (ie '1shot' operation)
004429  004815  //       : The pin may be configured as an input or output, the function behaves the same.
004430  004816  //       : All six pin counters may be active simultaneously, and the maximum frequency of pin transistions
004431  004817  //       : should not exceed a few Khz in mode 1 and 2and are usually used for simple process control counting.
004432  004818  //       : "mode" has the following effect:-
004433  004819  //       : mode COUNT_OFF(0)  = disconnect the counter from the pin, "OVFfunction" therefore ignored, and counting is inhibited.
004434  004820  //       : mode COUNT_RISE(1) = increment on every rising edge
004435  004821  //       : mode COUNT_FALL(2) = increment on every falling edge
004436  004822  //       : mode COUNT_EDGE(3) = increment on every rising and falling edge
004437  004823        
004438  004824  //------------------------------------------------------------------//
004439  004825  // pin counter mode constants                                       //
004440  004826  //------------------------------------------------------------------//
004441  004827  #CONST
004442  004832  #END
004443  004833        
004444  004834  func Qencoder1("PHApin", "PHBpin", "mode"), 1;
004445  004835  // Syntax: Qencoder1(pinA, pinB, mode);
004446  004836  // Usage : Qencoder1(PA4, PA5, stopfunc);         // connect PA4 and PA5 pins to qudrature encoder module #1
004447  004837  // Notes : not available on pins PA14 and PA15
004448  004838  //       : Connect a quadrature encoder to a pair of pins The position counter and delta can be read
004449  004839  //       : or written to at any time with peekW and pokeW using the following constants:-
004450  004840  //       : It is necessary to configure the pins first, depending on your requirements, eg
004451  004841  //       :           pin_Set(PIN_INP_HI, PA4);     // PA4 as input, with pullup to Vcc
004452  004842  //       : or maybe  pin_Set(PIN_INP, PA4);        // PA4 as input, no pullup or pulldown
004453  004843  //       : Returns true if the pin numbers are legal (usually ignored)
004454  004844  //    QEN1_COUNTER_LO
004455  004845  //    QEN1_COUNTER_HI
004456  004846  //    QEN1_DELTA This is reset to 0 when read
004457  004847        
004458  004848  func Qencoder2("PHApin", "PHBpin", "mode"), 1;
004459  004849  // Syntax: Qencoder2(pinA, pinB, mode);
004460  004850  // Usage : Qencoder2(PA4, PA5, stopfunc);         // connect PA4 and PA5 pins to qudrature encoder module #2
004461  004851  // Notes : not available on pins PA14 and PA15
004462  004852  //       : Connect a quadrature encoder to a pair of pins The position counter and delta can be read
004463  004853  //       : or written to at any time with peekW and pokeW using the following constants:-
004464  004854  //       : It is necessary to configure the pins first, depending on your requirements, eg
004465  004855  //       :           pin_Set(PIN_INP_HI, PA4);     // PA4 as input, with pullup to Vcc
004466  004856  //       : or maybe  pin_Set(PIN_INP, PA4);        // PA4 as input, no pullup or pulldown
004467  004857  //       : Returns true if the pin numbers are legal (usually ignored)
004468  004858  //    QEN2_COUNTER_LO
004469  004859  //    QEN2_COUNTER_HI
004470  004860  //    QEN2_DELTA This is reset to 0 when read
004471  004861        
004472  004862        
004473  004863  func Qencoder1Reset(), 0;
004474  004864  // Syntax: Qencoder1Reset();
004475  004865  // Usage : Qencoder1Reset();     // reset the counter and delta value for encoder #1
004476  004866  // Notes :
004477  004867  //    QEN1_COUNTER_LO is reset to zero
004478  004868  //    QEN1_COUNTER_HI is reset to zero
004479  004869  //    QEN1_DELTA is reset to zero
004480  004870        
004481  004871  func Qencoder2Reset(), 0;
004482  004872  // Syntax: Qencoder2Reset();
004483  004873  // Usage : Qencoder2Reset();     // reset the counter and delta value for encoder #2
004484  004874  // Notes :
004485  004875  //    QEN2_COUNTER_LO is reset to zero
004486  004876  //    QEN2_COUNTER_HI is reset to zero
004487  004877  //    QEN2_DELTA is reset to zero
004488  004878        
004489  004879        
004490  004880  func pin_PulseoutCount("pin", "freq", "count", "function"), 1;        // pulse pin at freq count times calling function when complete
004491  004881  // Syntax: pin_PulseoutCount(pin, freq, count, function);
004492  004882  // Usage : pin_PulseoutCount(PA4, 1000, 5000, 0);            // output 5000 1msec pulses on PA3
004493  004883  // Notes : only available on PA4 to PA9, maximum 3 active at any one time
004494  004884  //       : Invert the state of an output at a "freq" freuency "count" times.
004495  004885  //       : PulseoutCount is non blocking, that is, code execution may continue while
004496  004886  //       : pulses are occuring, and pulses can occur on multiple pins simultaneously.
004497  004887  //       : If not already an output, pin is automatically made a push/pull output,
004498  004888  //       : and the last state of its output latch will determine pulse polarity.
004499  004889  //       : It's its open drain state is not altered if the pin was already an output.
004500  004890  //       : If PulseoutCount is called while PulseoutCount is still active, the pulse counter
004501  004891  //       : will simply have the new "value" added to it.
004502  004892  //       : returns false if the pin number is illegal, freq is < 10, or all counters in use
004503  004893  //       : returns true if the pin number is legal (usually ignored)
004504  004894        
004505  004895  func __reserved72(), 0; // do not remove
004506  004896        
004507  004897  func pwm_Init("pin", "mode", "value"), 1;    // set pin PA4-PA9 for the required PWM mode and select its source
004508  004898  // Syntax: pwm_Init(pin, value);
004509  004899  // Usage : pwm_Init(PA4, 1, 500);                 // output 50% duty cycle on PA4
004510  004900  // Notes : only available on PA4 to PA9
004511  004901  //       : Mode PWM_OFF(0)    : Turn off the PWM (pin is left as output)
004512  004902  //       : Mode PWM_PLAIN(1)  : Plain PWM value is 0-1000, corresponding to 0-100% duty cycle.
004513  004903  //       :                    : Raw frequency ~70khz. A value of 1 is not valid
004514  004904  //       : Mode PWM_SERVO(2)  : Servo PWM value is 100-200, corresponding to 1.00 to 2.00 ms
004515  004905  //       :                    : Values of 0 to 600 are valid (0-6ms), but should be used with caution.
004516  004906  //       :                    : Repetition rate ~50hz or 20ms
004517  004907  //       : Mode PWM_BINARY(3) : Binary PWM value is 0-1024, corresponding to 0-100% duty cycle.
004518  004908  //       :                    : Raw frequency ~68khz. A value of 1 is not valid
004519  004909  //       : pwm_Init is non blocking and the pwm continues until turn off
004520  004910  //       : Returns true if the pin number is legal (usually ignored)
004521  004911        
004522  004912  //------------------------------------------------------------------------------
004523  004913  // PWM Constants
004524  004914  //------------------------------------------------------------------------------
004525  004915  #CONST
004526  004928  #END
004527  004929        
004528  004930  func OW_Reset("pin"), 1;                             // issue 1wire reset command
004529  004931  // Syntax   : OW_Reset(PA0);
004530  004932  // Usage    : OW_Reset(PA0);
004531  004933  // Notes    : Only available on PA0 to PA13
004532  004934  //          : Resets  ONEWIRE device
004533  004935  //          : Returns the status, 0 = ACK.
004534  004936  //          :
004535  004937        
004536  004938  func OW_Read("pin"), 1;                              // read data from 1wire bus
004537  004939  // Syntax   : OW_Read(PA0);
004538  004940  // Usage    : arg1 := OW_Read(PA0);
004539  004941  // Notes    : Only available on PA0 to PA13
004540  004942  //          : Reads value of the ONEWIRE pin
004541  004943  //          : that was previously selected for ONEWIRE comms.
004542  004944  //          :
004543  004945  //          : pin = 0 : the next byte from the ONEWIRE bus
004544  004946        
004545  004947  func OW_Read9("pin"), 1;                             // read data from 1wire bus, 9bit mode
004546  004948  // Syntax   : OW_Read9(PA0);
004547  004949  // Usage    : OW_Read9(PA0);
004548  004950  // Notes    : Only available on PA0 to PA13
004549  004951  //          : Reads 9 bit value of the appropriate ONEWIRE pin
004550  004952  //          : that was previously selected for ONEWIRE comms.
004551  004953  //          :
004552  004954  //          : read the 9 bits from the ONEWIRE bus
004553  004955        
004554  004956  func OW_Write("pin", "value"), 0;                      // write value to 1wire device
004555  004957  // Syntax   : OW_Write(PA0, arg);
004556  004958  // Usage    : OW_Write(PA0, arg);
004557  004959  // Notes    : Only available on PA0 to PA13
004558  004960  //          : Sends ONEWIRE data on the appropriate
004559  004961  //          : pin that was previously  selected as ONEWIRE comms.
004560  004962  //          :
004561  004963  //          : write arg to the ONEWIRE bus
004562  004964        
004563  004965  func __reserved77(), 0; // do not remove
004564  004966  func __reserved78(), 0; // do not remove
004565  004967        
004566  004968  func sys_GetDateVar("&year", "&month", "&day"), 0;              // get year, month, day into variables
004567  004969  // Syntax: sys_GetDateVar(&year, &month, &day);
004568  004970  // Usage : sys_GetDateVar(&year, &month, &day);
004569  004971  // Notes : Retrieves the date values into variables
004570  004972        
004571  004973  func sys_GetTimeVar("&hour", "&minute", "&second", "&msecs"), 0;              // get hour, minute, second, millseconds into variables
004572  004974  // Syntax: sys_GetTimeVar(&hour, &minute, &second, &msecs);
004573  004975  // Usage : sys_GetTimeVar(&hour, &minute, &second, &msecs);
004574  004976  // Notes : Retrieves the time values into variables
004575  004977        
004576  004978  func sys_PmmC(), 0;
004577  004979  // Syntax: sys_PmmC();
004578  004980  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer
004579  004981  // Notes : print the system PmmC name and revision eg "Diablo16\n1.0"
004580  004982  //       : Can be captured to a buffer using the to( function
004581  004983  //       : Returns nothing.
004582  004984        
004583  004985  func sys_Driver(), 0;
004584  004986  // Syntax: sys_Driver();
004585  004987  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer
004586  004988  // Notes : print the system PmmC name and revision eg "uLCD-32WDTU-A\n130411"
004587  004989  //       : Can be captured to a buffer using the to( function
004588  004990  //       : Returns nothing.
004589  004991        
004590  004992  func gfx_Scope("left", "width", "yzero", "n", "xstep", "Yamp", "colorbg", "&old_y1", "&new_y1", "color1", "&old_y2", "&new_y2", "color2", "&old_y3", "&new_y3", "color3", "&old_y4", "&new_y4", "color4"), 0;
004591  004993  // Notes : Draws up to 4 waveforms from table(s) of vertices at the specified origin.
004592  004994  //       : "Left" is the left margin, "Width" is the width, "yzero" is the y position
004593  004995  //       : that corresponds to a y value of zero, normally "Top" + "Height" for
004594  004996  //       : a graph, or "Top" + "Height"/2 for a scope. "n" is the number of
004595  004997  //       : elements in each buffer. This will need to be greater than "width" for negative
004596  004998  //       : "xstep" values. "Yamp" is for amplification in the Y direction, 100 is unity.
004597  004999  //       : pass 0 as the address for any unused traces
004598  005000  //       : X position is incremented each point by "xstep" pixels.
004599  005001  //       : Y values are derived from a Y buffer "newy" (signed values).
004600  005002  //       : 2 buffers need to be supplied, "newy" contains new
004601  005003  //       : points to be drawn, "oldy" contains most recent set
004602  005004  //       : of points to be un-drawn. After the waveform is drawn,
004603  005005  //       : "newy" buffer is automatically copied to "oldy" buffer.
004604  005006        
004605  005007        
004606  005008  func ana_HS("rate", "samples", "&IO1", "&IO2", "&IO3", "&IO4", "COMPLETEfunction"), 0;
004607  005009  // Syntax: ana_HS(rate, samples, IO1buf, IO2buf, IO3buf, IO4buf, userFunction);
004608  005010  // Usage : ana_HS(1000, 10, IO1buf, 0, 0, 0, myFunc);
004609  005011  // Notes : Collects "samples" samples at "rate" frequency for 0 to 4 analogue pins
004610  005012  //       : and calls "COMPLETEfunction" when done.
004611  005013  //       : "rate" is samples in 100 of samples per second
004612  005014  //       : Any unused IOx pins should have their buffer addresses set to 0
004613  005015  //       : For performance reasons samples are taken in chunks of 32, thus if you
004614  005016  //       : request 33 samples there will be a delay of 31 samples before
004615  005017  //       : "COMPLETEfunction" is called
004616  005018  //       : If Touch is enabled this function should be called no more than once per
004617  005019  //       : millisecond, otherwise touch behaviour could be eratic.
004618  005020        
004619  005021        
004620  005022  func sys_ErrorMessage("msgnum"), 1;
004621  005023        
004622  005024  //==============================//
004623  005025  // NeoPixel specific functions  //
004624  005026  //==============================//
004625  005027        
004626  005028  func NP_Write("pin", "data", "size", "Options", "RepeatFirst", "Repeat", "RepeatLast"), 1;    // Write a string of colours to a NeoPixel 'display'
004627  005029  // Syntax: NP_Write(pin, data, size, Options, RepeatFirst, Repeat, RepeatLast);
004628  005030  // Usage : NP_Write(PA4, data, 50, NP_565, 10, 0, 0);                 
004629  005031  // Notes : pin         : The I/O pin for the operation PA0 to PA13
004630  005032  //       : data        : Address of data to be sent
004631  005033  //       : size        : number of colour 'sets' to follow
004632  005034  //       : Options     : format of colour data to be sent, NP_565, NP_RGB, or NP_XRGB. i.e. 2, 3 or 4 bytes per colour
004633  005035  //       : RepeatFirst : Number of times to repeat the first colour (0 means first colour is not considered 'special')
004634  005036  //       : Repeat      : Number of times to repeat the colours between first and last
004635  005037  //       : RepeatLast  : Number of times to repeat the last colour (0 means last colour is not considered 'special')
004636  005038  //       : Returns true if the pin number is legal (usually ignored)
004637  005039  //       : Due to the critical timing requirements of the NeoPixel, the system Timer is disabled during this operation.
004638  005040  //       : Comms Interrupts should also be disabled by the user, otherwise errors may occur.
004639  005041        
004640  005042  // NeoPixel related constants
004641  005043  #CONST
004642  005047  #END
004643  005048        
004644  005049  func __reserved85(), 0; // do not remove
004645  005050  func __reserved86(), 0; // do not remove
004646  005051        
004647  005052  //==============================================//
004648  005053  // spi flash device specific functions          //
004649  005054  //==============================================//
004650  005055        
004651  005056  func spiflash_SIG("spi#", "enablepin"), 1;         // read Jedec signature from SPI Flash device
004652  005057  // Syntax   : spiflash_SIG("spi#","enablepin");
004653  005058  // Usage    : var := spiflash_SIG(SPI1, PA0);
004654  005059  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004655  005060  //          : spi_Init(...) function, the Electronic Signature of the device can be read using this function. The only
004656  005061  //          : devices supported so far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004657  005062  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004658  005063  //          : Release from Deep Power-down, and Read Electronic Signature. Only the low order byte is valid, the upper
004659  005064  //          : byte is ignored.
004660  005065        
004661  005066  func spiflash_ID("spi#", "enablepin"), 1;          // read ID code from FLASH device
004662  005067  // Syntax   : spiflash_ID("spi#","enablepin");
004663  005068  // Usage    : var := spiflash_ID(SPI1, PA0);
004664  005069  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004665  005070  //          : spi_Init(...) function, the memory type and capacity from the flash device can be read using this function
004666  005071  //          : The only devices supported so far M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004667  005072  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004668  005073  //          : Reads the memory type and capacity from the serial FLASH device. Hi byte contains type, and low byte
004669  005074  //          : contains capacity. Refer to the device data sheet for further information.
004670  005075        
004671  005076  func spiflash_BulkErase("spi#", "enablepin"), 0;    // erase the entire FLASH device
004672  005077  // Syntax	: spiflash_BulkErase("spi#","enablepin");
004673  005078  // Usage	: spiflash_BulkErase(SPI1, PA0);
004674  005079  // Notes	: A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004675  005080  // 	: spi_Init(...) function, the FLASH device can be completely erased using this function. The only devices
004676  005081  // 	: supported so far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004677  005082  // 	: Other similar devices should also work, provided they do not exceed 128Mbit.
004678  005083  // 	: Erases the entire flash media device. The function returns no value, and the operation can take up to 80
004679  005084  // 	: seconds depending on the size of the flash device. Note that not all devices support this command.
004680  005085  // 	: This uses the 0xC7 command.
004681  005086        
004682  005087  func spiflash_BlockErase("spi#", "enablepin", "block"), 0;            // erase the required 64k flash block
004683  005088  // Syntax	: spiflash_BlockErase("spi#", "enablepin", "block")
004684  005089  // Usage	: var := spiflash_BlockErase(SPI1, PA0, block_num)
004685  005090  // Notes	: A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004686  005091  // 	: spi_Init(...) function, the FLASH block can be erased using this function. The only devices supported so
004687  005092  // 	: far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004688  005093  // 	: Other similar devices should also work, provided they do not exceed 128Mbit.
004689  005094  // 	: E.g. there are 32 x 64K blocks on a 2Mb flash device.
004690  005095  // 	: blockAddress The address of the 64k FLASH block to be erased.
004691  005096  // 	: Erases the required block in a FLASH media device. The function returns no value, and the operation
004692  005097  // 	: can take up to 3 milliseconds.
004693  005098  // 	: This uses the 0xD8 command.
004694  005099        
004695  005100  func spiflash_SetAdd("spi#", "HiWord", "LoWord"), 0;           // set stream byte address
004696  005101  // Syntax: spiflash_SetAdd(AddHiWord, AddLoWord);
004697  005102  // Usage : spiflash_SetAdd(SPI1, arg1, arg2);
004698  005103  // Notes : Set FLASH internal Address pointer for bytewise access on the specified SPI port
004699  005104        
004700  005105  func spiflash_Read("*dest", "size", "spi#", "enablepin"), 1;
004701  005106  // Syntax: res := spiflash_Read("*dest", "size", "spi#", "enablepin"),
004702  005107  // Usage : res := spiflash_Read(memblock, 20, SPI1, PA0);
004703  005108  // Notes : Reads the specified number of bytes from the FLASH memory device on the specified SPI port and enable pin
004704  005109  //       : into the specified destination. The destination is a string pointer (i.e. BYTE aligned). The source
004705  005110  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004706  005111  //       : returns number of characters read
004707  005112  //       : if "dest" is zero, data is read direct to GRAM window
004708  005113  //       :
004709  005114        
004710  005115  func spiflash_Write("*source", "size", "spi#", "enablepin"), 1;
004711  005116  // Syntax: res := fwrite("*source", "size", "spi#", "enablepin"),
004712  005117  // Usage : res := fwrite(memblock, 20, SPI1, PA0);
004713  005118  // Notes : Writes the specified number of bytes to the FLASH memory device on the specified SPI port and enable pin
004714  005119  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004715  005120  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004716  005121  //       : returns number of bytes written
004717  005122  //       :
004718  005123        
004719  005124  func spiflash_Image("x", "y", "spi#", "enablepin"), 1;
004720  005125  // Syntax: spiflash_Image(x, y, "spi#", "enablepin");
004721  005126  // Usage : spiflash_Image(10, 10, SPI1, PA0);
004722  005127  // Notes : Display an image from a file at the current FLASH position set by spiflash_SetAdd()
004723  005128  //       : The image is displayed at x,y (with respect to top left corner).
004724  005129        
004725  005130  func spiflash_PutC("char", "spi#", "enablepin"), 0;
004726  005131  // Syntax: spiflash_PutC("char", "spi#", "enablepin");
004727  005132  // Usage : spiflash_PutC('x', SPI1, PA0);
004728  005133  // Notes : Writes a character (or byte) to the FLASH memory device on the specified SPI port and enable pin
004729  005134  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004730  005135  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004731  005136        
004732  005137  func spiflash_GetC("spi#", "enablepin"), 1;
004733  005138  // Syntax: spiflash_GetC("spi#", "enablepin");
004734  005139  // Usage : mychar := fgetC(SPI1, PA0);
004735  005140  // Notes : Reads a character (or byte) from the FLASH memory device on the specified SPI port and enable pin
004736  005141  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004737  005142  //       : by subsequent reads or writes.
004738  005143  //       : returns next char from file
004739  005144        
004740  005145  func spiflash_PutW("word", "spi#", "enablepin"), 0;
004741  005146  // Syntax: spiflash_PutW("word", "spi#", "enablepin");
004742  005147  // Usage : spiflash_PutW(0x1234, SPI1, PA0);
004743  005148  // Notes : Writes a word to the FLASH memory device on the specified SPI port and enable pin
004744  005149  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004745  005150  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004746  005151        
004747  005152  func spiflash_GetW("spi#", "enablepin"), 1;
004748  005153  // Syntax: spiflash_GetW("spi#", "enablepin");
004749  005154  // Usage : myword := fgetW(SPI1, PA0);
004750  005155  // Notes : Reads a word from the FLASH memory device on the specified SPI port and enable pin
004751  005156  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004752  005157  //       : by subsequent reads or writes.
004753  005158  // Notes : returns next word in file
004754  005159        
004755  005160  func spiflash_PutS("*source", "spi#", "enablepin"), 1;
004756  005161  // Syntax: res := spiflash_Puts("*source", "spi#", "enablepin"),
004757  005162  // Usage : res := spiflash_Puts(mystring, SPI1, PA0);
004758  005163  // Notes : Writes a string to the FLASH memory device on the specified SPI port and enable pin
004759  005164  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004760  005165  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004761  005166  //       : returns number of characters written
004762  005167  //       :
004763  005168        
004764  005169  func spiflash_GetS("*string", "size", "spi#", "enablepin"), 1;
004765  005170  // Syntax: res := spiflash_Gets("*string", "size", "spi#", "enablepin");
004766  005171  // Usage : res := spiflash_Gets(mystr , 81, SPI1, PA0); // read up to 80 chars
004767  005172  // Notes : Reads a string from the FLASH memory device on the specified SPI port and enable pin
004768  005173  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004769  005174  //       : by subsequent reads or writes.
004770  005175  //       : returns pointer to string or null if failed.
004771  005176  //       : spiflash_GetS(...) automatically appends a null-terminator to the data read.
004772  005177  //       : NB:- only reads up to "size-1" characters into "string"
004773  005178  //       : spiflash_GetS(...) will stop reading when any of the following conditions are true:
004774  005179  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
004775  005180  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
004776  005181  //       : C] It reaches the end of file
004777  005182  //       : D] A read error occurs.
004778  005183        
004779  005184  func spiflash_LoadFunction("spi#", "enablepin"), 1;
004780  005185  // Syntax: res := spiflash_LoadFunction("spi#", "enablepin");
004781  005186  // Usage : myfunc := spiflash_LoadFunction(SPI1, PA0);
004782  005187  // Notes : Load a function or program from the FLASH memory device on the specified SPI port and enable pin at
004783  005188  //       : the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes and
004784  005189  //       : return a function pointer to the allocation.
004785  005190  //       : The function can then be invoked just like any other
004786  005191  //       : function would be called via a function pointer.
004787  005192  //       : Parameters may be passed to it in a conventional way.
004788  005193  //       : The function may be discarded at any time when no
004789  005194  //       : longer required, thus freeing its memory resources.
004790  005195  //       : The loaded function can be discarded with mem_Free(..)
004791  005196  //       : eg:
004792  005197  //       : popupWindow := spiflash_LoadFunction("popupWindow1.4fn");
004793  005198  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
004794  005199  //       : then elsewhere in your program:-
004795  005200  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
004796  005201  //       : if(res == QUIT_APPLICATION) goto exitApp;
004797  005202  //       : Later in your program, when popupWindow is no longer
004798  005203  //       : required for the application:-
004799  005204  //       : res := mem_Free(popupWindow);
004800  005205  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
004801  005206  //       : The callers stack is shared by the loaded function,
004802  005207  //       : however any global variables in the loaded function
004803  005208  //       : are private to that function.
004804  005209  //
004805  005210        
004806  005211  func spiflash_Run("spi#", "enablepin", "arglistptr"), 1;
004807  005212  // Syntax: res := spiflash_Run("spi#", "enablepin", "arglistptr");
004808  005213  // Usage : res := spiflash_Run(SPI1, PA0, argptr);
004809  005214  // Notes : current program releases any allocated memory but
004810  005215  //       : retains the stack and global memory.
004811  005216  //       : If arglistptr is 0, no arguments are passed, else
004812  005217  //       : arglist points to an array, the first element being
004813  005218  //       : the number of elements in the array.
004814  005219  //       : func 'main' in the called program accepts
004815  005220  //       : the arguments, if any. The arguments can only
004816  005221  //       : be passed by value, no pointers or references can be
004817  005222  //       : used as all memory is cleared before the file
004818  005223  //       : is loaded. Refer to spiflash_Exec and spiflash_LoadFunction
004819  005224  //       : for functions that can pass by reference.
004820  005225        
004821  005226  func spiflash_Exec("spi#", "enablepin", "arglistptr"), 1;
004822  005227  // Syntax: res := spiflash_Exec("spi#", "enablepin", "arglistptr");
004823  005228  // Usage : res := spiflash_Exec(SPI1, PA0, "arglistptr");
004824  005229  // Notes : returns like a function, current program
004825  005230  //       : calling program is kept active and control returns to it.
004826  005231  //       : If arglistptr is 0, no arguments are passed, else
004827  005232  //       : arglist points to an array, the first element being
004828  005233  //       : the number of elements in the array.
004829  005234  //       : func 'main' in the called program accepts the arguments.
004830  005235  //       : This function is similar to spiflash_LoadFunction(...), however,
004831  005236  //       : the function argument list is passed by pointer, and
004832  005237  //       : the memory consumed by the function is released as
004833  005238  //       : soon as the function completes.
004834  005239        
004835  005240  func spiflash_LoadImageControl("spi#", "enablepin"), 1;
004836  005241  // Syntax: hImagelist := spiflash_LoadImageControl ("spi#", "enablepin"),
004837  005242  // Usage : hImagelist := spiflash_LoadImageControl (SPI1, PA0);
004838  005243  // Notes : Reads a control file to create an image list from the FLASH memory device on the specified SPI port
004839  005244  //       : and enable pin. The source is the address set by spiflash_SetAdd(), or incremented by subsequent reads
004840  005245  //       : or writes. The ".dat" file is first and is immediately followed a ^Z and then by the ".gci' file.
004841  005246  //       : Returns NULL if function fails.
004842  005247  //       : Returns a handle (pointer to the memory allocation) to the
004843  005248  //       : image control list that has been created.
004844  005249        
004845  005250  // Notes : This function Calculates the size of a chunk of memory required for
004846  005251  //       : a image list and populates it from the image control file ("*.dat")
004847  005252  //       : therefore, when imagelist is no longer required, you must de-allocate
004848  005253  //       : the image list memory by using eg:- mem_Free(hImagelist);
004849  005254  //       : to restore the heap.
004850  005255  //       :
004851  005256        
004852  005257  func spiflash_PlayWAV("spi#", "enablepin"), 1;
004853  005258  // Syntax: spiflash_PlayWAV("spi#", "enablepin");
004854  005259  // Usage : spiflash_PlayWAV(SPI1, PA0);
004855  005260  // Notes : Play a wave file from the FLASH memory device on the specified SPI port and enable pin.
004856  005261  //       : The source is the address set by spiflash_SetAdd(), or incremented by subsequent reads
004857  005262  //       : or writes.
004858  005263  //       : This function automatically grabs a chunk
004859  005264  //       : of memory for a file buffer, and a wave
004860  005265  //       : buffer. The minimum memory requirement is
004861  005266  //       : about 580 bytes for the disk io service and
004862  005267  //       : a minimum wave buffer size of 1024. The size
004863  005268  //       : of the wave buffer allocation
004864  005269  //       : can be increased by the snd_BufSize function.
004865  005270  //       : The default size 1024 bytes.
004866  005271  //       : NB the memory is only required during the
004867  005272  //       : duration of play, and is automatically
004868  005273  //       : released while not in use.
004869  005274  //       : See the Sound Class services for other associated controls.
004870  005275  //       : If there are no errors, returns number of blocks to play (1 to 32767)
004871  005276  //       : If errors occured, the folling is returned
004872  005277  //       : -7  : Insufficient memory available for WAV buffer and file
004873  005278  //       : -6  : cant play this rate
004874  005279  //       : -5  : no data chunk found in first rsector
004875  005280  //       : -4  : no format data
004876  005281  //       : -3  : no wave chunk signature
004877  005282  //       : -2  : bad wave file format
004878  005283  //       : -1  : file not found
004879  005284        
004880  005285  //==============================================//
004881  005286  // more com functions                           //
004882  005287  //==============================================//
004883  005288        
004884  005289  func com1_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004885  005290  // Syntax   : com1_TXblock("buf", "bufsize");
004886  005291  // Usage    : com1_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004887  005292  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004888  005293  //          : if a transmit buffer is active and space is available this function will return almost
004889  005294  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004890  005295        
004891  005296  func com1_RXblock("buf", "bufsize"), 0;                       // commence a block reception
004892  005297  // Syntax   : com1_RXblock("buf", "bufsize");
004893  005298  // Usage    : com1_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004894  005299  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004895  005300  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004896  005301  //          : immediately otherwise it will block until until the required bytes are received.
004897  005302        
004898  005303  func com2_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004899  005304  // Syntax   : com_TXblock("buf", "bufsize");
004900  005305  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004901  005306  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004902  005307  //          : if a transmit buffer is active and space is available this function will return almost
004903  005308  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004904  005309        
004905  005310  func com2_RXblock("buf", "bufsize"), 0;                       // commence an block reception
004906  005311  // Syntax   : com_RXblock("buf", "bufsize");
004907  005312  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004908  005313  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004909  005314  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004910  005315  //          : immediately otherwise it will block until until the required bytes are received.
004911  005316        
004912  005317  func com3_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004913  005318  // Syntax   : com_TXblock("buf", "bufsize");
004914  005319  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004915  005320  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004916  005321  //          : if a transmit buffer is active and space is available this function will return almost
004917  005322  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004918  005323        
004919  005324  func com3_RXblock("buf", "bufsize"), 0;                       // commence an block reception
004920  005325  // Syntax   : com_RXblock("buf", "bufsize");
004921  005326  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004922  005327  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004923  005328  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004924  005329  //          : immediately otherwise it will block until until the required bytes are received.
004925  005330        
004926  005331  func disp_BlitPixelsFromCOM1(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004927  005332  // Syntax: disp_BlitPixelsFromCOM1();                  New in v1.1
004928  005333  // Usage : disp_BlitPixelsFromCOM1();
004929  005334  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004930  005335  //       : display from the specified com port.
004931  005336        
004932  005337  func disp_BlitPixelsFromCOM2(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004933  005338  // Syntax: disp_BlitPixelsFromCOM2();                  New in v1.1
004934  005339  // Usage : disp_BlitPixelsFromCOM2();
004935  005340  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004936  005341  //       : display from the specified com port.
004937  005342        
004938  005343  func disp_BlitPixelsFromCOM3(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004939  005344  // Syntax: disp_BlitPixelsFromCOM3();                  New in v1.1
004940  005345  // Usage : disp_BlitPixelsFromCOM3();
004941  005346  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004942  005347  //       : display from the specified com port.
004943  005348        
004944  005349        
004945  005350  //==============================================//
004946  005351  // crc generation functions                     //
004947  005352  //==============================================//
004948  005353        
004949  005354  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
004950  005355  // *Notes   : (if you calculate all of the incoming data
004951  005356  //          : INCLUDING the CRC, the result should be 0x00
004952  005357  //          : This is equivalent to simple addition of all bytes
004953  005358  //          : and returning the negated sum an 8 bit value.
004954  005359  //          : For the standard test string "123456789",
004955  005360  //          : crc_CSUM_8 will return 0x0023.
004956  005361        
004957  005362        
004958  005363  func crc_16("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate CRC16
004959  005364  // *Notes   : The "mode" argument may be READ, WRITE or CHECK
004960  005365  //          : (if you calculate all of the incoming data
004961  005366  //          : INCLUDING the CRC, the result should be 0x0000
004962  005367  //          : For the standard test string "123456789",
004963  005368  //          : crc_16 will return 0xBB3D.
004964  005369        
004965  005370        
004966  005371  func crc_MODBUS("buf","count"), 1;                  // given a pointer to a buffer and a byte count, calculate CRC16 for MODBUS
004967  005372  // *Notes   : (if you calculate all of the incoming data
004968  005373  //          : INCLUDING the CRC, the result should be 0x0000
004969  005374  //          : For the standard test string "123456789",
004970  005375  //          : crc_MODBUS will return 0x4B37.
004971  005376        
004972  005377        
004973  005378  func crc_CCITT("buf","count","seed"), 1;            // given a pointer to a buffer, byte count and seed, calculate the 16bit CRC for seed
004974  005379  // *Notes   : (if you calculate all of the incoming data
004975  005380  //          : INCLUDING the CRC, the result should be 0x0000
004976  005381  //          : For the standard test string "123456789",
004977  005382  //          : crc_CCITT will return the following:-
004978  005383  //          : seed = 0 (XMODEM protocol) result = 0x31C3
004979  005384  //          : seed = 0xFFFF, result = 0x29B1
004980  005385  //          : seed = 0x1D0F, result = 0xE5CC
004981  005386        
004982  005387  func __reserved87(), 0; // do not remove
004983  005388  func __reserved88(), 0; // do not remove
004984  005389  func __reserved89(), 0; // do not remove
004985  005390        
004986  005391  //----------------------------------------------------------------------------//
004987  005392  //  functions to support buffered transmission and reception of break signal  //
004988  005393  //----------------------------------------------------------------------------//
004989  005394        
004990  005395  func com_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
004991  005396  // Usage : com_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
004992  005397  // Usage : com_TXbufferBrk(0, 0, 0);             // revert to non buffered service
004993  005398  // Notes : initialize a serial buffer for the COM0 output.
004994  005399  //       : The program must declare a var array as a circular buffer.
004995  005400  //       : When a TX buffer is declared for comms, the transmission
004996  005401  //       : of characters becomes non blocking. If the buffer has
004997  005402  //       : insufficient space to accept the next character from a
004998  005403  //       : serout_x() function, the excess characters will be ignored,
004999  005404  //       : and the com_Full_x() error will be asserted.   If the
005000  005405  //       : TX buffer is no longer required, just set the buffer pointer
005001  005406  //       : to zero, the size in this case doesnt matter and is ignored.
005002  005407  //       : The function can resize or reallocated to another buffer at
005003  005408  //       : any time. The buffer is flushed before any changes are made.
005004  005409  //       : "pin" designates an IO pin to control a bi-directional
005005  005410  //       : control device for half duplex mode. "pin" will go HI at the
005006  005411  //       : start of a transmission, and will return low after the final
005007  005412  //       : byte is transmitted. If not required, just set "pin" to zero.
005008  005413        
005009  005414  func com1_TXbufferBrk("buf", "bufsize", "pin"), 0;
005010  005415  // Usage : com1_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005011  005416  // Usage : com1_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005012  005417  // Notes : initialize a serial buffer for the COM0 output.
005013  005418  //       : The program must declare a var array as a circular buffer.
005014  005419  //       : When a TX buffer is declared for comms, the transmission
005015  005420  //       : of characters becomes non blocking. If the buffer has
005016  005421  //       : insufficient space to accept the next character from a
005017  005422  //       : serout_x() function, the excess characters will be ignored,
005018  005423  //       : and the com_Full_x() error will be asserted.   If the
005019  005424  //       : TX buffer is no longer required, just set the buffer pointer
005020  005425  //       : to zero, the size in this case doesnt matter and is ignored.
005021  005426  //       : The function can resize or reallocated to another buffer at
005022  005427  //       : any time. The buffer is flushed before any changes are made.
005023  005428  //       : "pin" designates an IO pin to control a bi-directional
005024  005429  //       : control device for half duplex mode. "pin" will go HI at the
005025  005430  //       : start of a transmission, and will return low after the final
005026  005431  //       : byte is transmitted. If not required, just set "pin" to zero.
005027  005432        
005028  005433  func com2_TXbufferBrk("buf", "bufsize", "pin"), 0;
005029  005434  // Usage : com2_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005030  005435  // Usage : com2_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005031  005436  // Notes : initialize a serial buffer for the COM0 output.
005032  005437  //       : The program must declare a var array as a circular buffer.
005033  005438  //       : When a TX buffer is declared for comms, the transmission
005034  005439  //       : of characters becomes non blocking. If the buffer has
005035  005440  //       : insufficient space to accept the next character from a
005036  005441  //       : serout_x() function, the excess characters will be ignored,
005037  005442  //       : and the com_Full_x() error will be asserted.   If the
005038  005443  //       : TX buffer is no longer required, just set the buffer pointer
005039  005444  //       : to zero, the size in this case doesnt matter and is ignored.
005040  005445  //       : The function can resize or reallocated to another buffer at
005041  005446  //       : any time. The buffer is flushed before any changes are made.
005042  005447  //       : "pin" designates an IO pin to control a bi-directional
005043  005448  //       : control device for half duplex mode. "pin" will go HI at the
005044  005449  //       : start of a transmission, and will return low after the final
005045  005450  //       : byte is transmitted. If not required, just set "pin" to zero.
005046  005451        
005047  005452  func com3_TXbufferBrk("buf", "bufsize", "pin"), 0;
005048  005453  // Usage : com3_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005049  005454  // Usage : com3_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005050  005455  // Notes : initialize a serial buffer for the COM0 output.
005051  005456  //       : The program must declare a var array as a circular buffer.
005052  005457  //       : When a TX buffer is declared for comms, the transmission
005053  005458  //       : of characters becomes non blocking. If the buffer has
005054  005459  //       : insufficient space to accept the next character from a
005055  005460  //       : serout_x() function, the excess characters will be ignored,
005056  005461  //       : and the com_Full_x() error will be asserted.   If the
005057  005462  //       : TX buffer is no longer required, just set the buffer pointer
005058  005463  //       : to zero, the size in this case doesnt matter and is ignored.
005059  005464  //       : The function can resize or reallocated to another buffer at
005060  005465  //       : any time. The buffer is flushed before any changes are made.
005061  005466  //       : "pin" designates an IO pin to control a bi-directional
005062  005467  //       : control device for half duplex mode. "pin" will go HI at the
005063  005468  //       : start of a transmission, and will return low after the final
005064  005469  //       : byte is transmitted. If not required, just set "pin" to zero.
005065  005470        
005066  005471  func com_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
005067  005472  // Syntax: com_InitBrk(buffer, bufsize, qualifier);
005068  005473  // Usage1: com_InitBrk(mybuf, 20, 0);
005069  005474  // Usage2: com_InitBrk(mybuf, 20, ':');
005070  005475  // Notes : initialize a serial capture buffer for the comms input
005071  005476  //       : The program must declare a var array as a circular buffer.
005072  005477  //       : Usage1 declares a circular buffer which will continually
005073  005478  //       : buffer characters.
005074  005479  //       : Usage2 must receive ':' before any characters will
005075  005480  //       : accumulate in the buffer.
005076  005481        
005077  005482  func com1_InitBrk("buf","bufsize","qualifier"), 0;
005078  005483  // Syntax: com1_InitBrk(buffer, bufsize, qualifier);
005079  005484  // Usage1: com1_InitBrk(mybuf, 20, 0);
005080  005485  // Usage2: com1_InitBrk(mybuf, 20, ':');
005081  005486  // Notes : initialize a serial capture buffer for the comms input
005082  005487  //       : The program must declare a var array as a circular buffer.
005083  005488  //       : Usage1 declares a circular buffer which will continually
005084  005489  //       : buffer characters.
005085  005490  //       : Usage2 must receive ':' before any characters will
005086  005491  //       : accumulate in the buffer.
005087  005492        
005088  005493  func com2_InitBrk("buf","bufsize","qualifier"), 0;
005089  005494  // Syntax: com2_InitBrk(buffer, bufsize, qualifier);
005090  005495  // Usage1: com2_InitBrk(mybuf, 20, 0);
005091  005496  // Usage2: com2_InitBrk(mybuf, 20, ':');
005092  005497  // Notes : initialize a serial capture buffer for the comms input
005093  005498  //       : The program must declare a var array as a circular buffer.
005094  005499  //       : Usage1 declares a circular buffer which will continually
005095  005500  //       : buffer characters.
005096  005501  //       : Usage2 must receive ':' before any characters will
005097  005502  //       : accumulate in the buffer.
005098  005503        
005099  005504  func com3_InitBrk("buf","bufsize","qualifier"), 0;
005100  005505  // Syntax: com3_InitBrk(buffer, bufsize, qualifier);
005101  005506  // Usage1: com3_InitBrk(mybuf, 20, 0);
005102  005507  // Usage2: com3_Init(mybuf, 20, ':');
005103  005508  // Notes : initialize a serial capture buffer for the comms input
005104  005509  //       : The program must declare a var array as a circular buffer.
005105  005510  //       : Usage1 declares a circular buffer which will continually
005106  005511  //       : buffer characters.
005107  005512  //       : Usage2 must receive ':' before any characters will
005108  005513  //       : accumulate in the buffer.
005109  005514        
005110  005515  func gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour"), 0;         // display an Annular ring segment
005111  005516  // Syntax 	: gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour") ;
005112  005517  // Usage 	: gfx_RingSegment(x, y, starta, enda, rx, w, colour) ;
005113  005518  // Notes 	: Draw a Segment of a ring at x, y from rad1 to rad2 starting at starta to enda
005114  005519  // 	: in colour.
005115  005520  //
005116  005521        
005117  005522  func gfx_AngularMeter("value", "&MeterRam", "&MeterDef"), 0;                           // draw an angular meter scale and value
005118  005523  // Syntax 	: gfx_AngularMeter("value", "&MeterRam", "&MeterDef") ;
005119  005524  // Usage 	: gfx_AngularMeter(value, MeterRam, MeterDef) ;
005120  005525  // Notes 	: Draw an Angular Meter as defined by MeterDef (if required), using MeterRam positioning at
005121  005526  // 	: position value. See the reference for the MeterDef values
005122  005527  //
005123  005528        
005124  005529  // AngularMeter constants
005125  005530  #CONST
005126  005581  #END
005127  005582        
005128  005583  #constant PANEL2_FILLED 0x8000
005129  005583  #constant PANEL2_FILLED 0x8000
005130  005584        
005131  005585  func gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf"), 0;                           // draw a windows style 3D panel
005132  005586  // Syntax 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
005133  005587  // Usage 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
005134  005588  // Notes	: Draws a panel2 (groupbox) at screen location defined by
005135  005589  // 	: x, y, width and height with left colour "cl", right colour "cr" and option fill colour "cf".
005136  005590  // 	:  w1 and w2 define the width of the outer and inner borders.
005137  005591  // 	:         state = 0 : recessed
005138  005592  // 	:         state = 1 : raised
005139  005593  // 	: 	  or state with PANEL2_FILLED to draw the fill
005140  005594        
005141  005595  func gfx_Needle("value", "&NeedleRam", "&NeedleDef"), 0;                           // draw a needle on a meter base
005142  005596  // Syntax 	: gfx_Needle("value", "&NeedleRam", "&NeedleDef") ;
005143  005597  // Usage 	: gfx_Needle(value, NeedleRam, NeedleDef) ;
005144  005598  // Notes 	: Draw a Needle as defined by NeedleDef (if required), using NeedleRam positioning at
005145  005599  // 	: position value. See the reference for the NeedleDef values
005146  005600  //
005147  005601        
005148  005602  #CONST
005149  005624  #END
005150  005625        
005151  005626  #CONST
005152  005633  #END
005153  005634        
005154  005635  func gfx_Dial("value", "&DialRam", "&DialDef"), 0;                           // draw a Dial / knob
005155  005636  // Syntax 	: gfx_Dial("value", "&DialRam", "&DialDef") ;
005156  005637  // Usage 	: gfx_Dial(value, DialRam, DialDef) ;
005157  005638  // Notes 	: Draw a Dial as defined by DialDef (if required), using DialRam positioning at
005158  005639  // 	: position value. See the reference for the DialDef values
005159  005640  //
005160  005641        
005161  005642  #CONST
005162  005700  #END
005163  005701        
005164  005702  func gfx_Gauge("value", "&GaugeRam", "&GaugeDef"), 0;                           // draw a gauge
005165  005703  // Syntax 	: gfx_Gauge("value", "&GaugeRam", "&GaugeDef") ;
005166  005704  // Usage 	: gfx_Gauge(value, GaugeRam, GaugeDef) ;
005167  005705  // Notes 	: Draw a Gauge as defined by GaugeDef (if required), using GaugeRam positioning at
005168  005706  // 	: position value. See the reference for the GaugeDef values
005169  005707  //
005170  005708        
005171  005709  #CONST
005172  005734  #END
005173  005735        
005174  005736  // widget_* functions
005175  005737  //
005176  005738  #CONST
005177  005771  #END
005178  005772        
005179  005773  #CONST
005180  005776  #END
005181  005777        
005182  005778  #CONST
005183  005810  #END
005184  005811        
005185  005812  func gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef"), 0;                           // draw a value to a series of 7 segment led Digits
005186  005813  // Syntax 	: gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef");
005187  005814  // Usage 	: gfx_LedDigits(value, LedDigitRam, LedDigitDef);
005188  005815  // Notes 	: Draw a series of 7 segment Led Digits as defined by LedDigitDef, using LedDigitRam positioning at
005189  005816  // 	: position value. See the reference for LedDigitDef values.
005190  005817  //
005191  005818        
005192  005819  func gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value"), 0;                           // draw a single 7 segment led digit
005193  005820  // Syntax 	: gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value");
005194  005821  // Usage 	: gfx_LedDigit(x, y, digitsize, oncolour, offcolour, value);
005195  005822  // Notes 	: Draws a single 7 segment led Digit at x, y of size digitsize using oncolour and offcolour.
005196  005823  // 	: The value can be 0-9 (0-9), A-F (0x0a-0x0f), blank(0x10) and - (0x11).
005197  005824  //      : Or value with LEDDIGIT_F_SHOW_DP to show a decimal point, LEDDIGIT_F_DP_COMMA to make the Decimal
005198  005825  // 	: point a comma and LEDDIGIT_F_DP_ON to turn the decimal point on
005199  005826  // 	:
005200  005827  // 	: LEDDIGIT_F_SET_SEGMENTS can be used to turn value into a series of bits to turn on individual segments
005201  005828  //      : eg LEDDIGIT_F_SET_SEGMENTS + 9 will turn on the top and bottom segments. Again LEDDIGIT_F_SHOW_DP and
005202  005829  // 	: LEDDIGIT_F_DP_COMMA can be used, but in this case the DP is the 8th segment. 
005203  005830  // Returns : nothing.
005204  005831        
005205  005832  func widget_Create("count"), 1;
005206  005833  // Syntax 	: widget_Create("count"),
005207  005834  // Usage  	: widget_Create(count);
005208  005835  // Notes  	: Creates a widget Control capable of hoolding count elements and returns
005209  005836  //        	: a handle for the control.
005210  005837  // Returns	: Widget control handle.
005211  005838        
005212  005839  func widget_Add("hndl", "index", "widget"), 1;
005213  005840  // Syntax 	: widget_Add("hndl", "index", "widget"),
005214  005841  // Usage  	: widget_Add(hndl, index, widget);
005215  005842  // Notes  	: Add a widget ram entry "widget" into index "index" of the widget control referenced
005216  005843  //        	: by "hndl".
005217  005844  // Returns	: ssnothing.
005218  005845        
005219  005846  func widget_Delete("hndl", "index"), 1;
005220  005847  // Syntax 	: widget_Delete("hndl", "index"),
005221  005848  // Usage  	: widget_Delete(hndl, index);
005222  005849  // Notes  	: Delete widget ram entry "index" from the widget control referenced by "hndl".
005223  005850  // Returns	: sssnothing.
005224  005851        
005225  005852  func widget_Realloc("handle", "n"), 1;
005226  005853  // Syntax	: widget_Realloc(handle, n);
005227  005854  // Usage 	: Resizes a widget control to contain n entries, allowing it to be expanded or
005228  005855  //      	: condensed. Doing this unnecessarily can lead to RAM fragmentation. It is
005229  005856  //             	: much better to allocate widget controls once with the desired number of entries.
005230  005857  // Returns	: new handle to widget control.
005231  005858        
005232  005859  func widget_GetWord("hndl", "index", "offset"), 1;
005233  005860  // Syntax	: myvar := widget_GetWord("handle", "index", "offset");
005234  005861  // Usage 	: myvar := widget_GetWord(hndl, 5, WIDGET_YPOS);
005235  005862  // Notes 	: returns specified word (0-14) from a widget entry
005236  005863  //       	: refer to widget control entry offsets.
005237  005864        
005238  005865  func widget_Setposition("hndl", "index", "xpos", "ypos"), 1;
005239  005866  // Syntax	: widget_SetPosition(handle, index, xpos, ypos);
005240  005867  // Usage 	: r := widget_SetPosition(hImageList, imagenum, x, y);
005241  005868  // Notes 	: set the position of the widget control
005242  005869  //       	: returns true if index was ok and function was successful.
005243  005870        
005244  005871  func widget_Enable("hndl", "index"), 1;
005245  005872  // Syntax	: widget_Enable(handle, index);
005246  005873  // Usage 	: r := widget_Enable(hImageList, imagenum);
005247  005874  // Notes 	: enable an item in a widget control.
005248  005875  // Returns     	: true if index was ok and function was successful.
005249  005876        
005250  005877  func widget_Disable("hndl", "index"), 1;
005251  005878  // Syntax	: widget_Disable(handle, index);
005252  005879  // Usage 	: r := widget_Disable(hImageList, imagenum);
005253  005880  // Notes 	: disable an inetm in a widget control.
005254  005881  // Returns      : true if index was ok and function was successful.
005255  005882        
005256  005883  func widget_SetWord("hndl", "index", "offset", "value"), 1;
005257  005884  // Syntax: widget_SetWord(handle, index, offset, word);
005258  005885  // Usage : widget_SetWord(hndl, 5, IMAGE_XPOS, 10);
005259  005886  // Notes : set specified word (0-7) in a image entry
005260  005887  //       : returns TRUE if successful, return value usually ignored.
005261  005888        
005262  005889  func widget_SetAttributes("hndl", "index", "value"), 1;
005263  005890  // Syntax: widget_SetAttributes("handle", "index","offset");
005264  005891  // Usage : widget_SetAttributes(hndl, 5, I_TOPMOST);
005265  005892  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
005266  005893  //       : of an image control entry. "value" refers to various bits in
005267  005894  //       : the image control entry (see image attribute flags).
005268  005895  //       : A '1' bit in the "value" field SETS the respective bit
005269  005896  //       : in the IMAGE_FLAGS field of the image control entry.
005270  005897  //       : returns TRUE if successful, return value usually ignored.
005271  005898        
005272  005899  func widget_ClearAttributes("hndl", "index", "value"), 1;
005273  005900  // Syntax: widget_ClearAttributes("handle", "index","offset");
005274  005901  // Usage : widget_ClearAttributes(hndl, 5, I_TOPMOST);
005275  005902  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
005276  005903  //       : of an image control entry. "value" refers to various bits in
005277  005904  //       : the image control entry (see image attribute flags)
005278  005905  //       : a '1' bit in the "value" field CLEARS the respective bit
005279  005906  //       : in the IMAGE_FLAGS field of the image control entry.
005280  005907  //       : returns TRUE if successful, return value usually ignored.
005281  005908        
005282  005909  func widget_Touched("hndl", "index"), 1;
005283  005910  // Syntax: r := widget_Touched(handle, index);
005284  005911  // Usage : widget_Touched(hndl, 17);
005285  005912  //       : returns -1 if image not touched, or returns index
005286  005913  // Notes : if index is passed as -1, function tests all images,
005287  005914  //       : and returns -1 if image not touched, or returns index.
005288  005915        
005289  005916  #CONST
005290  005954  #END
005291  005955        
005292  005956  func gfx_Slider5("value", "&SliderRam", "&SliderDef"), 0;                           // draw a slider
005293  005957  // Syntax 	: gfx_Slider5("value", "&SliderRam", "&SliderDef") ;
005294  005958  // Usage 	: gfx_Slider5(value, SliderRam, SliderDef) ;
005295  005959  // Notes 	: Draw a Slider as defined by SliderDef (if required), using SliderRam positioning at
005296  005960  // 	: position value. See the reference for the SliderDef values
005297  005961  //
005298  005962        
005299  005963  #CONST
005300  005982  #END
005301  005983        
005302  005984  func gfx_Switch("state", "&SwitchRam", "&SwitchDef"), 0;                           // draw a switch
005303  005985  // Syntax 	: gfx_Switch("state", "&SwitchRam", "&SwitchDef") ;
005304  005986  // Usage 	: gfx_Switch(state, SwitchRam, SwitchDef) ;
005305  005987  // Notes 	: Draw a Switch as defined by SwitchDef (if required), using SwitchRam positioning at
005306  005988  // 	: position value. See the reference for the SwitchDef values
005307  005989  //
005308  005990        
005309  005991  #CONST
005310  006020  #END
005311  006021        
005312  006022  func gfx_Button4("state", "&gfx_ButtonRam", "&gfx_ButtonDef"), 0;                           // draw a button
005313  006023  // Syntax 	: gfx_Button4("state", "&ButtonRam", "&ButtonDef") ;
005314  006024  // Usage 	: gfx_Button4(state, ButtonRam, ButtonDef) ;
005315  006025  // Notes 	: Draw a Button as defined by ButtonDef (if required), using ButtonRam positioning at
005316  006026  // 	: position value. See the reference for the ButtonDef values
005317  006027  //
005318  006028        
005319  006029  #CONST
005320  006044  #END
005321  006045        
005322  006046  func gfx_Led("state", "&LedRam", "&LedDef"), 0;                           // draw an LED
005323  006047  // Syntax 	: gfx_Led("state", "&LedRam", "&LedDef") ;
005324  006048  // Usage 	: gfx_Led(state, LedRam, LedDef) ;
005325  006049  // Notes 	: Draw a Led as defined by LedDef (if required), using LedRam positioning in
005326  006050  // 	: state state. See the reference for the LedDef values
005327  006051  //
005328  006052        
005329  006053  #CONST
005330  006071  #END
005331  006072  #CONST
005332  006090  #END
005333  006091        
005334  006092  func gfx_Scale("&ScaleRam", "&ScaleDef"), 0;                           // draw a Scale
005335  006093  // Syntax 	: gfx_Scale("&ScaleRam", "&ScaleDef") ;
005336  006094  // Usage 	: gfx_Scale(ScaleRam, ScaleDef) ;
005337  006095  // Notes 	: Draw a Scale as defined by ScaleDef, setting LedRam for use in touch processing.
005338  006096  // 	: See the reference for the ScaleDef values. If touch processing is not required 0 may be used as the SclaleRam parameter.
005339  006097  //
005340  006098        
005341  006099  #CONST
005342  006103  #END
005343  006104        
005344  006105  #CONST
005345  006125  #END
005346  006126        
005347  006127  func gfx_RulerGauge("state", "&RulerGaugeRam", "&RulerGaugeDef"), 0;                           // draw a Ruler Gauge
005348  006128  // Syntax 	: gfx_Led("position", "&RulerGaugeRam", "&RulerGaugeDef") ;
005349  006129  // Usage 	: gfx_Led(position, RulerGaugeRam, RulerGaugeDef) ;
005350  006130  // Notes 	: Draw a RulerGauge as defined by RulerGaugeDef (if required), using RulerGaugeRam positioning at
005351  006131  // 	: position value. See the reference for the RulerGaugeDef values
005352  006132  //
005353  006133        
005354  006134  #CONST
005355  006144  #END
005356  006145        
005357  006146  func file_CheckUpdate("Filename", "Options"), 1;                           // check and/or update the program running in Flash
005358  006147  // Syntax 	: file_CheckUpdate("Filename", "Options") ;
005359  006148  // Usage 	: file_CheckUpdate("thisfile.4xe", CheckUpdate_Check) ;
005360  006149  // Notes 	: Check and/or update the program running in flash using the specified file on uSD.
005361  006150  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
005362  006151  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
005363  006152  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
005364  006153  //
005365  006154  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
005366  006155  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
005367  006156  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
005368  006157  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
005369  006158  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
005370  006159  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
005371  006160        
005372  006161  func img_FileRead("*dest", "size", "handle", "index"), 1;
005373  006162  // Syntax: res := img_FileRead("*dest", "size", "handle", "index"),
005374  006163  // Usage : res := img_FileRead(memblock,20,hnd1);
005375  006164  // Notes : returns number of characters read
005376  006165  //       : if "dest" is zero, data is read direct to GRAM window
005377  006166  //       :
005378  006167        
005379  006168  func img_FileSeek("handle", "index", "HiWord", "LoWord"), 1;
005380  006169  // Syntax: res := img_FileSeek("handle", "index", "HiWord", "LoWord")
005381  006170  // Usage : res := img_FileSeek(hSource, 0, 0x1234);
005382  006171  // Notes : set file position to 0x00001234 (byte position 4660)
005383  006172  //       : for the file handle so subsequent data may be read
005384  006173  //       : from that position onwards with img_FileGetC(...),
005385  006174  //       : img_FileGetW(...) or img_FileGetS(...)
005386  006175  // Notes : returns true if ok, usually ignored
005387  006176        
005388  006177  func img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
005389  006178  // Syntax: img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
005390  006179  // Usage : res := img_FileIndex(hsource, 0, 1000, 123), 1;
005391  006180  // Notes : set file seek position to 123000
005392  006181  //       : for the file handle so subsequent data may be read
005393  006182  //       : from that record position onwards with img_FileGetC(...),
005394  006183  //       : img_FileGetW(...) or img_FileGetS(...)
005395  006184  // Notes : returns true if ok, usually ignored
005396  006185        
005397  006186  func img_FileTell("handle", "index", "&HiWord", "&LoWord"), 1;
005398  006187  // Syntax: img_FileTell("handle", "index", &HiWord, &LoWord);
005399  006188  // Usage : img_FileTell(fhndl, &SizeHi, &SizeLo);
005400  006189  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
005401  006190  //       : returns true if function succeeded
005402  006191        
005403  006192  func img_FileSize("handle", "index", "&HiWord", "&LoWord"), 1;
005404  006193  // Syntax: img_FileSize("handle", "index", &HiWord, &LoWord);
005405  006194  // Usage : img_FileSize(fhndl, &SizeHi, &SizeLo);
005406  006195  // Notes : Reads the 32 bit file size and stores it into 2 variables.
005407  006196  //       : returns true if function succeeded
005408  006197        
005409  006198  func img_FileGetC("handle", "index"), 1;
005410  006199  // Syntax: img_FileGetC("handle", "index");
005411  006200  // Usage : mychar := fgetC("handle", "index");
005412  006201  // Notes : returns next char from file
005413  006202        
005414  006203  func img_FileGetW("handle", "index"), 1;
005415  006204  // Syntax: img_FileGetW("handle", "index");
005416  006205  // Usage : myword := fgetW("handle", "index");
005417  006206  // Notes : returns next word in file
005418  006207        
005419  006208  func img_FileGetS("*string", "size", "handle", "index"), 1;
005420  006209  // Syntax: res := img_FileGets("*string", "size", "handle", "index");
005421  006210  // Usage : res := img_FileGets(mystr , 81, hnd1); // read up to 80 chars
005422  006211  // Notes : get a string from a file
005423  006212  //       : returns pointer to string or null if failed.
005424  006213  //       : img_FileGetS(...) automatically appends a null-terminator to the data read.
005425  006214  //       : NB:- only reads up to "size-1" characters into "string"
005426  006215  //       : img_FileGetS(...) will stop reading when any of the following conditions are true:
005427  006216  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
005428  006217  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
005429  006218  //       : C] It reaches the end of file
005430  006219  //       : D] A read error occurs.
005431  006220        
005432  006221  func img_FileRewind("handle", "index"), 1;
005433  006222  // Syntax: res := img_FileRewind("handle", "index");
005434  006223  // Usage : res := img_FileRewind(hnd1);
005435  006224  // Notes : returns true if file rewound ok (usually ignored)
005436  006225  //       : resets the file pointer the the beginning of the open file.
005437  006226        
005438  006227  func img_FileLoadFunction("handle", "index"), 1;
005439  006228  // Syntax: res := img_FileLoadFunction("handle", "index");
005440  006229  // Usage : myfunc := img_FileLoadFunction("handle", "index");
005441  006230  // Notes : Load a function or program from disk and
005442  006231  //       : return a function pointer to the allocation.
005443  006232  //       : The function can then be invoked just like any other
005444  006233  //       : function would be called via a function pointer.
005445  006234  //       : Parameters may be passed to it in a conventional way.
005446  006235  //       : The function may be discarded at any time when no
005447  006236  //       : longer required, thus freeing its memory resources.
005448  006237  //       : The loaded function can be discarded with mem_Free(..)
005449  006238  //       : eg:
005450  006239  //       : popupWindow := img_FileLoadFunction("handle", "index");
005451  006240  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
005452  006241  //       : then elsewhere in your program:-
005453  006242  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
005454  006243  //       : if(res == QUIT_APPLICATION) goto exitApp;
005455  006244  //       : Later in your program, when popupWindow is no longer
005456  006245  //       : required for the application:-
005457  006246  //       : res := mem_Free(popupWindow);
005458  006247  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
005459  006248  //       : The callers stack is shared by the loaded function,
005460  006249  //       : however any global variables in the loaded function
005461  006250  //       : are private to that function.
005462  006251  //
005463  006252        
005464  006253  func img_FileRun("handle", "index", "arglistptr"), 1;
005465  006254  // Syntax: res := img_FileRun("handle", "index","arglistptr");
005466  006255  // Usage : res := img_FileRun("handle", "index", argptr);
005467  006256  // Notes : current program releases any allocated memory but
005468  006257  //       : retains the stack and global memory.
005469  006258  //       : If arglistptr is 0, no arguments are passed, else
005470  006259  //       : arglist points to an array, the first element being
005471  006260  //       : the number of elements in the array.
005472  006261  //       : func 'main' in the called program accepts
005473  006262  //       : the arguments, if any. THe arguments can only
005474  006263  //       : be passed by value, no pointers or references can be
005475  006264  //       : used as all memory is cleared before the file
005476  006265  //       : is loaded. Refer to img_FileExec and img_FileLoadFunction
005477  006266  //       : for functions that can pass by reference.
005478  006267        
005479  006268  func img_FileExec("handle", "index", "arglistptr"), 1;
005480  006269  // Syntax: res := img_FileExec("handle", "index","arglistptr");
005481  006270  // Usage : res := img_FileExec("handle", "index","arglistptr");
005482  006271  // Notes : returns like a function, current program
005483  006272  //       : calling program is kept active and control returns to it.
005484  006273  //       : If arglistptr is 0, no arguments are passed, else
005485  006274  //       : arglist points to an array, the first element being
005486  006275  //       : the number of elements in the array.
005487  006276  //       : func 'main' in the called program accepts the arguments.
005488  006277  //       : This function is similar to img_FileLoadFunction(...), however,
005489  006278  //       : the function argument list is passed by pointer, and
005490  006279  //       : the memory consumed by the function is released as
005491  006280  //       : soon as the function completes.
005492  006281        
005493  006282  func img_FilePlayWAV("handle", "index"), 1;
005494  006283  // Syntax: img_FilePlayWAV("handle", "index");
005495  006284  // Usage : img_FilePlayWAV("handle", "index");
005496  006285  // Notes : Play a wave file at index "index" in the filesystem "handle"
005497  006286  //       : This function automatically grabs a chunk
005498  006287  //       : of memory for a file buffer, and a wave
005499  006288  //       : buffer. The minimum memory requirement is
005500  006289  //       : about 580 bytes for the disk io service and
005501  006290  //       : a minimum wave buffer size of 1024. The siz
005502  006291  //       : of the wave buffer allocation
005503  006292  //       : can be increased by the snd_BufSize function.
005504  006293  //       : The default size 1024 bytes.
005505  006294  //       : NB the memory is only required during the
005506  006295  //       : duration of play, and is automatically
005507  006296  //       : released while not in use.
005508  006297  //       : See the Sound Class services for other associated controls.
005509  006298  //       : If there are no errors, returns number of blocks to play (1 to 32767)
005510  006299  //       : If errors occured, the folling is returned
005511  006300  //       : -7  : Insufficient memory available for WAV buffer and file
005512  006301  //       : -6  : cant play this rate
005513  006302  //       : -5  : no data chunk found in first rsector
005514  006303  //       : -4  : no format data
005515  006304  //       : -3  : no wave chunk signature
005516  006305  //       : -2  : bad wave file format
005517  006306  //       : -1  : file not found
005518  006307        
005519  006308  func img_TxtFontID("handle", "index"), 1;                   // 2  text font ID (0 = system font)
005520  006309  // Syntax: img_TxtFontID("handle", "index");
005521  006310  // Usage : img_TxtFontID("handle", "index");
005522  006311  // Notes : Set the font to a font held in the image file system
005523  006312        
005524  006313  func spiflash_Block32Erase("spi#", "enablepin"), 1;            // erase the required 32k flash block
005525  006314  // Syntax	: flash_Block32Erase("spi#", "enablepin");
005526  006315  // Usage	: flash_Block32Erase(SPI1, PA0);
005527  006316  // Notes	: Erase the 32KB flash block including the currently set address
005528  006317  // 	: This uses the 0x52 command.
005529  006318        
005530  006319  func spiflash_Sector4Erase("spi#", "enablepin"), 1;            // erase the required 4k flash sector
005531  006320  // Syntax: flash_Sector4Erase("spi#", "enablepin");
005532  006321  // Usage : flash_Sector4Erase(SPI1, PA0);
005533  006322  // Notes	: Erase the 4KB flash sector including the currently set address
005534  006323  // 	: This uses the 0x20 command.
005535  006324        
005536  006325  func flash_FunctionCall("bank", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in a Flash GCI
005537  006326  // Syntax: img_FunctionCall(bank, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
005538  006327  // Usage : img_FunctionCall(bank, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
005539  006328  // Notes	: Calls the Flashbank passing index "index" as the first parameter. 
005540  006329  // 	: Other parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The second two parameters are passed
005541  006330  // 	: "as is", since the third parameter is normally in flash and one banks flash is not accessible from another
005542  006331  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
005543  006332  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
005544  006333  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
005545  006334  // 	: Returns 0 if successful.
005546  006335        
005547  006336  func flash_LoadSPIflash("bank", "hndl", "idx"), 1;
005548  006337  // Syntax   : flash_LoadFile(bank, ptr);
005549  006338  // Usage    : result := flash_LoadFile(FLASHBANK_2, "TETRIS10.EXE"); // load the file from disk into FLASHBANK_2
005550  006339  // Notes    : Copies a file from uSD to the required flashbank.
005551  006340  //          : The destination bank cannont be the execution bank, or a bank that is write protected
005552  006341  // Returns  : returns true if the function succeeded.
005553  006342        
005554  006343  func gfx_GradientShape("GradientRAM", "HorzVert", "OuterWidth", "X", "Y", "W", "H", "TLrad", "TRrad", "BLrad", "BRrad", "Darken", "OuterColor", "OuterType", "OuterLevel", "InnerColor", "InnerType", "InnerLevel", "Split"), 0 ;
005555  006344  // Syntax 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
005556  006345  // Usage 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
005557  006346  // Notes 	: Produce a shaped color gradient using the supplied parameters.0
005558  006347  // 	: GradientRAM	This Function requires a quantity or RAM to work. It also needs to be initialised and it's size varies accoring to the largest corner radius. Multiple gradient shape calls can
005559  006348  // 	: 	share the same GradientRAM. eg gradientRAM[29+91*2] := [-1,-1,-9999,0,0,91] ;  Would support a maximum radius of 90 degrees, note the 91 in two places.
005560  006349  // 	: HorzVert	Horizontal or Vertical -- 0 or 1
005561  006350  // 	: OuterWidth	Outer gradient width 0 to ...
005562  006351  // 	: X	x co-ordinate
005563  006352  // 	: Y	y co-ordinate
005564  006353  // 	: W	width
005565  006354  // 	: H	height
005566  006355  // 	: LTrad	Top left corner radius
005567  006356  // 	: TRrad	Top right corner radius
005568  006357  // 	: BLrad	Bottom left radius
005569  006358  // 	: BRrad	Bottom right radius
005570  006359  // 	: Darken	Darken both colours by a value. Can be a -ve value to lighten
005571  006360  // 	: OuterCol	Outer Gradient colour
005572  006361  // 	: OuterType	Outer Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
005573  006362  // 	: OuterLevel	Outer Gradient level 0 - 63
005574  006363  // 	: InnerCol	Inner Gradient colour
005575  006364  // 	: InnerType	Inner Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
005576  006365  // 	: InnerLevel	Inner Gradient level 0 - 63
005577  006366  // 	: Split	Split gradient, 0 - no split, 1 - top, 2 - bottom 
005578  006367  // 
005579  006368  // Returns	: nothing
005580  006369        
005581  006370        
005582  006371  func gfx_GradientColor("Type", "Darken", "Level", "H", "Pos", "Color"), 1 ;
005583  006372  // Syntax 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
005584  006373  // Usage 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
005585  006374  // Notes 	: Given the parameters, adjust the input color to produce the output color.
005586  006375  // 	: Type	Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
005587  006376  // 	: Darken	Darken colour by a value. Can be a -ve value to lighten
005588  006377  // 	: Level	Gradient level 0 - 63
005589  006378  // 	: H	Height of the object that gradient is applied
005590  006379  // 	: Pos	Position in the height that gradient is calculated
005591  006380  // 	: Color	Source colour that gradient is applied to
005592  006381  // 
005593  006382  // Returns	: Color after Adjustment.
005594  006383        
005595  006384  func gfx_GradTriangleFilled("X0", "Y0", "X1", "Y1", "X2", "Y2", "SolidCol", "GradientCol", "GradientHeight", "GradientY", "GradientLevel", "Type"), 0;
005596  006385  // Syntax 	: gfx_GradTriangleFilled(X0, Y0, X1, Y1, X2, Y2, SolidCol, GradientCol, GradientHeight, GradientY, GradientLevel, Type);
005597  006386  // Usage 	: gfx_GradTriangleFilled(10, 10, 10, 100, 100, 100 ,YELLOW, DARKKHAKI, 100, 10, 30, 1);
005598  006387  // Notes 	: Produce a triangle with or without a gradient.
005599  006388  // 	: X0	First triangle point x coordinate
005600  006389  // 	: Y0	First triangle point y coordinate
005601  006390  // 	: X1	Second triangle point x coordinate
005602  006391  // 	: Y1	Second triangle point y coordinate
005603  006392  // 	: X2	Third triangle point x coordinate
005604  006393  // 	: Y2	Third triangle point y coordinate
005605  006394  // 	: SolidCol	Colour that will be used if the Solid or Gradient parameter is set to 0
005606  006395  // 	: GradientCol	Colour that will be used if the Solid or Gradient parameter is set to 1
005607  006396  // 	: GradientHeight	Height of the area that the gradient will be calculated. Can be larger than the triangle
005608  006397  // 	: GradientY	Position on the Y axis that the gradient will be calculated from with respect to triangle position
005609  006398  // 	: GradientLevel	Level of gradient applied
005610  006399  // 	: Type	Select wether solid triangle or gardient triangle is drawn. 
005611  006400        
005612  006401  func spiflash_ReadByte("flags", "spi#", "enablepin"), 1;
005613  006402  // Syntax	: res := spiflash_Read(flag, "spi#", "enablepin");
005614  006403  // Usage	: res := spiflash_Read(0, SPI1, PA0);
005615  006404  // Notes	: Reads a byte from the FLASH memory device on the specified SPI port and enable pin
005616  006405  // 	: and returns it. The enable pin is lowered at the start of the operation and raised at the 
005617  006406  // 	: end unless the flag is set to SPIFLASH_HOLDCS is set, in which case the pin is left low.
005618  006407  // 	:
005619  006408        
005620  006409  func spiflash_WriteByte("reg/value", "spi#", "enablepin"), 0;
005621  006410  // Syntax	: res := fwrite(reg, spi, enablepin);
005622  006411  // Usage	: res := fwrite(0x80, SPI1, PA0);
005623  006412  // Notes	: Writes the specified byte to the FLASH memory device on the specified SPI port and enable pin.
005624  006413  // 	: The value may be a command or value depending upon where it is written to relative to the lowering of CS.
005625  006414  // 	: The enable pin is lowered at the start of the operation and raised at the end unless the reg/value has 
005626  006415  // 	: SPIFLASH_HOLDCS orred onto it, in which case the pin is left low.
005627  006416  // 	:
005628  006417        
005629  006418  func spiflash_SetMode("spi#", "mode"), 0;
005630  006419  // Syntax	: res := fwrite("spi#", "mode");
005631  006420  // Usage	: res := fwrite(SPI1, SPIMODE_ADDRESS3);
005632  006421  // Notes	: Sets the address size to be used to access the FLASH memory device on the specified SPI port and enable pin.
005633  006422  // 	: The size should be set using the correct command for the SPI FLASH memory device you are using.
005634  006423  // 	: Then this function should be called to enable that addresing mode to be used.
005635  006424  // 	: valid options are 
005636  006425  // 	: SPIFLASH_ADDRESS3	Address operand is 3 bytes long
005637  006426  // 	: SPIFLASH_ADDRESS4	Address operand is 4 bytes long
005638  006427        
005639  006428  func spiflash_LoadGCFImageControl("spi#", "enablepin"), 1;    // load a GCF image control into memory
005640  006429  // Syntax	: hImagelist := spiflash_LoadGCFImageControl("spi#", "enablepin")
005641  006430  // Usage	: hImagelist := spiflash_LoadGCFImageControl(SPI0, USD_ENABLE)
005642  006431  // Notes	: Reads a GCF file on Flash memory to create an image list.
005643  006432  // 	: Returns NULL if function fails.
005644  006433  // 	: Returns a handle (pointer to the memory allocation) to the
005645  006434  // 	: image control list that has been created.
005646  006435  // 	: spiflash_SetAdd() should have previously been called to set the GCIF start location.
005647  006436  // 	: spi# is the SPI interface to which the Flash memory chip is located SPI0 for the uSD port, or SPI1, SPI2 or SPI3.
005648  006437  // 	: enablepin is the enable, or CS pin for the Flash meory chip PA0-PA15, or USD_ENABLE for the uSD's enable pin.
005649  006438        
005650  006439  func gfx_XYrotToVal("x","y","base","mina","maxa","minv","maxv"), 1;         // convert a rotational x/y postion to a value
005651  006440  // Usage	: gfx_XYrotToVal(x,y,XYROT_EAST,starta,enda,minv,maxv)
005652  006441  // Notes	: Convert a rotational angle into a value
005653  006442  // 	: Calculates a position for a rotary input starting at mina and continuing to maxa. both angles must be greater than 0.
005654  006443  // 	: Base can be XYROT_EAST, used for internal widgets, or XYROT_SOUTH, used for GCI widgets.
005655  006444  // 	: Returns a value from minv to maxv
005656  006445        
005657  006446  func gfx_XYlinToVal("x","y","base","minpos","maxpos","minv","maxv"), 1;         // convert a linear x/y postion to a value
005658  006447  // Usage	: gfx_XYrotToVal(x,y,XYLIN_X,startp,endp,minv,maxv)
005659  006448  // Notes	: Convert a linear position into a value
005660  006449  // 	: Calculates a position for a linear input starting at minpos and continuing to maxpos. 
005661  006450  // 	: Base can be XYLIN_X, to use the x value for calculations, or XYLIN_Y, to use the y value.
005662  006451  // 	: Returns a value from minv to maxv
005663  006452        
005664  006453        
005665  006454  //------------------------------------------------------------------//
005666  006455  //     SPIFLASH constants                                           //
005667  006456  //------------------------------------------------------------------//
005668  006457  #constant SPIFLASH_HOLDCS	0x8000	// CS is not lowered after this operation
005669  006457  #constant SPIFLASH_HOLDCS	0x8000	// CS is not lowered after this operation
005670  006458        
005671  006459  //------------------------------------------------------------------//
005672  006460  //     break control constant                                       //
005673  006461  //------------------------------------------------------------------//
005674  006462  #constant BREAK      0xFFFD    // interpretation of the break signal
005675  006462  #constant BREAK      0xFFFD    // interpretation of the break signal
005676  006463        
005677  006464  //------------------------------------------------------------------//
005678  006465  // CONSTANTS
005679  006466  //------------------------------------------------------------------//
005680  006467        
005681  006468  #CONST
005682  006568  #END
005683  006569        
005684  006570  #CONST
005685  006575  #END
005686  006576        
005687  006577  // timebase constants for timebase_init
005688  006578  // NB only TB2 and TB4 can be used for synchronous A2D sampling.
005689  006579  #CONST
005690  006590  #END
005691  006591        
005692  006592        
005693  006593  // generic constants
005694  006594  #CONST
005695  006602  #END
005696  006603        
005697  006604        
005698  006605        
005699  006606  //gfx_Get() related constants
005700  006607  #CONST
005701  006616  #END
005702  006617        
005703  006618        
005704  006619        
005705  006620        
005706  006621  #CONST
005707  006634  #END
005708  006635        
005709  006636        
005710  006637  #CONST
005711  006662  #END
005712  006663        
005713  006664        
005714  006665        
005715  006666        
005716  006667  // timer control  related constants
005717  006668  #CONST
005718  006677  #END
005719  006678        
005720  006679        
005721  006680        
005722  006681  //------------------------------------------------------------------------------
005723  006682  // system WORD variables accesible with peekW and pokeW or pointer access
005724  006683  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
005725  006684  // can also be accessed with peekW and pokeW
005726  006685  //------------------------------------------------------------------------------
005727  006686        
005728  006687  #CONST
005729  006782  #END
005730  006783        
005731  006784  #CONST
005732  006949  #END
005733  006950        
005734  006951        
005735  006952        
005736  006953  //==================================================================================================
005737  006954        
005738  006955        
005739  006956        
005740  000013      #ENDIF
005741  000014        
005742  000015        
005743  000016  //===========================================================================================
005744  000017        
005745  000018        
005746  000002        
005747  000003  //#constant OLDCOMPILE
005748  000004        
005749  000005        
005750  000006  // generated 2/18/2021 5:24:22 PM
005751  000007  // uSDRequired:- 1   InternalRequired:- 1
005752  000008        
005753  000009  #MODE FLASHBANK_0
005754  000010        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

005755  000011  #inherit "4DGL_16bitColours.fnc"
005756  000011  #inherit "4DGL_16bitColours.fnc"
005757  000004  */
005758  000005        
005759  000006        
005760  000007        
005761  000008  #CONST
005762  000149  #END
005763  000150        
005764  000012        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

005765  000013  #inherit "VisualConst.inc"
005766  000013  #inherit "VisualConst.inc"
005767  000001  // Line Patterns
005768  000002  #constant  LPCOARSE    0xF0F0
005769  000002  #constant  LPCOARSE    0xF0F0
005770  000003  #constant  LPMEDIUM    0x3333
005771  000003  #constant  LPMEDIUM    0x3333
005772  000004  #constant  LPFINE      0xAAAA
005773  000004  #constant  LPFINE      0xAAAA
005774  000005  #constant  LPDASHDOT   0x03CF
005775  000005  #constant  LPDASHDOT   0x03CF
005776  000006  #constant  LPDASHDOTDOT 0x0333
005777  000006  #constant  LPDASHDOTDOT 0x0333
005778  000007  #constant  LPSOLID     0x0000
005779  000007  #constant  LPSOLID     0x0000
005780  000014        
005781  000015        
file C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGaugeConst.inc

005782  000016  #inherit "VolvoBoostGaugeConst.inc"
005783  000016  #inherit "VolvoBoostGaugeConst.inc"
005784  000001  // File generated 2/18/2021 5:24:22 PM
005785  000002  // Warning! This is a generated file, any manual changes will be
005786  000003  // lost during the next generation.
005787  000004        
005788  000005  #constant  IFONT_OFFSET     0
005789  000005  #constant  IFONT_OFFSET     0
005790  000006  // object indexes into WIDGET pointer
005791  000007  #CONST
005792  000016  #END
005793  000017        
005794  000018  // object indexes into ImageControl
005795  000019  #CONST
005796  000024  #END
005797  000025        
005798  000026        
005799  000027        
005800  000028  #IFNOT EXISTS NOGLOBALS
005801  000029  var hndl ;
005802  000030  #ENDIF
005803  000017        
005804  000018        
005805  000019        
005806  000020  #constant IPDatasize 22
005807  000020  #constant IPDatasize 22
005808  000021        
005809  000022  #CONST
005810  000026  #END
005811  000027        
005812  000028        
005813  000029        
005814  000030  #CONST
005815  000173  #END
005816  000174        
005817  000219  #END
5818  0326
5819  0327
5820  0328
5821  0329
5822  032A
5823  032B
5824  032C
5825  032D
5826  032E
5827  032F
5828  0330
5829  0331
5830  0332
5831  0333
5832  0334
5833  0335
5834  0336
5835  0337
5836  0338
5837  0339
5838  033A
5839  033B
5840  033C
5841  033D
5842  033E
5843  033F
5844  0340
5845  0341
5846  0342
5847  0343
5848  0344
5849  0345
5850  0346
5851  0347
5852  0348
5853  0349
5854  034A
5855  034B
5856  034C
5857  034D
5858  034E
5859  034F
5860  0350
5861  0351
5862  0352
5863  0353
5864  0354
5865  0355
5866  0356
5867  0357
5868  0358
5869  0359
5870  035A
5871  035B
5872  035C
5873  035D
5874  035E
5875  035F
5876  0360
5877  0361
5878  0362
5879  0363
5880  0364
5881  0365
5882  0366
5883  0367
5884  0368
5885  0369
5886  036A
5887  036B
5888  036C
5889  036D
5890  036E
5891  036F
5892  0370
5893  0371
5894  0372
5895  0373
5896  0374
5897  0375
5898  0376
5899  0377
5900  0378
5901  0379
5902  037A
5903  037B
5904  037C
5905  037D
5906  037E
5907  037F
5908  0380
5909  0381
5910  0382
5911  0383
5912  0384
5913  0385
5914  0386
5915  0387
5916  0388
5917  0389
5918  038A
5919  038B
5920  038C
5921  038D
5922  038E
5923  038F
5924  0390
5925  0391
5926  0392
5927  0393
5928  0394
5929  0395
5930  0396
5931  0397
5932  0398
5933  0399
5934  039A
5935  039B
5936  039C
5937  039D
5938  039E
5939  039F
5940  03A0
5941  03A1
5942  03A2
5943  03A3
5944  03A4
5945  03A5
5946  03A6
5947  03A7
5948  03A8
5949  03A9
5950  03AA
5951  03AB
5952  03AC
5953  03AD
5954  03AE
5955  03AF
5956  03B0
5957  03B1
5958  03B2
5959  03B3
5960  03B4
5961  03B5
5962  03B6
5963  03B7
5964  03B8
5965  03B9
5966  03BA
5967  03BB
5968  03BC
5969  03BD
5970  03BE
5971  03BF
5972  03C0
5973  03C1
5974  03C2
5975  03C3
5976  03C4
5977  03C5
5978  03C6
5979  03C7
5980  03C8
5981  03C9
5982  03CA
5983  03CB
5984  03CC
5985  03CD
5986  03CE
5987  03CF
5988  03D0
5989  03D1
5990  03D2
5991  03D3
5992  03D4
5993  03D5
5994  03D6
5995  03D7
5996  03D8
5997  03D9
5998  03DA
5999  03DB
6000  03DC
6001  03DD
6002  03DE
6003  03DF
6004  03E0
6005  03E1
6006  03E2
6007  03E3
6008  03E4
6009  03E5
6010  03E6
6011  03E7
6012  03E8
6013  03E9
6014  03EA
6015  03EB
6016  03EC
6017  03ED
6018  03EE
6019  03EF
6020  03F0
6021  03F1
6022  03F2
6023  03F3
6024  03F4
6025  03F5
6026  03F6
6027  03F7
6028  03F8
6029  03F9
6030  03FA
6031  03FB
6032  03FC
6033  03FD
6034  03FE
6035  03FF
6036  0400
6037  0401
6038  0402
6039  0403
6040  0404
6041  0405
6042  0406
6043  0407
6044  0408
6045  0409
6046  040A
6047  040B
6048  040C
6049  040D
6050  040E
6051  040F
6052  0410
6053  0411
6054  0412
6055  0413
6056  0414
6057  0415
6058  0416
6059  0417
6060  0418
6061  0419
6062  041A
6063  041B
6064  041C
6065  041D
6066  041E
6067  041F
6068  0420
6069  0421
6070  0422
6071  0423
6072  0424
6073  0425
6074  0426
6075  0427
6076  0428
6077  0429
6078  042A
6079  042B
6080  042C
6081  042D
6082  042E
6083  042F
6084  0430
6085  0431
6086  0432
6087  0433
6088  0434
6089  0435
6090  0436
6091  0437
6092  0438
6093  0439
6094  043A
6095  043B
6096  043C
6097  043D
6098  043E
6099  043F
6100  0440
6101  0441
6102  0442
6103  0443
6104  0444
6105  0445
6106  0446
6107  0447
6108  0448
6109  0449
6110  044A
6111  044B
6112  044C
6113  044D
6114  044E
6115  044F
6116  0450
6117  0451
6118  0452
6119  0453
6120  0454
6121  0455
6122  0456
6123  0457
6124  0458
6125  0459
6126  045A
6127  045B
6128  045C
6129  045D
6130  045E
6131  045F
6132  0460
6133  0461
6134  0462
6135  0463
6136  0464
6137  0465
6138  0466
6139  0467
6140  0468
6141  0469
6142  046A
6143  046B
6144  046C
6145  046D
6146  046E
6147  046F
6148  0470
6149  0471
6150  0472
6151  0473
6152  0474
6153  0475
6154  0476
6155  0477
6156  0478
6157  0479
6158  047A
6159  047B
6160  047C
6161  047D
6162  047E
6163  047F
6164  0480
6165  0481
6166  0482
6167  0483
6168  0484
6169  0485
6170  0486
6171  0487
6172  0488
6173  0489
6174  048A
6175  048B
6176  048C
6177  048D
6178  048E
6179  048F
6180  0490
6181  0491
6182  0492
6183  0493
6184  0494
6185  0495
6186  0496
6187  0497
6188  0498
6189  0499
6190  049A
6191  049B
6192  049C
6193  049D
6194  049E
6195  049F
6196  04A0
6197  04A1
6198  04A2
6199  04A3
6200  04A4
6201  04A5
6202  04A6
6203  04A7
6204  04A8
6205  04A9
6206  04AA
6207  04AB
6208  04AC
6209  04AD
6210  04AE
6211  04AF
6212  04B0
6213  04B1
6214  04B2
6215  04B3
6216  04B4
6217  04B5
6218  04B6
6219  04B7
6220  04B8
6221  04B9
6222  04BA
6223  04BB
6224  04BC
6225  04BD
6226  04BE
6227  04BF
6228  04C0
6229  04C1
6230  04C2
6231  04C3
6232  04C4
6233  04C5
6234  04C6
6235  04C7
6236  04C8
6237  04C9
6238  04CA
6239  04CB
6240  04CC
6241  04CD
6242  04CE
6243  04CF
6244  04D0
6245  04D1
6246  04D2
6247  04D3
6248  04D4
6249  04D5
6250  04D6
6251  04D7
6252  04D8
6253  04D9
6254  04DA
6255  04DB
6256  04DC
6257  04DD
6258  04DE
6259  04DF
6260  04E0
6261  04E1
6262  04E2
6263  04E3
6264  04E4
6265  04E5
6266  04E6
6267  04E7
6268  04E8
6269  04E9
6270  04EA
6271  04EB
6272  04EC
6273  04ED
6274  04EE
6275  04EF
6276  04F0
6277  04F1
6278  04F2
6279  04F3
6280  04F4
6281  04F5
6282  04F6
6283  04F7
6284  04F8
6285  04F9
6286  04FA
6287  04FB
6288  04FC
6289  04FD
6290  04FE
6291  04FF
6292  0500
6293  0501
6294  0502
6295  0503
6296  0504
6297  0505
6298  0506
6299  0507
6300  0508
6301  0509
6302  050A
6303  050B
6304  050C
6305  050D
6306  050E
6307  050F
6308  0510
6309  0511
6310  0512
6311  0513
6312  0514
6313  0515
6314  0516
6315  0517
6316  0518
6317  0519
6318  051A
6319  051B
6320  051C
6321  051D
6322  051E
6323  051F
6324  0520
6325  0521
6326  0522
6327  0523
6328  0524
6329  0525
6330  0526
6331  0527
6332  0528
6333  0529
6334  052A
6335  052B
6336  052C
6337  052D
6338  052E
6339  052F
6340  0530
6341  0531
6342  0532
6343  0533
6344  0534
6345  0535
6346  0536
6347  0537
6348  0538
6349  0539
6350  053A
6351  053B
6352  053C
6353  053D
6354  053E
6355  053F
6356  0540
6357  0541
6358  0542
6359  0543
6360  0544
6361  0545
6362  0546
6363  0547
6364  0548
6365  0549
6366  054A
6367  054B
6368  054C
6369  054D
6370  054E
6371  054F
6372  0550
6373  0551
6374  0552
6375  0553
6376  0554
6377  0555
6378  0556
6379  0557
6380  0558
6381  0559
6382  055A
6383  055B
6384  055C
6385  055D
6386  055E
6387  055F
6388  0560
6389  0561
6390  0562
6391  0563
6392  0564
6393  0565
6394  0566
6395  0567
6396  0568
6397  0569
6398  056A
6399  056B
6400  056C
6401  056D
6402  056E
6403  056F
6404  0570
6405  0571
6406  0572
6407  0573
6408  0574
6409  0575
6410  0576
6411  0577
6412  0578
6413  0579
6414  057A
6415  057B
6416  057C
6417  057D
6418  057E
6419  057F
6420  0580
6421  0581
6422  0582
6423  0583
6424  0584
6425  0585
6426  0586
6427  0587
6428  0588
6429  0589
6430  058A
6431  058B
6432  058C
6433  058D
6434  058E
6435  058F
6436  0590
6437  0591
6438  0592
6439  0593
6440  0594
6441  0595
6442  0596
6443  0597
6444  0598
6445  0599
6446  059A
6447  059B
6448  059C
6449  059D
6450  059E
6451  059F
6452  05A0
6453  05A1
6454  05A2
6455  05A3
6456  05A4
6457  05A5
6458  05A6
6459  05A7
6460  05A8
6461  05A9
6462  05AA
6463  05AB
6464  05AC
6465  05AD
6466  05AE
6467  05AF
6468  05B0
6469  05B1
6470  05B2
6471  05B3
6472  05B4
6473  05B5
6474  05B6
6475  05B7
6476  05B8
6477  05B9
6478  05BA
6479  05BB
6480  05BC
6481  05BD
6482  05BE
6483  05BF
6484  05C0
6485  05C1
6486  05C2
6487  05C3
6488  05C4
6489  05C5
6490  05C6
6491  05C7
6492  05C8
6493  05C9
6494  05CA
6495  05CB
6496  05CC
6497  05CD
6498  05CE
6499  05CF
6500  05D0
6501  05D1
6502  05D2
6503  05D3
6504  05D4
6505  05D5
6506  05D6
6507  05D7
6508  05D8
6509  05D9
6510  05DA
6511  05DB
6512  05DC
6513  05DD
6514  05DE
6515  05DF
6516  05E0
6517  05E1
6518  05E2
6519  05E3
6520  05E4
6521  05E5
6522  05E6
6523  05E7
6524  05E8
6525  05E9
6526  05EA
6527  05EB
6528  05EC
6529  05ED
6530  05EE
6531  05EF
6532  05F0
6533  05F1
6534  05F2
6535  05F3
6536  05F4
6537  05F5
6538  05F6
6539  05F7
6540  05F8
6541  05F9
6542  05FA
6543  05FB
6544  05FC
6545  05FD
6546  05FE
6547  05FF
6548  0600
6549  0601
6550  0602
6551  0603
6552  0604
6553  0605
6554  0606
6555  0607
6556  0608
6557  0609
6558  060A
6559  060B
6560  060C
6561  060D
6562  060E
6563  060F
6564  0610
6565  0611
6566  0612
6567  0613
6568  0614
6569  0615
6570  0616
6571  0617
6572  0618
6573  0619
6574  061A
6575  061B
6576  061C
6577  061D
6578  061E
6579  061F
6580  0620
6581  0621
6582  0622
6583  0623
6584  0624
6585  0625
6586  0626
6587  0627
6588  0628
6589  0629
6590  062A
6591  062B
6592  062C
6593  062D
6594  062E
6595  062F
6596  0630
6597  0631
6598  0632
6599  0633
6600  0634
6601  0635
6602  0636
6603  0637
6604  0638
6605  0639
6606  063A
6607  063B
6608  063C
6609  063D
6610  063E
6611  063F
6612  0640
6613  0641
6614  0642
6615  0643
6616  0644
6617  0645
006618  000220        
006619  000221      var vIAngularMeter0[WIDGET_RAM_SPACE] ;
006620  000222      var vILedDigits0[WIDGET_RAM_SPACE+2] ;
006621  000223      var vIAngularMeter1[WIDGET_RAM_SPACE] ;
006622  000224      var vILedDigits1[WIDGET_RAM_SPACE+2] ;
006623  000225      var vIAngularMeter2[WIDGET_RAM_SPACE] ;
006624  000226      var vILedDigits2[WIDGET_RAM_SPACE+2] ;
006625  000227      var vIAngularMeter3[WIDGET_RAM_SPACE] ;
006626  000228      var vILedDigits3[WIDGET_RAM_SPACE+2] ;
006627  000229  // Start P2.inc
006628  000230  var vObjects[MaxIntObjects+1] ;              // address of RAM objects
006629  000231  var GObjectIdx, GObjectFunc, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings ;
006630  000232  var oObjects[MaxTotObjects+1] ;                 // address of objects
006631  000233  var CurrentForm, oldn, ImageTouched ;
006632  000234  var TouchXpos, TouchYpos ;
006633  000235  var GObjectType, TouchState, CurInputData, pInputIndex ;
006634  000236  var comRX[40], cmd[CMDLenMAX] ;
006635  000237        
006636  000238  var InputCS, OutputCS ;
006637  000239        
006638  000240  // > ? Constant/Global/Data ? <
006639  000241        
006640  000242        
006641  000243  func addressInternalWidget(var idx var iponly)
006642  000244      var i, j ;
006643  000245  //to(COM0) ; print("Address Int ", idx, " ") ;
006644  000246      GObjectIdx := xobj2iobj[idx] ;
006645  000247      GObjectType := (GObjectIdx>>8) ;                          // extract object type
006646  000248      i := oObjects[GObjectType] ;                              // i is address of list of all objects of this type
006647  000249      GObjectIdx &= 0xff ;
006648  000250      //GObjectIdx *= 2 ;
006649  000251      j := GObjectIdx * 2 ;
006650  000252      GObjectDATA := i[j + 2] ;                                 // address of this object
006651  000253      i := vObjects[GObjectType-tiAngularMeter] ;               // i is address of list of all ram objects of his type
006652  000254      GObjectRAM := i[j] ;                                      // address of this objects' ram
006653  000255      i := GObjectType-tiAngularMeter ;
006654  000256      GObjectFunc := gfxInternals[i] ; // address function
006655  000257      GObjectParms := gfxIntParms[i] ;
006656  000258      GObjectStrings := gfxIntStrings[i] ;
006657  000259  //to(COM0) ; print([HEX4] GObjectFunc, " ", [HEX4] GObjectRAM, " ", [HEX4] GObjectDATA, " ", GObjectType, " ", GObjectIdx, "\r\n") ;
006658  000260  //    GObjectFunc(0, GObjectRAM, GObjectDATA) ;
006659  000261  endfunc
006660  000262        
006661  000263  func seroutCS(var op)
006662  000264      serout(op) ;
006663  000265      OutputCS ^= op ;
006664  000266  endfunc
006665  000267        
006666  000268  func nak0()
006667  000269      serout(NAK) ;
006668  000270      InputCS := 0 ;
006669  000271  endfunc
006670  000272        
006671  000273  func seroutOcs()
006672  000274      serout(OutputCS) ;
006673  000275      OutputCS := 0 ;
006674  000276  endfunc
006675  000277        
006676  000278  func SendReport(var id, var objt, var objn, var val)
006677  000279      seroutCS(id) ;
006678  000280      seroutCS(objt) ;
006679  000281      seroutCS(objn) ;
006680  000282      seroutCS(val >> 8) ; // first 8 bits
006681  000283      seroutCS(val) ;
006682  000284      seroutOcs() ;
006683  000285  endfunc
006684  000286        
006685  000287        
006686  000288        
006687  000289  func ReadObject(var ObjectType, var ObjectIdx)
006688  000290      var j, k, Objects ;
006689  000291      if ((ObjectType >= tiLedDigitsH) && (ObjectType <= tiLinearInput))
006690  000292          j := ObjectIdx *2 ;
006691  000293          k := vObjects[ObjectType-tiAngularMeter] ;               // k is address of list of all ram objects of his type
006692  000294          k := k[j] ;                                              // k is address of this objects' ram
006693  000295          if (ObjectType == tiLedDigit)
006694  000296              k := k[0] ;
006695  000297          else 
006696  000298              k := k[WIDGET_VAL1] ;
006697  000299          endif
006698  000300  //gfx_MoveTo(0,0); txt_Opacity(OPAQUE) ; print(ObjectType, " ", ObjectIdx, " ", k," ") ;
006699  000301      else
006700  000302      Objects := *(oObjects+ObjectType) ;
006701  000303        
006702  000304      j := 2 + ObjectIdx * 2 + Objects ;
006703  000305       if (ObjectType == tForm)
006704  000306          k := CurrentForm ;
006705  000307          else
006706  000308          k := img_GetWord(hndl, *j, IMAGE_INDEX);
006707  000309      endif
006708  000310      endif
006709  000311      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
006710  000312  endfunc
006711  000313        
006712  000314  var wp ;
006713  000315        
006714  000316        
006715  000317  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
006716  000318      var i, j, k, Objects ;
006717  000319  //    ObjectType &= 0x3f ; Why was his there? Anibuttons? Complex cascades?
006718  000320  //to(COM0) ; print("WriteObject ", ObjectType, " ", ObjectIdx, " ", NewVal, "\r\n") ;
006719  000321      if (ObjectType == tForm)
006720  000322          ActivateForm(ObjectIdx) ;
006721  000323          return ;
006722  000324      endif
006723  000325          Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
006724  000326          i := *(Objects) ;
006725  000327  	if ((ObjectType >= tiAngularMeter) && (ObjectType <= tiLinearInput))
006726  000328              i := oObjects[ObjectType] ;                              // f is address of list of all objects of this type
006727  000329              j := ObjectIdx *2 ;
006728  000330              i := i[j + 2] ;                         // f is address of this object
006729  000331              k := vObjects[ObjectType-tiAngularMeter] ;               // a is address of list of all ram objects of his type
006730  000332              k := k[j] ;                             // a is address of this objects' ram
006731  000333                  j := ObjectType-tiAngularMeter ;
006732  000334                  Objects := gfxInternals[j] ;           // locate function address   
006733  000335              Objects(NewVal, k, i) ; 
006734  000336          return ;
006735  000337      endif
006736  000338              img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
006737  000339              img_Show(hndl, i) ; // will only display if form is current
006738  000340      return ; // compiler bug circumvention!
006739  000341  endfunc
006740  000342        
006741  000343        
006742  000344        
006743  000345        
006744  000346        
006745  000347  func ActivateForm(var newform)
006746  000348      var i, j, *p ;
006747  000349        
006748  000350          widget_Disable(wp, ALL) ;
006749  000351      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
006750  000352          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
006751  000353              if (img_GetWord(hndl, i, IMAGE_TAG))
006752  000354                  img_Disable(hndl,i) ;
006753  000355              endif
006754  000356          next
006755  000357      endif
006756  000358      CurrentForm := newform ;
006757  000359      // display newform image or clear to image color
006758  000360      if (FormBGcolors[CurrentForm] != ColorBGimage)
006759  000361          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
006760  000362          gfx_Cls() ;
006761  000363          DoGFXObjects() ;                                    // display GFX 'widgets'
006762  000364      endif
006763  000365        
006764  000366      // enable inputs
006765  000367      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
006766  000368          j := img_GetWord(hndl, i, IMAGE_TAG) ;
006767  000369          if (j)
006768  000370              j-- ;
006769  000371              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
006770  000372              //if (j != tKeyboard)
006771  000373              if (((j <= tWinButton) || (j >= t4Dbutton)) && (j != tSmartGauge) )               // enable inputs
006772  000374                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
006773  000375              endif
006774  000376              img_Show(hndl,i) ; // show initialy, if required
006775  000377              if (j == tForm)
006776  000378                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
006777  000379              endif
006778  000380          endif
006779  000381      next
006780  000382        
006781  000383      // enable inputs
006782  000384         var a, f ; 
006783  000395  */
006784  000396      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
006785  000397          addressInternalWidget(i, 0) ;
006786  000398          widget_Enable(wp,i) ;
006787  000399          if (GObjectType != tiLabelB) widget_ClearAttributes(wp,i,WIDGET_F_INITIALISED) ; // don't clear initialised for tiLabelB
006788  000400                  j := GObjectRAM[WIDGET_VAL1] ;
006789  000401                  GObjectFunc(j, GObjectRAM, GObjectDATA) ; 
006790  000402      next
006791  000403      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
006792  000404          if (InternalInputControls[i] != -1)
006793  000405              widget_SetAttributes(wp,i,WIDGET_F_TOUCH_ENABLE) ;
006794  000406          endif
006795  000407      next
006796  000408        
006797  000409        
006798  000410  endfunc
006799  000411        
006800  000412  func UpdateObjects(var newval)
006801  000413      var IPidx, otherOBJ, oldvalue ;
006802  000414      if (GObjectType < tiLedDigitsH)
006803  000415          oldvalue := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ;
006804  000416      else
006805  000417          oldvalue := GObjectRAM[WIDGET_VAL1] ;
006806  000418      endif
006807  000419      if ( ( oldvalue != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
006808  000420      if (GObjectType < tiLedDigitsH)
006809  000421          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
006810  000422              img_Show(hndl, *(pInputIndex));      // only shows on current form
006811  000423      else
006812  000424          WriteObject(GObjectType, GObjectIdx, newval) ;
006813  000425      endif
006814  000426          IPidx := *(CurInputData+TouchState) ;
006815  000427          while(IPidx != 0)
006816  000428              otherOBJ := IPidx + InputData;
006817  000429              if (*(otherOBJ) == OT_REPORT)
006818  000430          SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
006819  000431              else if (*(otherOBJ) == OT_MAGIC)
006820  000432                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
006821  000433                  IPidx(newval) ;
006822  000434  //            else if (TouchState == *(otherOBJ+Ofs_IPD_P4))  // test prior to Workshop 6.5.0.0
006823  000435              else if ((TouchState == *(otherOBJ+Ofs_IPD_P4)) || (*(CurInputData+Ofs_IPD_P1) && ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))))
006824  000436                  if (*(otherOBJ) == OT_ACTIVATE)
006825  000437                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
006826  000438                      GObjectType := tForm ;
006827  000439                  else if (*(otherOBJ) == OT_SETCONST)
006828  000440                      newval := *(otherOBJ+Ofs_IPD_P3) ;
006829  000441                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
006830  000442                  else if (*(otherOBJ) == OT_SETANOTHER)
006831  000443                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
006832  000444                  else if (*(otherOBJ) == OT_PREVFRAME)
006833  000445                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
006834  000446                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
006835  000447                      endif
006836  000448                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
006837  000449                  else if (*(otherOBJ) == OT_NEXTFRAME)
006838  000450                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
006839  000451                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
006840  000452                      endif
006841  000453                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
006842  000454                  endif
006843  000455              endif
006844  000456              IPidx := *(otherOBJ+TouchState) ;
006845  000457          wend
006846  000458      endif
006847  000459  endfunc
006848  000460        
006849  000461  // End P2.inc
006850  000462  func DoGFXObjects()
006851  000463  endfunc
006852  000464        
006853  000465  // Start P3.inc
006854  000466  func main()
006855  000467      var comTX[50], cmdi, i, j, TouchStatus ;
006856  000468        
006857  000469        
006858  000470      gfx_ScreenMode(PORTRAIT) ;
006859  000471        
006860  000472      putstr("Mounting...\n");
006861  000473      if (!(file_Mount()))
006862  000474          while(!(file_Mount()))
006863  000475              putstr("Drive not mounted...");
006864  000476              pause(200);
006865  000477              gfx_Cls();
006866  000478              pause(200);
006867  000479          wend
006868  000480      endif
006869  000481        
006870  000482  //    gfx_MoveTo(0, 0);
006871  000483  //    print(mem_Heap()," ") ;
006872  000484  //    gfx_TransparentColour(0x0020);
006873  000485  //    gfx_Transparency(ON);
006874  000486        
006875  000487        
006876  000488      // open image control
006877  000489      hndl := file_LoadImageControl("VOLVOB~2.dat", "VOLVOB~2.gci", 1);
006878  000490        
006879  000491        
006880  000492      // init 'constants'
006881  000493  // End P3.inc
006882  000494        
006883  000495      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
006884  000496      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
006885  000497      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
006886  000498      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
006887  000499      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
006888  000500      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
006889  000501      oObjects[tWinButton] := oDipSwitchs ; // dummy as no object there
006890  000502      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
006891  000503      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
006892  000504      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
006893  000505      oObjects[tForm] := oForms ;
006894  000506      oObjects[tGauge] := oDipSwitchs ; // dummy as no object there
006895  000507      oObjects[tImage] := oDipSwitchs ; // dummy as no object there
006896  000508      oObjects[tKeyboard] := oDipSwitchs ; // dummy as no object there
006897  000509      oObjects[tLed] := oDipSwitchs ; // dummy as no object there
006898  000510      oObjects[tLeddigits] := oDipSwitchs ; // dummy as no object there
006899  000511      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
006900  000512      oObjects[tStrings] := oDipSwitchs ; // dummy as no object there
006901  000513      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
006902  000514      oObjects[tUserled] := oDipSwitchs ; // dummy as no object there
006903  000515      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
006904  000516      oObjects[tStaticText] := oStaticTexts ;
006905  000517      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
006906  000518      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
006907  000519      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
006908  000520      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
006909  000521      oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
006910  000522      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
006911  000523      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
006912  000524      oObjects[t4Dbutton] := oDipSwitchs ; // dummy as no object there
006913  000525      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
006914  000526      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
006915  000527      oObjects[tUserButton] := oDipSwitchs ; // dummy as no object there
006916  000528      oObjects[tMagicObject] := oDipSwitchs ; // dummy as no object there
006917  000529      oObjects[tSmartGauge] := oDipSwitchs ; // dummy as no object there
006918  000530      oObjects[tSmartSlider] := oDipSwitchs ; // dummy as no object there
006919  000531      oObjects[tSmartKnob] := oDipSwitchs ; // dummy as no object there
006920  000532      oObjects[tiLedDigitsH] := oDipSwitchs ; // dummy as no object there
006921  000533      oObjects[tiAngularMeter] := oiAngularMeters ;
006922  000534      oObjects[tiGauge] := oDipSwitchs ; // dummy as no object there
006923  000535      oObjects[tiLabelB] := oDipSwitchs ; // dummy as no object there
006924  000536      oObjects[tiUserGauge] := oDipSwitchs ; // dummy as no object there
006925  000537      oObjects[tiMediaGauge] := oDipSwitchs ; // dummy as no object there
006926  000538      oObjects[tiMediaThermometer] := oDipSwitchs ; // dummy as no object there
006927  000539      oObjects[tiLed] := oDipSwitchs ; // dummy as no object there
006928  000540      oObjects[tiMediaLed] := oDipSwitchs ; // dummy as no object there
006929  000541      oObjects[tiLedDigits] := oiLedDigitss ;
006930  000542      oObjects[tiNeedle] := oDipSwitchs ; // dummy as no object there
006931  000543      oObjects[tiRuler] := oDipSwitchs ; // dummy as no object there
006932  000544      oObjects[tiLedDigit] := oDipSwitchs ; // dummy as no object there
006933  000545      oObjects[tiButtonD] := oDipSwitchs ; // dummy as no object there
006934  000546      oObjects[tiButtonE] := oDipSwitchs ; // dummy as no object there
006935  000547      oObjects[tiMediaButton] := oDipSwitchs ; // dummy as no object there
006936  000548      oObjects[tiToggleInput] := oDipSwitchs ; // dummy as no object there
006937  000549      oObjects[tiDial] := oDipSwitchs ; // dummy as no object there
006938  000550      oObjects[tiMediaRotary] := oDipSwitchs ; // dummy as no object there
006939  000551      oObjects[tiRotaryInput] := oDipSwitchs ; // dummy as no object there
006940  000552      oObjects[tiSwitch] := oDipSwitchs ; // dummy as no object there
006941  000553      oObjects[tiSwitchB] := oDipSwitchs ; // dummy as no object there
006942  000554      oObjects[tiSliderE] := oDipSwitchs ; // dummy as no object there
006943  000555      oObjects[tiMediaSlider] := oDipSwitchs ; // dummy as no object there
006944  000556      oObjects[tiSliderH] := oDipSwitchs ; // dummy as no object there
006945  000557      oObjects[tiSliderG] := oDipSwitchs ; // dummy as no object there
006946  000558      oObjects[tiSliderF] := oDipSwitchs ; // dummy as no object there
006947  000559      oObjects[tiSliderD] := oDipSwitchs ; // dummy as no object there
006948  000560      oObjects[tiSliderC] := oDipSwitchs ; // dummy as no object there
006949  000561      oObjects[tiLinearInput] := oDipSwitchs ; // dummy as no object there
006950  000562      vObjects[0] := oiviAngularMeter ;
006951  000563      vObjects[8] := oiviLedDigits ;
006952  000564  // Start P4.inc
006953  000565      wp := widget_Create(8) ;
006954  000566      for (i := 0; i < 8; i++)
006955  000567  	addressInternalWidget(i, 0) ;
006956  000568          widget_Add(wp, i, GObjectRAM) ;
006957  000569  //        if (GObjectType == tiLabelB)			// code to cause 'early' allocation of 'buffer' storage in LabelB widgets
006958  000570  //            widget_Disable(wp, i) ;
006959  000571  //            img_FunctionCall(hndl, GObjectFunc, j, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings) ;
006960  000572  //        endif
006961  000573      next
006962  000574        
006963  000575      // init comms
006964  000576      com_Init(comRX,CMDLenMAX,0);
006965  000577      com_SetBaud(COM0,11520);
006966  000578      com_TXbuffer(comTX, 100, 0);
006967  000579      // tag 'real' objects
006968  000580      for (i := 0; i <= MaxTotObjects; i++)
006969  000581          if (   (i != tSounds)
006970  000582              && (i != tTimer)
006971  000583              && (i != tPinOutput)
006972  000584              && (i != tMagicObject)
006973  000585              && (i != tPinInput) )
006974  000586              TouchXpos := oObjects[i] ;
006975  000587              TouchYpos := *(TouchXpos) ;
006976  000588              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
006977  000589                  oldn := *(TouchXpos+ImageTouched*2) ;
006978  000590                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
006979  000591                  if (oldn != -1)
006980  000592                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
006981  000593                      img_Disable(hndl, oldn) ;
006982  000594                  endif
006983  000595              next
006984  000596          endif
006985  000597      next
006986  000598        
006987  000599        
006988  000600      // display initial form
006989  000601      CurrentForm := -1 ;
006990  000602  // End P4.inc
006991  000603  // Start P5.inc
006992  000604      ActivateForm(0) ; // need to change this according to first actual form
006993  000605        
006994  000606  // End P5.inc
006995  000607  // Start P6.inc Diablo
006996  000608      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
006997  000609      oldn := -1 ;
006998  000610      repeat
006999  000611        
007000  000612          // check comms for command, how to NAK invalid command
007001  000613          if (com_Count() != 0)
007002  000614              i := serin() ;
007003  000615              InputCS ^= i ;               // update checksum
007004  000616                  cmd[cmdi++] := i ;
007005  000617                   if (   (cmd[0] == READ_OBJ)
007006  000618                           && (cmdi == 4)         )
007007  000619                      if (InputCS)
007008  000620                          nak0() ;
007009  000621                      else
007010  000622                          ReadObject(cmd[1], cmd[2]) ;
007011  000623                      endif
007012  000624                      cmdi := 0 ;
007013  000625                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
007014  000626                           && (cmdi == 6)          )
007015  000627                      if (InputCS)
007016  000628                          nak0() ;
007017  000629                      else
007018  000630                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
007019  000631                          serout(ACK) ;
007020  000632                      endif
007021  000633                      cmdi := 0 ;
007022  000634                  else if (   (cmd[0] == WRITE_CONTRAST)
007023  000635                           && (cmdi == 3)         )
007024  000636                      if (InputCS)
007025  000637                          nak0() ;
007026  000638                      else
007027  000639                          gfx_Contrast(cmd[1]) ;
007028  000640                          serout(ACK) ;
007029  000641                      endif
007030  000642                      cmdi := 0 ;
007031  000643                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
007032  000644                      nak0() ;
007033  000645                      cmdi := 0 ;
007034  000646                  endif
007035  000647          endif   // a character is available
007036  000648        
007037  000649        
007038  000650      // touch code processing
007039  000651        
007040  000652          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
007041  000653          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
007042  000654              ImageTouched := img_Touched(hndl,-1) ;
007043  000655              if (ImageTouched == -1)
007044  000656                  ImageTouched := widget_Touched(wp, ALL) ;
007045  000657                  if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
007046  000658              endif
007047  000659              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
007048  000660                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
007049  000661              endif
007050  000662              if (TouchStatus != TOUCH_RELEASED)        // if not released
007051  000663                  if (oldn != -1)
007052  000664                      ImageTouched := oldn ;
007053  000665                  else
007054  000666                      if (oldn != ImageTouched)
007055  000667                  oldn := ImageTouched ;
007056  000668                          TouchStatus := TOUCH_PRESSED ;
007057  000669                      endif
007058  000670                  endif
007059  000671                  TouchXpos  := touch_Get(TOUCH_GETX);
007060  000672                  TouchYpos  := touch_Get(TOUCH_GETY);
007061  000673                  TouchState := Ofs_IPD_DOWN ;
007062  000674              else
007063  000675                  ImageTouched := oldn ;                     // simulate release of what we touched
007064  000676                  oldn := -1 ;                    // prevent double release
007065  000677                  TouchState := Ofs_IPD_RELEASE ;
007066  000678              endif
007067  000679              if (ImageTouched >= 0)
007068  000680                          CurInputData := InputControls[ImageTouched] + InputData;
007069  000681                          GObjectType := *(CurInputData) ;
007070  000682                          if (GObjectType == tSmartSlider)
007071  000683                              i := tTrackbar ; // GSlider ;
007072  000684                          else if (GObjectType == tSmartKnob)
007073  000685                              i := tKnob ;
007074  000686                          else if (GObjectType >= t4Dbutton) 
007075  000687                              i := GObjectType - 23 ; // adjust to ensure next in gosub
007076  000688                          else 
007077  000689                              i := GObjectType ;
007078  000690                          endif
007079  000691                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007080  000692                          ImageTouched := -1 ; // show processed here
007081  000693              endif
007082  000694              if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
007083  000695              if (ImageTouched >= 0)
007084  000696  //print(ImageTouched," ") ;
007085  000697  //                        CurInputData := InternalInputControls[ImageTouched] + InternalInputData;
007086  000698                          CurInputData := InternalInputControls[ImageTouched] + InputData;
007087  000699  //                        GObjectType := *(CurInputData) ;
007088  000700  //                        i := GObjectType ;
007089  000701  //                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
007090  000702  //                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007091  000703                          addressInternalWidget(ImageTouched, 0) ;
007092  000704  //                        i := xobj2iiobj[ImageTouched] ;                            // address object type and hash from ram index
007093  000705  //                        GObjectIdx := i & 0xff ;
007094  000706  //                        GObjectType := (i>>8) ;                                   // extract object type
007095  000707                          if (GObjectType <= tiToggleInput) 
007096  000708                              i := 0 ;
007097  000709                          else if (GObjectType <= tiRotaryInput) 
007098  000710                              i := 1 ;
007099  000711                          else if (GObjectType <= tiSwitchB) 
007100  000712                              i := 2 ;
007101  000713                          else 
007102  000714                              i := 3 ;
007103  000715                          endif
007104  000716  //to(COM0) ; print(i, "\r\n") ;  
007105  000717        
007106  000718                          gosub (i), (ciButton, ciDial, ciSwitch, ciSlider) ;
007107  000719        
007108  000720        
007109  000721  //            ImageTouched := widget_Touched(wp, ALL) ;
007110  000722              endif
007111  000723          endif
007112  000724   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
007113  000725        
007114  000726          sys_EventsResume() ;
007115  000727      forever
007116  000728        
007117  000729  ciSwitch:
007118  000730  cDipswitch:
007119  000731        
007120  000732  cKnob:
007121  000733  ciDial:
007122  000734        
007123  000735  cRockerswitch:
007124  000736        
007125  000737  cRotaryswitch:
007126  000738        
007127  000739  cSlider:
007128  000740  cTrackbar:
007129  000741  ciSlider:
007130  000742        
007131  000743  ciButton:
007132  000744        
007133  000745  c4DButton:
007134  000746  cUserButton:
007135  000747  cWinbutton:
007136  000748        
007137  000749  cAniButton:
007138  000750        
007139  000751  cColorPicker:
007140  000752        
007141  000753  endfunc
007142  000754  // End P6.inc
Notice: local var 'j' in func 'main' is never used (line 467 file:VolvoBoostGauge.4DGenieS)
Notice: no execution path to func 'UpdateObjects'
Notice: variable 'GObjectRAM' is being indexed (line 400 file:VolvoBoostGauge.4DGenieS)
Notice: Check that the function called via pointer  'GObjectFunc' requires 3 arguments (line 401 file:VolvoBoostGauge.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 348 file:VolvoBoostGauge.4DGenieS)
Notice: local var 'a' in func 'ActivateForm' is never used (line 384 file:VolvoBoostGauge.4DGenieS)
Notice: local var 'f' in func 'ActivateForm' is never used (line 384 file:VolvoBoostGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 330 file:VolvoBoostGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 332 file:VolvoBoostGauge.4DGenieS)
Notice: Check that the function called via pointer  'Objects' requires 3 arguments (line 335 file:VolvoBoostGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 294 file:VolvoBoostGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 296 file:VolvoBoostGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 298 file:VolvoBoostGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 252 file:VolvoBoostGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 254 file:VolvoBoostGauge.4DGenieS)
Notice: function argument 'iponly' in func 'addressInternalWidget' is never used (line 243 file:VolvoBoostGauge.4DGenieS)


Symbol Table:
name                             decimal         hex
__MAXBANKS                             6  0x00000006 (const dword)  (not used)
__MAXMEM                           32768  0x00008000 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             3  0x00000003 (const dword)  (not used)
__reserved10                        -111  0xffffff91 (PmmC func) args[0] r=0  (not used)
__reserved13                        -123  0xffffff85 (PmmC func) args[0] r=0  (not used)
__reserved14                        -124  0xffffff84 (PmmC func) args[0] r=0  (not used)
__reserved17                        -201  0xffffff37 (PmmC func) args[0] r=0  (not used)
__reserved18                        -202  0xffffff36 (PmmC func) args[0] r=0  (not used)
__reserved19                        -203  0xffffff35 (PmmC func) args[0] r=0  (not used)
__reserved20                        -204  0xffffff34 (PmmC func) args[0] r=0  (not used)
__reserved21                        -205  0xffffff33 (PmmC func) args[0] r=0  (not used)
__reserved22                        -206  0xffffff32 (PmmC func) args[0] r=0  (not used)
__reserved23                        -220  0xffffff24 (PmmC func) args[0] r=0  (not used)
__reserved24                        -221  0xffffff23 (PmmC func) args[0] r=0  (not used)
__reserved25                        -222  0xffffff22 (PmmC func) args[0] r=0  (not used)
__reserved26                        -223  0xffffff21 (PmmC func) args[0] r=0  (not used)
__reserved3                          -69  0xffffffbb (PmmC func) args[0] r=0  (not used)
__reserved30                        -283  0xfffffee5 (PmmC func) args[0] r=0  (not used)
__reserved4                          -70  0xffffffba (PmmC func) args[0] r=0  (not used)
__reserved42                        -373  0xfffffe8b (PmmC func) args[0] r=0  (not used)
__reserved43                        -387  0xfffffe7d (PmmC func) args[0] r=0  (not used)
__reserved44                        -388  0xfffffe7c (PmmC func) args[0] r=0  (not used)
__reserved45                        -389  0xfffffe7b (PmmC func) args[0] r=0  (not used)
__reserved46                        -390  0xfffffe7a (PmmC func) args[0] r=0  (not used)
__reserved5                          -76  0xffffffb4 (PmmC func) args[0] r=0  (not used)
__reserved51                        -411  0xfffffe65 (PmmC func) args[0] r=0  (not used)
__reserved52                        -412  0xfffffe64 (PmmC func) args[0] r=0  (not used)
__reserved53                        -422  0xfffffe5a (PmmC func) args[0] r=0  (not used)
__reserved54                        -423  0xfffffe59 (PmmC func) args[0] r=0  (not used)
__reserved57                        -457  0xfffffe37 (PmmC func) args[0] r=0  (not used)
__reserved58                        -458  0xfffffe36 (PmmC func) args[0] r=0  (not used)
__reserved6                          -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
__reserved60                        -467  0xfffffe2d (PmmC func) args[0] r=0  (not used)
__reserved61                        -468  0xfffffe2c (PmmC func) args[0] r=0  (not used)
__reserved62                        -469  0xfffffe2b (PmmC func) args[0] r=0  (not used)
__reserved63                        -490  0xfffffe16 (PmmC func) args[0] r=0  (not used)
__reserved64                        -491  0xfffffe15 (PmmC func) args[0] r=0  (not used)
__reserved65                        -492  0xfffffe14 (PmmC func) args[0] r=0  (not used)
__reserved66                        -493  0xfffffe13 (PmmC func) args[0] r=0  (not used)
__reserved68                        -509  0xfffffe03 (PmmC func) args[0] r=0  (not used)
__reserved69                        -510  0xfffffe02 (PmmC func) args[0] r=0  (not used)
__reserved70                        -511  0xfffffe01 (PmmC func) args[0] r=0  (not used)
__reserved72                        -520  0xfffffdf8 (PmmC func) args[0] r=0  (not used)
__reserved77                        -526  0xfffffdf2 (PmmC func) args[0] r=0  (not used)
__reserved78                        -527  0xfffffdf1 (PmmC func) args[0] r=0  (not used)
__reserved85                        -536  0xfffffde8 (PmmC func) args[0] r=0  (not used)
__reserved86                        -537  0xfffffde7 (PmmC func) args[0] r=0  (not used)
__reserved87                        -570  0xfffffdc6 (PmmC func) args[0] r=0  (not used)
__reserved88                        -571  0xfffffdc5 (PmmC func) args[0] r=0  (not used)
__reserved89                        -572  0xfffffdc4 (PmmC func) args[0] r=0  (not used)
__reserved9                         -110  0xffffff92 (PmmC func) args[0] r=0  (not used)
__translate                           -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
ABS                                  -53  0xffffffcb (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 6)
ActivateForm                        2525  0x000009dd (User func) args[1] r=0  (usage 8)
addressInternalWidget               3421  0x00000d5d (User func) args[2] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (usage 6)
ana_HS                              -533  0xfffffdeb (PmmC func) args[7] r=0  (not used)
ANGULAR_bgcol                         66  0x00000042 (const dword)  (not used)
ANGULAR_c1                            24  0x00000018 (const dword)  (not used)
ANGULAR_c2                            26  0x0000001a (const dword)  (not used)
ANGULAR_c3                            28  0x0000001c (const dword)  (not used)
ANGULAR_capcol                        46  0x0000002e (const dword)  (not used)
ANGULAR_capfnt                        44  0x0000002c (const dword)  (not used)
ANGULAR_capofsx                       48  0x00000030 (const dword)  (not used)
ANGULAR_capofsy                       50  0x00000032 (const dword)  (not used)
ANGULAR_Caption                       52  0x00000034 (const dword)  (not used)
ANGULAR_cxx                           62  0x0000003e (const dword)  (not used)
ANGULAR_cyx                           64  0x00000040 (const dword)  (not used)
ANGULAR_F_BG_TRANSPARENT             N/A         N/A (macro)   0x0002   (not used)
ANGULAR_F_LABEL_STRINGS              N/A         N/A (macro)   0x0001   (not used)
ANGULAR_F_TEXT_PCT_COLOUR            N/A         N/A (macro)   0x0008   (not used)
ANGULAR_F_TICK_PCT_COLOUR            N/A         N/A (macro)   0x0004   (not used)
ANGULAR_flags                         42  0x0000002a (const dword)  (not used)
ANGULAR_h                             60  0x0000003c (const dword)  (not used)
ANGULAR_incro                         30  0x0000001e (const dword)  (not used)
ANGULAR_labcol                        36  0x00000024 (const dword)  (not used)
ANGULAR_labfnt                        34  0x00000022 (const dword)  (not used)
ANGULAR_labofs                        38  0x00000026 (const dword)  (not used)
ANGULAR_labs                          32  0x00000020 (const dword)  (not used)
ANGULAR_labstr                        40  0x00000028 (const dword)  (not used)
ANGULAR_maxa                          70  0x00000046 (const dword)  (not used)
ANGULAR_maxv                          74  0x0000004a (const dword)  (not used)
ANGULAR_mina                          68  0x00000044 (const dword)  (not used)
ANGULAR_minv                          72  0x00000048 (const dword)  (not used)
ANGULAR_p1                            20  0x00000014 (const dword)  (not used)
ANGULAR_p2                            22  0x00000016 (const dword)  (not used)
ANGULAR_ri                             2  0x00000002 (const dword)  (not used)
ANGULAR_ro                             0  0x00000000 (const dword)  (not used)
ANGULAR_tc                            18  0x00000012 (const dword)  (not used)
ANGULAR_tcks                           4  0x00000004 (const dword)  (not used)
ANGULAR_tiszl                         12  0x0000000c (const dword)  (not used)
ANGULAR_tiszs                         14  0x0000000e (const dword)  (not used)
ANGULAR_tkl                            6  0x00000006 (const dword)  (not used)
ANGULAR_toszl                          8  0x00000008 (const dword)  (not used)
ANGULAR_toszs                         10  0x0000000a (const dword)  (not used)
ANGULAR_tw                            16  0x00000010 (const dword)  (not used)
ANGULAR_w                             58  0x0000003a (const dword)  (not used)
ANGULAR_x                             54  0x00000036 (const dword)  (not used)
ANGULAR_y                             56  0x00000038 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                          17  0x00000011 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_RADIUS                          27  0x0000001b (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 12)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BREAK                              65533  0x0000fffd (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
bus_ClearPins                       -119  0xffffff89 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                            -117  0xffffff8b (PmmC func) args[0] r=1  (not used)
bus_Read8                           -122  0xffffff86 (PmmC func) args[0] r=1  (not used)
bus_SetChangeInterrupt              -120  0xffffff88 (PmmC func) args[2] r=1  (not used)
bus_SetPins                         -118  0xffffff8a (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             3  0x00000003 (const dword)  (not used)
bus_Write8                          -121  0xffffff87 (PmmC func) args[1] r=0  (not used)
BUTTON4_BC0                           12  0x0000000c (const dword)  (not used)
BUTTON4_BC1                           14  0x0000000e (const dword)  (not used)
BUTTON4_BR1                           28  0x0000001c (const dword)  (not used)
BUTTON4_BR2                           30  0x0000001e (const dword)  (not used)
BUTTON4_BRG                           32  0x00000020 (const dword)  (not used)
BUTTON4_CAP                           26  0x0000001a (const dword)  (not used)
BUTTON4_FC0                           28  0x0000001c (const dword)  (not used)
BUTTON4_FC1                           30  0x0000001e (const dword)  (not used)
BUTTON4_FST                           32  0x00000020 (const dword)  (not used)
BUTTON4_FSZ                           34  0x00000022 (const dword)  (not used)
BUTTON4_IB1                           16  0x00000010 (const dword)  (not used)
BUTTON4_IB2                           18  0x00000012 (const dword)  (not used)
BUTTON4_IG0                           20  0x00000014 (const dword)  (not used)
BUTTON4_IG1                           22  0x00000016 (const dword)  (not used)
BUTTON4_OB1                            6  0x00000006 (const dword)  (not used)
BUTTON4_OB2                            8  0x00000008 (const dword)  (not used)
BUTTON4_OBG                           10  0x0000000a (const dword)  (not used)
BUTTON4_rad                            4  0x00000004 (const dword)  (not used)
BUTTON4_TPC                           24  0x00000018 (const dword)  (not used)
BUTTON4_XP                             0  0x00000000 (const dword)  (not used)
BUTTON4_YP                             2  0x00000002 (const dword)  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                             -49  0xffffffcf (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                           -12  0xfffffff4 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                            -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
CHECKED                                0  0x00000000 (const dword)  (not used)
CHECKUPDATE_INVALIDFILE                5  0x00000005 (const dword)  (not used)
CHECKUPDATE_NEWFILE                    1  0x00000001 (const dword)  (not used)
CHECKUPDATE_NOFILE                     4  0x00000004 (const dword)  (not used)
CHECKUPDATE_OLDFILE                    2  0x00000002 (const dword)  (not used)
CHECKUPDATE_QUERY                      1  0x00000001 (const dword)  (not used)
CHECKUPDATE_UPDATEALWAYS               3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATEDONE                 3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATENEWER                2  0x00000002 (const dword)  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
ciButton                          UNRESOLVED  (not used)
ciDial                            UNRESOLVED  (not used)
ciSlider                          UNRESOLVED  (not used)
ciSwitch                          UNRESOLVED  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  480  0x000001e0 (mem) word[80] (global)  (usage 33)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 6)
ColorBGimage                          32  0x00000020 (const dword)  (usage 3)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63493  0x0000f805 (const dword)  (not used)
com1_Count                          -249  0xffffff07 (PmmC func) args[0] r=1  (not used)
com1_Error                          -257  0xfffffeff (PmmC func) args[0] r=1  (not used)
com1_Full                           -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
com1_Init                           -233  0xffffff17 (PmmC func) args[3] r=0  (not used)
com1_InitBrk                        -578  0xfffffdbe (PmmC func) args[3] r=0  (not used)
com1_Reset                          -245  0xffffff0b (PmmC func) args[0] r=0  (not used)
COM1_RX_pin                         -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
com1_RXblock                        -558  0xfffffdd2 (PmmC func) args[2] r=0  (not used)
com1_Sync                           -261  0xfffffefb (PmmC func) args[0] r=1  (not used)
COM1_TX_pin                         -229  0xffffff1b (PmmC func) args[1] r=1  (not used)
com1_TXblock                        -557  0xfffffdd3 (PmmC func) args[2] r=0  (not used)
com1_TXbuffer                       -265  0xfffffef7 (PmmC func) args[3] r=0  (not used)
com1_TXbufferBrk                    -574  0xfffffdc2 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -277  0xfffffeeb (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -269  0xfffffef3 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -273  0xfffffeef (PmmC func) args[1] r=1  (not used)
COM2                               63494  0x0000f806 (const dword)  (not used)
com2_Count                          -250  0xffffff06 (PmmC func) args[0] r=1  (not used)
com2_Error                          -258  0xfffffefe (PmmC func) args[0] r=1  (not used)
com2_Full                           -254  0xffffff02 (PmmC func) args[0] r=1  (not used)
com2_Init                           -234  0xffffff16 (PmmC func) args[3] r=0  (not used)
com2_InitBrk                        -579  0xfffffdbd (PmmC func) args[3] r=0  (not used)
com2_Reset                          -246  0xffffff0a (PmmC func) args[0] r=0  (not used)
COM2_RX_pin                         -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
com2_RXblock                        -560  0xfffffdd0 (PmmC func) args[2] r=0  (not used)
com2_Sync                           -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
COM2_TX_pin                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
com2_TXblock                        -559  0xfffffdd1 (PmmC func) args[2] r=0  (not used)
com2_TXbuffer                       -266  0xfffffef6 (PmmC func) args[3] r=0  (not used)
com2_TXbufferBrk                    -575  0xfffffdc1 (PmmC func) args[3] r=0  (not used)
com2_TXbufferHold                   -278  0xfffffeea (PmmC func) args[1] r=1  (not used)
com2_TXcount                        -270  0xfffffef2 (PmmC func) args[0] r=1  (not used)
com2_TXemptyEvent                   -274  0xfffffeee (PmmC func) args[1] r=1  (not used)
COM3                               63495  0x0000f807 (const dword)  (not used)
com3_Count                          -251  0xffffff05 (PmmC func) args[0] r=1  (not used)
com3_Error                          -259  0xfffffefd (PmmC func) args[0] r=1  (not used)
com3_Full                           -255  0xffffff01 (PmmC func) args[0] r=1  (not used)
com3_Init                           -235  0xffffff15 (PmmC func) args[3] r=0  (not used)
com3_InitBrk                        -580  0xfffffdbc (PmmC func) args[3] r=0  (not used)
com3_Reset                          -247  0xffffff09 (PmmC func) args[0] r=0  (not used)
COM3_RX_pin                         -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
com3_RXblock                        -562  0xfffffdce (PmmC func) args[2] r=0  (not used)
com3_Sync                           -263  0xfffffef9 (PmmC func) args[0] r=1  (not used)
COM3_TX_pin                         -231  0xffffff19 (PmmC func) args[1] r=1  (not used)
com3_TXblock                        -561  0xfffffdcf (PmmC func) args[2] r=0  (not used)
com3_TXbuffer                       -267  0xfffffef5 (PmmC func) args[3] r=0  (not used)
com3_TXbufferBrk                    -576  0xfffffdc0 (PmmC func) args[3] r=0  (not used)
com3_TXbufferHold                   -279  0xfffffee9 (PmmC func) args[1] r=1  (not used)
com3_TXcount                        -271  0xfffffef1 (PmmC func) args[0] r=1  (not used)
com3_TXemptyEvent                   -275  0xfffffeed (PmmC func) args[1] r=1  (not used)
com_Count                           -248  0xffffff08 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -256  0xffffff00 (PmmC func) args[0] r=1  (not used)
com_Full                            -252  0xffffff04 (PmmC func) args[0] r=1  (not used)
com_Init                            -232  0xffffff18 (PmmC func) args[3] r=0  (usage 3)
com_InitBrk                         -577  0xfffffdbf (PmmC func) args[3] r=0  (not used)
com_Mode                            -280  0xfffffee8 (PmmC func) args[4] r=1  (not used)
com_Reset                           -244  0xffffff0c (PmmC func) args[0] r=0  (not used)
com_RXblock                         -282  0xfffffee6 (PmmC func) args[2] r=0  (not used)
com_SetBaud                         -225  0xffffff1f (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -260  0xfffffefc (PmmC func) args[0] r=1  (not used)
com_TXblock                         -281  0xfffffee7 (PmmC func) args[2] r=0  (not used)
com_TXbuffer                        -264  0xfffffef8 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferBrk                     -573  0xfffffdc3 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
com_TXcount                         -268  0xfffffef4 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -272  0xfffffef0 (PmmC func) args[1] r=1  (not used)
comRX                                400  0x00000190 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -58  0xffffffc6 (PmmC func) args[1] r=1  (not used)
COUNT_EDGE                             3  0x00000003 (const dword)  (not used)
COUNT_FALL                             2  0x00000002 (const dword)  (not used)
COUNT_OFF                              0  0x00000000 (const dword)  (not used)
COUNT_RISE                             1  0x00000001 (const dword)  (not used)
crc_16                              -567  0xfffffdc9 (PmmC func) args[2] r=1  (not used)
crc_CCITT                           -569  0xfffffdc7 (PmmC func) args[3] r=1  (not used)
crc_CSUM_8                          -566  0xfffffdca (PmmC func) args[2] r=1  (not used)
crc_MODBUS                          -568  0xfffffdc8 (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         396  0x0000018c (mem) word (global)  (usage 13)
CurrentForm                          382  0x0000017e (mem) word (global)  (usage 42)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                   -64  0xffffffc0 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEBUG_MODE                            64  0x00000040 (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIABLO                                 3  0x00000003 (const dword)  (usage 3)
DIAL_bevColour                        28  0x0000001c (const dword)  (not used)
DIAL_bevColour2                       30  0x0000001e (const dword)  (not used)
DIAL_bevSize                          26  0x0000001a (const dword)  (not used)
DIAL_bgcolour                         22  0x00000016 (const dword)  (not used)
DIAL_capcol                           72  0x00000048 (const dword)  (not used)
DIAL_capfnt                           70  0x00000046 (const dword)  (not used)
DIAL_capofsx                          74  0x0000004a (const dword)  (not used)
DIAL_capofsy                          76  0x0000004c (const dword)  (not used)
DIAL_caption                          78  0x0000004e (const dword)  (not used)
DIAL_colour                           24  0x00000018 (const dword)  (not used)
DIAL_cx                                8  0x00000008 (const dword)  (not used)
DIAL_cy                               10  0x0000000a (const dword)  (not used)
DIAL_F_BG_TRANSPARENT                N/A         N/A (macro)   0x0002   (not used)
DIAL_F_HANDLE_CIRCLE                 N/A         N/A (macro)   0x0000   (not used)
DIAL_F_HANDLE_LINE                   N/A         N/A (macro)   0x0030   (not used)
DIAL_F_HANDLE_RECTANGLE              N/A         N/A (macro)   0x0020   (not used)
DIAL_F_HANDLE_STYLE                  N/A         N/A (macro)   0x00f0   (not used)
DIAL_F_HANDLE_TRIANGLE               N/A         N/A (macro)   0x0010   (not used)
DIAL_F_INDICATOR_CIRCLE              N/A         N/A (macro)   0x0000   (not used)
DIAL_F_INDICATOR_LINE                N/A         N/A (macro)   0x0300   (not used)
DIAL_F_INDICATOR_RECTANGLE           N/A         N/A (macro)   0x0200   (not used)
DIAL_F_INDICATOR_STYLE               N/A         N/A (macro)   0x0f00   (not used)
DIAL_F_INDICATOR_TRIANGLE            N/A         N/A (macro)   0x0100   (not used)
DIAL_F_LABEL_STRINGS                 N/A         N/A (macro)   0x0001   (not used)
DIAL_flags                            80  0x00000050 (const dword)  (not used)
DIAL_h                                 6  0x00000006 (const dword)  (not used)
DIAL_handlecolour                     54  0x00000036 (const dword)  (not used)
DIAL_handlelength                     58  0x0000003a (const dword)  (not used)
DIAL_handlesize                       56  0x00000038 (const dword)  (not used)
DIAL_indc1h                           42  0x0000002a (const dword)  (not used)
DIAL_indc1l                           36  0x00000024 (const dword)  (not used)
DIAL_indc2h                           44  0x0000002c (const dword)  (not used)
DIAL_indc2l                           38  0x00000026 (const dword)  (not used)
DIAL_indc3h                           46  0x0000002e (const dword)  (not used)
DIAL_indc3l                           40  0x00000028 (const dword)  (not used)
DIAL_indlength                        52  0x00000034 (const dword)  (not used)
DIAL_indOffset                        48  0x00000030 (const dword)  (not used)
DIAL_indp1                            32  0x00000020 (const dword)  (not used)
DIAL_indp2                            34  0x00000022 (const dword)  (not used)
DIAL_indsize                          50  0x00000032 (const dword)  (not used)
DIAL_labcolour                        60  0x0000003c (const dword)  (not used)
DIAL_labcount                         66  0x00000042 (const dword)  (not used)
DIAL_labfont                          62  0x0000003e (const dword)  (not used)
DIAL_labofs                           64  0x00000040 (const dword)  (not used)
DIAL_labstr                           68  0x00000044 (const dword)  (not used)
DIAL_maxa                             16  0x00000010 (const dword)  (not used)
DIAL_maxv                             20  0x00000014 (const dword)  (not used)
DIAL_mina                             14  0x0000000e (const dword)  (not used)
DIAL_minv                             18  0x00000012 (const dword)  (not used)
DIAL_rad                              12  0x0000000c (const dword)  (not used)
DIAL_w                                 4  0x00000004 (const dword)  (not used)
DIAL_x                                 0  0x00000000 (const dword)  (not used)
DIAL_y                                 2  0x00000002 (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_BlitPixelsFromCOM0             -372  0xfffffe8c (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM1             -563  0xfffffdcd (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM2             -564  0xfffffdcc (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM3             -565  0xfffffdcb (PmmC func) args[0] r=0  (not used)
disp_Disconnect                     -371  0xfffffe8d (PmmC func) args[0] r=0  (not used)
disp_Init                           -370  0xfffffe8e (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -367  0xfffffe91 (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -363  0xfffffe95 (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -362  0xfffffe96 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -369  0xfffffe8f (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -364  0xfffffe94 (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -365  0xfffffe93 (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -366  0xfffffe92 (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        2524  0x000009dc (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                               -65  0xffffffbf (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                            -66  0xffffffbe (PmmC func) args[0] r=1  (not used)
EXTERN                               N/A         N/A (macro)  /**/   (not used)
FALSE_REASON                         141  0x0000008d (const dword)  (not used)
FCY_1                                 20  0x00000014 (const dword)  (not used)
FCY_256                               23  0x00000017 (const dword)  (not used)
FCY_64                                22  0x00000016 (const dword)  (not used)
FCY_8                                 21  0x00000015 (const dword)  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_CheckUpdate                    -607  0xfffffda1 (PmmC func) args[2] r=1  (not used)
file_Close                          -431  0xfffffe51 (PmmC func) args[1] r=1  (not used)
file_Count                          -425  0xfffffe57 (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -426  0xfffffe56 (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -446  0xfffffe42 (PmmC func) args[1] r=1  (not used)
file_Error                          -424  0xfffffe58 (PmmC func) args[0] r=1  (not used)
file_Exec                           -450  0xfffffe3e (PmmC func) args[2] r=1  (not used)
file_Exists                         -429  0xfffffe53 (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -427  0xfffffe55 (PmmC func) args[1] r=1  (not used)
file_FindNext                       -428  0xfffffe54 (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -441  0xfffffe47 (PmmC func) args[1] r=1  (not used)
file_GetS                           -445  0xfffffe43 (PmmC func) args[3] r=1  (not used)
file_GetW                           -443  0xfffffe45 (PmmC func) args[1] r=1  (not used)
file_Image                          -438  0xfffffe4a (PmmC func) args[3] r=1  (not used)
file_Index                          -434  0xfffffe4e (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -448  0xfffffe40 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -451  0xfffffe3d (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -452  0xfffffe3c (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -430  0xfffffe52 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -454  0xfffffe3a (PmmC func) args[1] r=1  (not used)
file_PutC                           -440  0xfffffe48 (PmmC func) args[2] r=1  (not used)
file_PutS                           -444  0xfffffe44 (PmmC func) args[2] r=1  (not used)
file_PutW                           -442  0xfffffe46 (PmmC func) args[2] r=1  (not used)
file_Read                           -432  0xfffffe50 (PmmC func) args[3] r=1  (not used)
file_Rename                         -455  0xfffffe39 (PmmC func) args[2] r=1  (not used)
file_Rewind                         -447  0xfffffe41 (PmmC func) args[1] r=1  (not used)
file_Run                            -449  0xfffffe3f (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -439  0xfffffe49 (PmmC func) args[5] r=1  (not used)
file_Seek                           -433  0xfffffe4f (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_SetDate                        -456  0xfffffe38 (PmmC func) args[7] r=1  (not used)
file_Size                           -437  0xfffffe4b (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -435  0xfffffe4d (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -453  0xfffffe3b (PmmC func) args[0] r=0  (not used)
file_Write                          -436  0xfffffe4c (PmmC func) args[3] r=1  (not used)
FILLPATTERN_0                      65504  0x0000ffe0 (const dword)  (not used)
FILLPATTERN_1                      65505  0x0000ffe1 (const ??? 0)  (not used)
FILLPATTERN_10                     65514  0x0000ffea (const ??? 0)  (not used)
FILLPATTERN_11                     65515  0x0000ffeb (const ??? 0)  (not used)
FILLPATTERN_12                     65516  0x0000ffec (const ??? 0)  (not used)
FILLPATTERN_13                     65517  0x0000ffed (const ??? 0)  (not used)
FILLPATTERN_14                     65518  0x0000ffee (const ??? 0)  (not used)
FILLPATTERN_15                     65519  0x0000ffef (const ??? 0)  (not used)
FILLPATTERN_16                     65520  0x0000fff0 (const ??? 0)  (not used)
FILLPATTERN_17                     65521  0x0000fff1 (const ??? 0)  (not used)
FILLPATTERN_18                     65522  0x0000fff2 (const ??? 0)  (not used)
FILLPATTERN_19                     65523  0x0000fff3 (const ??? 0)  (not used)
FILLPATTERN_2                      65506  0x0000ffe2 (const ??? 0)  (not used)
FILLPATTERN_20                     65524  0x0000fff4 (const ??? 0)  (not used)
FILLPATTERN_21                     65525  0x0000fff5 (const ??? 0)  (not used)
FILLPATTERN_22                     65526  0x0000fff6 (const ??? 0)  (not used)
FILLPATTERN_23                     65527  0x0000fff7 (const ??? 0)  (not used)
FILLPATTERN_24                     65528  0x0000fff8 (const ??? 0)  (not used)
FILLPATTERN_25                     65529  0x0000fff9 (const ??? 0)  (not used)
FILLPATTERN_26                     65530  0x0000fffa (const ??? 0)  (not used)
FILLPATTERN_27                     65531  0x0000fffb (const ??? 0)  (not used)
FILLPATTERN_28                     65532  0x0000fffc (const ??? 0)  (not used)
FILLPATTERN_29                     65533  0x0000fffd (const ??? 0)  (not used)
FILLPATTERN_3                      65507  0x0000ffe3 (const ??? 0)  (not used)
FILLPATTERN_30                     65534  0x0000fffe (const ??? 0)  (not used)
FILLPATTERN_31                     65535  0x0000ffff (const ??? 0)  (not used)
FILLPATTERN_4                      65508  0x0000ffe4 (const ??? 0)  (not used)
FILLPATTERN_5                      65509  0x0000ffe5 (const ??? 0)  (not used)
FILLPATTERN_6                      65510  0x0000ffe6 (const ??? 0)  (not used)
FILLPATTERN_7                      65511  0x0000ffe7 (const ??? 0)  (not used)
FILLPATTERN_8                      65512  0x0000ffe8 (const ??? 0)  (not used)
FILLPATTERN_9                      65513  0x0000ffe9 (const ??? 0)  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_Bank                          -498  0xfffffe0e (PmmC func) args[0] r=1  (not used)
flash_Blit1                         -507  0xfffffe05 (PmmC func) args[4] r=1  (not used)
flash_Blit16                        -503  0xfffffe09 (PmmC func) args[3] r=1  (not used)
flash_Blit2                         -506  0xfffffe06 (PmmC func) args[4] r=1  (not used)
flash_Blit4                         -505  0xfffffe07 (PmmC func) args[4] r=1  (not used)
flash_Blit8                         -504  0xfffffe08 (PmmC func) args[3] r=1  (not used)
flash_Copy                          -496  0xfffffe10 (PmmC func) args[4] r=1  (not used)
flash_EraseBank                     -499  0xfffffe0d (PmmC func) args[2] r=1  (not used)
flash_Exec                          -508  0xfffffe04 (PmmC func) args[2] r=1  (not used)
flash_FunctionCall                  -624  0xfffffd90 (PmmC func) args[7] r=1  (not used)
flash_GetByte                       -494  0xfffffe12 (PmmC func) args[2] r=1  (not used)
flash_GetWord                       -495  0xfffffe11 (PmmC func) args[2] r=1  (not used)
flash_LoadFile                      -500  0xfffffe0c (PmmC func) args[2] r=1  (not used)
flash_LoadSPIflash                  -625  0xfffffd8f (PmmC func) args[3] r=1  (not used)
flash_putstr                        -502  0xfffffe0a (PmmC func) args[2] r=1  (not used)
FLASH_READ_PROTECT                    16  0x00000010 (const dword)  (not used)
flash_Run                           -497  0xfffffe0f (PmmC func) args[1] r=1  (not used)
FLASH_WRITE_PROTECT                   32  0x00000020 (const dword)  (not used)
flash_WriteBlock                    -501  0xfffffe0b (PmmC func) args[3] r=1  (not used)
FLASHBANK_0                            0  0x00000000 (const dword)  (usage 3)
FLASHBANK_1                            1  0x00000001 (const dword)  (not used)
FLASHBANK_2                            2  0x00000002 (const dword)  (not used)
FLASHBANK_3                            3  0x00000003 (const dword)  (not used)
FLASHBANK_4                            4  0x00000004 (const dword)  (not used)
FLASHBANK_5                            5  0x00000005 (const dword)  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
flt_ABS                              -84  0xffffffac (PmmC func) args[2] r=1  (not used)
flt_ACOS                             -85  0xffffffab (PmmC func) args[2] r=1  (not used)
flt_ADD                              -97  0xffffff9f (PmmC func) args[3] r=1  (not used)
flt_ASIN                             -86  0xffffffaa (PmmC func) args[2] r=1  (not used)
flt_ATAN                             -87  0xffffffa9 (PmmC func) args[2] r=1  (not used)
flt_CEIL                             -90  0xffffffa6 (PmmC func) args[2] r=1  (not used)
flt_COS                              -88  0xffffffa8 (PmmC func) args[2] r=1  (not used)
flt_DIV                             -100  0xffffff9c (PmmC func) args[3] r=1  (not used)
flt_EQ                              -101  0xffffff9b (PmmC func) args[2] r=1  (not used)
flt_EXP                              -89  0xffffffa7 (PmmC func) args[2] r=1  (not used)
flt_FLOOR                            -91  0xffffffa5 (PmmC func) args[2] r=1  (not used)
flt_FTOI                            -108  0xffffff94 (PmmC func) args[1] r=1  (not used)
flt_GE                              -104  0xffffff98 (PmmC func) args[2] r=1  (not used)
flt_GT                              -103  0xffffff99 (PmmC func) args[2] r=1  (not used)
flt_ITOF                             -79  0xffffffb1 (PmmC func) args[2] r=1  (not used)
flt_LE                              -106  0xffffff96 (PmmC func) args[2] r=1  (not used)
flt_LOG                              -93  0xffffffa3 (PmmC func) args[2] r=1  (not used)
flt_LT                              -105  0xffffff97 (PmmC func) args[2] r=1  (not used)
flt_LTOF                             -81  0xffffffaf (PmmC func) args[2] r=1  (not used)
flt_MUL                              -99  0xffffff9d (PmmC func) args[3] r=1  (not used)
flt_NE                              -102  0xffffff9a (PmmC func) args[2] r=1  (not used)
flt_POW                              -96  0xffffffa0 (PmmC func) args[3] r=1  (not used)
flt_PRINT                            -83  0xffffffad (PmmC func) args[2] r=1  (not used)
flt_PRINTxy                         -109  0xffffff93 (PmmC func) args[4] r=1  (not used)
flt_SGN                             -107  0xffffff95 (PmmC func) args[1] r=1  (not used)
flt_SIN                              -92  0xffffffa4 (PmmC func) args[2] r=1  (not used)
flt_SQR                              -94  0xffffffa2 (PmmC func) args[2] r=1  (not used)
flt_SUB                              -98  0xffffff9e (PmmC func) args[3] r=1  (not used)
flt_TAN                              -95  0xffffffa1 (PmmC func) args[2] r=1  (not used)
flt_UITOF                            -80  0xffffffb0 (PmmC func) args[2] r=1  (not used)
flt_ULTOF                            -82  0xffffffae (PmmC func) args[2] r=1  (not used)
flt_VAL                              -78  0xffffffb2 (PmmC func) args[2] r=1  (not used)
FONT1                                  1  0x00000001 (const dword)  (not used)
FONT2                                  2  0x00000002 (const dword)  (not used)
FONT3                                  3  0x00000003 (const dword)  (not used)
FONT_1                                 1  0x00000001 (const dword)  (not used)
FONT_10                               10  0x0000000a (const dword)  (not used)
FONT_11                               11  0x0000000b (const dword)  (not used)
FONT_2                                 2  0x00000002 (const dword)  (not used)
FONT_3                                 3  0x00000003 (const dword)  (not used)
FONT_4                                 4  0x00000004 (const dword)  (not used)
FONT_5                                 5  0x00000005 (const dword)  (not used)
FONT_6                                 6  0x00000006 (const dword)  (not used)
FONT_7                                 7  0x00000007 (const dword)  (not used)
FONT_8                                 8  0x00000008 (const dword)  (not used)
FONT_9                                 9  0x00000009 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                         795  0x0000031bFormBGcolors                         795  0x0000031b (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 6)
FormEndIndex                         693  0x000002b5FormEndIndex                         693  0x000002b5 (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 6)
FormStartIndex                       685  0x000002adFormStartIndex                       685  0x000002ad (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 6)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAUGE_COLOR                           18  0x00000012 (const dword)  (not used)
GAUGE_F_HORZ                         N/A         N/A (macro)    0x0002   (not used)
GAUGE_F_TOPRIGHT                     N/A         N/A (macro)    0x0001   (not used)
GAUGE_FLAGS                           36  0x00000024 (const dword)  (not used)
GAUGE_H                                6  0x00000006 (const dword)  (not used)
GAUGE_MAXV                            12  0x0000000c (const dword)  (not used)
GAUGE_MINV                            10  0x0000000a (const dword)  (not used)
GAUGE_P1                              34  0x00000022 (const dword)  (not used)
GAUGE_P1H                             22  0x00000016 (const dword)  (not used)
GAUGE_P1L                             20  0x00000014 (const dword)  (not used)
GAUGE_P2                              32  0x00000020 (const dword)  (not used)
GAUGE_P2H                             26  0x0000001a (const dword)  (not used)
GAUGE_P2L                             24  0x00000018 (const dword)  (not used)
GAUGE_P3H                             30  0x0000001e (const dword)  (not used)
GAUGE_P3L                             28  0x0000001c (const dword)  (not used)
GAUGE_SPACING                         16  0x00000010 (const dword)  (not used)
GAUGE_T                                8  0x00000008 (const dword)  (not used)
GAUGE_TICKH                           14  0x0000000e (const dword)  (not used)
GAUGE_W                                4  0x00000004 (const dword)  (not used)
GAUGE_X                                0  0x00000000 (const dword)  (not used)
GAUGE_Y                                2  0x00000002 (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                        -165  0xffffff5b (PmmC func) args[1] r=1  (not used)
gfx_565to332                        -166  0xffffff5a (PmmC func) args[1] r=1  (not used)
gfx_AngularMeter                    -582  0xfffffdba (PmmC func) args[3] r=0  (usage 3)
gfx_Arc                             -172  0xffffff54 (PmmC func) args[7] r=0  (not used)
gfx_BevelRadius                     -194  0xffffff3e (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -196  0xffffff3c (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -195  0xffffff3d (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                        -184  0xffffff48 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                           -149  0xffffff6b (PmmC func) args[2] r=0  (not used)
gfx_Bullet                          -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
gfx_Button                          -155  0xffffff65 (PmmC func) args[9] r=1  (not used)
gfx_Button2                         -156  0xffffff64 (PmmC func) args[8] r=0  (not used)
gfx_Button3                         -157  0xffffff63 (PmmC func) args[8] r=0  (not used)
gfx_Button4                         -603  0xfffffda5 (PmmC func) args[3] r=0  (not used)
gfx_ChangeColour                    -151  0xffffff69 (PmmC func) args[2] r=0  (not used)
gfx_CheckBox                        -158  0xffffff62 (PmmC func) args[8] r=0  (not used)
gfx_Circle                          -136  0xffffff78 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                    -137  0xffffff77 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                        -186  0xffffff46 (PmmC func) args[1] r=1  (not used)
gfx_ClipWindow                      -150  0xffffff6a (PmmC func) args[4] r=0  (not used)
gfx_Cls                             -126  0xffffff82 (PmmC func) args[0] r=0  (usage 6)
gfx_Contrast                        -192  0xffffff40 (PmmC func) args[1] r=1  (usage 3)
gfx_Dial                            -585  0xfffffdb7 (PmmC func) args[3] r=0  (not used)
gfx_Dot                             -145  0xffffff6f (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                         -153  0xffffff67 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                   -154  0xffffff66 (PmmC func) args[5] r=0  (not used)
gfx_FillPattern                     -170  0xffffff56 (PmmC func) args[2] r=1  (not used)
gfx_FrameDelay                      -189  0xffffff43 (PmmC func) args[1] r=1  (not used)
gfx_Gauge                           -586  0xfffffdb6 (PmmC func) args[3] r=0  (not used)
gfx_Get                             -182  0xffffff4a (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                        -139  0xffffff75 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -176  0xffffff50 (PmmC func) args[7] r=0  (not used)
gfx_GradientColor                   -627  0xfffffd8d (PmmC func) args[6] r=1  (not used)
gfx_GradientShape                   -626  0xfffffd8e (PmmC func) args[19] r=0  (not used)
gfx_GradTriangleFilled              -628  0xfffffd8c (PmmC func) args[12] r=0  (not used)
gfx_Hline                           -132  0xffffff7c (PmmC func) args[4] r=1  (not used)
gfx_IncX                            -147  0xffffff6d (PmmC func) args[0] r=1  (not used)
gfx_IncY                            -148  0xffffff6c (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
gfx_Led                             -604  0xfffffda4 (PmmC func) args[3] r=0  (not used)
gfx_LedDigit                        -588  0xfffffdb4 (PmmC func) args[6] r=0  (not used)
gfx_LedDigits                       -587  0xfffffdb5 (PmmC func) args[3] r=0  (usage 3)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
gfx_Line                            -131  0xffffff7d (PmmC func) args[5] r=0  (not used)
gfx_LinePattern                     -193  0xffffff3f (PmmC func) args[1] r=1  (not used)
gfx_LineRel                         -130  0xffffff7e (PmmC func) args[2] r=0  (not used)
gfx_LineTo                          -129  0xffffff7f (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                         -128  0xffffff80 (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                          -127  0xffffff81 (PmmC func) args[2] r=0  (not used)
gfx_Needle                          -584  0xfffffdb8 (PmmC func) args[3] r=0  (not used)
gfx_ObjectColour                    -185  0xffffff47 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                           -142  0xffffff72 (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                       -141  0xffffff73 (PmmC func) args[2] r=0  (not used)
gfx_Origin                          -169  0xffffff57 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                   -191  0xffffff41 (PmmC func) args[1] r=1  (not used)
gfx_Panel                           -161  0xffffff5f (PmmC func) args[6] r=0  (not used)
gfx_Panel2                          -583  0xfffffdb9 (PmmC func) args[10] r=0  (not used)
gfx_PenSize                         -183  0xffffff49 (PmmC func) args[1] r=1  (not used)
gfx_PieSlice                        -171  0xffffff55 (PmmC func) args[9] r=0  (not used)
gfx_PointWithinBox                  -199  0xffffff39 (PmmC func) args[3] r=1  (not used)
gfx_PointWithinRectangle            -200  0xffffff38 (PmmC func) args[3] r=1  (not used)
gfx_Polygon                         -144  0xffffff70 (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                   -168  0xffffff58 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                        -143  0xffffff71 (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                        -138  0xffffff76 (PmmC func) args[3] r=0  (not used)
gfx_RadioButton                     -159  0xffffff61 (PmmC func) args[8] r=0  (not used)
gfx_ReadBresLine                    -178  0xffffff4e (PmmC func) args[5] r=1  (not used)
gfx_ReadGRAMarea                    -180  0xffffff4c (PmmC func) args[5] r=1  (not used)
gfx_Rectangle                       -134  0xffffff7a (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                 -135  0xffffff79 (PmmC func) args[5] r=0  (not used)
gfx_RGBto565                        -164  0xffffff5c (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
gfx_RingSegment                     -581  0xfffffdbb (PmmC func) args[7] r=0  (not used)
gfx_RoundGradient                   -177  0xffffff4f (PmmC func) args[8] r=0  (not used)
gfx_RoundPanel                      -175  0xffffff51 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -173  0xffffff53 (PmmC func) args[6] r=0  (not used)
gfx_RulerGauge                      -606  0xfffffda2 (PmmC func) args[3] r=0  (not used)
gfx_Scale                           -605  0xfffffda3 (PmmC func) args[2] r=0  (not used)
gfx_Scope                           -532  0xfffffdec (PmmC func) args[19] r=0  (not used)
gfx_ScreenCopyPaste                 -163  0xffffff5d (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                      -190  0xffffff42 (PmmC func) args[1] r=1  (usage 3)
gfx_Set                             -125  0xffffff83 (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                   -152  0xffffff68 (PmmC func) args[0] r=0  (not used)
gfx_Slider                          -162  0xffffff5e (PmmC func) args[8] r=1  (not used)
gfx_Slider2                         -160  0xffffff60 (PmmC func) args[8] r=1  (not used)
gfx_Slider5                         -601  0xfffffda7 (PmmC func) args[3] r=0  (not used)
gfx_Surround                        -174  0xffffff52 (PmmC func) args[7] r=0  (not used)
gfx_Switch                          -602  0xfffffda6 (PmmC func) args[3] r=0  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                    -188  0xffffff44 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour               -187  0xffffff45 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                        -140  0xffffff74 (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                  -167  0xffffff59 (PmmC func) args[7] r=0  (not used)
gfx_Vline                           -133  0xffffff7b (PmmC func) args[4] r=1  (not used)
gfx_WriteBresLine                   -179  0xffffff4d (PmmC func) args[5] r=0  (not used)
gfx_WriteGRAMarea                   -181  0xffffff4b (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
gfx_XYlinToVal                      -634  0xfffffd86 (PmmC func) args[7] r=1  (not used)
gfx_XYrotToVal                      -633  0xfffffd87 (PmmC func) args[7] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -198  0xffffff3a (PmmC func) args[1] r=1  (not used)
gfxInternals                           7  0x00000007gfxInternals                           7  0x00000007 (mem) word[29] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 6)
gfxIntParms                           65  0x00000041gfxIntParms                           65  0x00000041 (mem) word[29] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
gfxIntStrings                        123  0x0000007bgfxIntStrings                        123  0x0000007b (mem) word[29] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectDATA                          240  0x000000f0 (mem) word (global)  (usage 6)
GObjectFunc                          236  0x000000ec (mem) word (global)  (usage 6)
GObjectIdx                           234  0x000000ea (mem) word (global)  (usage 14)
GObjectParms                         242  0x000000f2 (mem) word (global)  (usage 3)
GObjectRAM                           238  0x000000ee (mem) word (global)  (usage 14)
GObjectStrings                       244  0x000000f4 (mem) word (global)  (usage 3)
GObjectType                          392  0x00000188 (mem) word (global)  (usage 58)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (usage 3)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                               -48  0xffffffd0 (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 60)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
HYPER                                  3  0x00000003 (const dword)  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -305  0xfffffecf (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -314  0xfffffec6 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -311  0xfffffec9 (PmmC func) args[0] r=1  (not used)
I2C1_Close                          -287  0xfffffee1 (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -323  0xfffffebd (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -320  0xfffffec0 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -317  0xfffffec3 (PmmC func) args[0] r=1  (not used)
I2C1_Nack                           -308  0xfffffecc (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -284  0xfffffee4 (PmmC func) args[3] r=1  (not used)
I2C1_Putn                           -329  0xfffffeb7 (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -299  0xfffffed5 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -290  0xfffffede (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -293  0xfffffedb (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -302  0xfffffed2 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -306  0xfffffece (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -315  0xfffffec5 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -312  0xfffffec8 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -288  0xfffffee0 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -321  0xfffffebf (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -318  0xfffffec2 (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -309  0xfffffecb (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -285  0xfffffee3 (PmmC func) args[3] r=1  (not used)
I2C2_Putn                           -330  0xfffffeb6 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -327  0xfffffeb9 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -300  0xfffffed4 (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -297  0xfffffed7 (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -291  0xfffffedd (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -294  0xfffffeda (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -303  0xfffffed1 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -307  0xfffffecd (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -316  0xfffffec4 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -313  0xfffffec7 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -289  0xfffffedf (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -322  0xfffffebe (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -319  0xfffffec1 (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -310  0xfffffeca (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
I2C3_Putn                           -331  0xfffffeb5 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -328  0xfffffeb8 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -301  0xfffffed3 (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -298  0xfffffed6 (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -292  0xfffffedc (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -295  0xfffffed9 (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -304  0xfffffed0 (PmmC func) args[1] r=1  (not used)
I2C_10KHZ                              3  0x00000003 (const dword)  (not used)
I2C_20KHZ                              4  0x00000004 (const dword)  (not used)
I2C_250KHZ                             6  0x00000006 (const dword)  (not used)
I2C_50KHZ                              5  0x00000005 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 3)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                           0  0x00000000 (const dword)  (not used)
iFormEndIndex                        709  0x000002c5iFormEndIndex                        709  0x000002c5 (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 6)
iFormStartIndex                      701  0x000002bdiFormStartIndex                      701  0x000002bd (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 6)
iIAngularMeter0                        0  0x00000000 (const ??? 0)  (not used)
IIAngularMeter0                      213  0x000000d5IIAngularMeter0                      213  0x000000d5 (mem) word[48] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
iIAngularMeter1                        2  0x00000002 (const ??? 0)  (not used)
IIAngularMeter1                      331  0x0000014bIIAngularMeter1                      331  0x0000014b (mem) word[48] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
iIAngularMeter2                        4  0x00000004 (const ??? 0)  (not used)
IIAngularMeter2                      449  0x000001c1IIAngularMeter2                      449  0x000001c1 (mem) word[48] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
iIAngularMeter3                        6  0x00000006 (const ??? 0)  (not used)
IIAngularMeter3                      567  0x00000237IIAngularMeter3                      567  0x00000237 (mem) word[48] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
iiFormEndIndex                       725  0x000002d5iiFormEndIndex                       725  0x000002d5 (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (not used)
iiFormStartIndex                     717  0x000002cdiiFormStartIndex                     717  0x000002cd (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (not used)
iILedDigits0                           1  0x00000001 (const ??? 0)  (not used)
IILedDigits0                         309  0x00000135IILedDigits0                         309  0x00000135 (mem) word[11] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
iILedDigits1                           3  0x00000003 (const ??? 0)  (not used)
IILedDigits1                         427  0x000001abIILedDigits1                         427  0x000001ab (mem) word[11] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
iILedDigits2                           5  0x00000005 (const ??? 0)  (not used)
IILedDigits2                         545  0x00000221IILedDigits2                         545  0x00000221 (mem) word[11] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
iILedDigits3                           7  0x00000007 (const ??? 0)  (not used)
IILedDigits3                         663  0x00000297IILedDigits3                         663  0x00000297 (mem) word[11] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
ILINEARIP_COLOR1                      12  0x0000000c (const dword)  (not used)
ILINEARIP_COLOR2                      14  0x0000000e (const dword)  (not used)
ILINEARIP_COLOR3                      16  0x00000010 (const dword)  (not used)
ILINEARIP_COLOR4                      18  0x00000012 (const dword)  (not used)
ILINEARIP_COLOR5                      20  0x00000014 (const dword)  (not used)
ILINEARIP_COLOR6                      22  0x00000016 (const dword)  (not used)
ILINEARIP_H                            6  0x00000006 (const dword)  (not used)
ILINEARIP_INDEX                        8  0x00000008 (const dword)  (not used)
ILINEARIP_MAXVAL                      42  0x0000002a (const dword)  (not used)
ILINEARIP_MINVAL                      44  0x0000002c (const dword)  (not used)
ILINEARIP_OFFSET_BR                   46  0x0000002e (const dword)  (not used)
ILINEARIP_OFFSET_TL                   48  0x00000030 (const dword)  (not used)
ILINEARIP_ORIENTATION                 10  0x0000000a (const dword)  (not used)
ILINEARIP_TEXT1                       36  0x00000024 (const dword)  (not used)
ILINEARIP_TEXT2                       38  0x00000026 (const dword)  (not used)
ILINEARIP_TEXT3                       40  0x00000028 (const dword)  (not used)
ILINEARIP_VALUE1                      24  0x00000018 (const dword)  (not used)
ILINEARIP_VALUE2                      26  0x0000001a (const dword)  (not used)
ILINEARIP_VALUE3                      28  0x0000001c (const dword)  (not used)
ILINEARIP_VALUE4                      30  0x0000001e (const dword)  (not used)
ILINEARIP_VALUE5                      32  0x00000020 (const dword)  (not used)
ILINEARIP_VALUE6                      34  0x00000022 (const dword)  (not used)
ILINEARIP_W                            4  0x00000004 (const dword)  (not used)
ILINEARIP_X                            0  0x00000000 (const dword)  (not used)
ILINEARIP_Y                            2  0x00000002 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 22)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
ImageTouched                         386  0x00000182 (mem) word (global)  (usage 72)
img_ClearAttributes                 -383  0xfffffe81 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -376  0xfffffe88 (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -375  0xfffffe89 (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
img_FileExec                        -619  0xfffffd95 (PmmC func) args[3] r=1  (not used)
img_FileGetC                        -613  0xfffffd9b (PmmC func) args[2] r=1  (not used)
img_FileGetS                        -615  0xfffffd99 (PmmC func) args[4] r=1  (not used)
img_FileGetW                        -614  0xfffffd9a (PmmC func) args[2] r=1  (not used)
img_FileIndex                       -610  0xfffffd9e (PmmC func) args[5] r=1  (not used)
img_FileLoadFunction                -617  0xfffffd97 (PmmC func) args[2] r=1  (not used)
img_FilePlayWAV                     -620  0xfffffd94 (PmmC func) args[2] r=1  (not used)
img_FileRead                        -608  0xfffffda0 (PmmC func) args[4] r=1  (not used)
img_FileRewind                      -616  0xfffffd98 (PmmC func) args[2] r=1  (not used)
img_FileRun                         -618  0xfffffd96 (PmmC func) args[3] r=1  (not used)
img_FileSeek                        -609  0xfffffd9f (PmmC func) args[4] r=1  (not used)
img_FileSize                        -612  0xfffffd9c (PmmC func) args[4] r=1  (not used)
img_FileTell                        -611  0xfffffd9d (PmmC func) args[4] r=1  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -380  0xfffffe84 (PmmC func) args[3] r=1  (usage 23)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SelectReadPosition              -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_SequentialRead                  -386  0xfffffe7e (PmmC func) args[2] r=1  (not used)
img_SetAttributes                   -382  0xfffffe82 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -374  0xfffffe8a (PmmC func) args[4] r=1  (not used)
img_SetWord                         -379  0xfffffe85 (PmmC func) args[4] r=1  (usage 8)
img_Show                            -381  0xfffffe83 (PmmC func) args[2] r=1  (usage 8)
img_Touched                         -384  0xfffffe80 (PmmC func) args[2] r=1  (usage 3)
img_TxtFontID                       -621  0xfffffd93 (PmmC func) args[2] r=1  (not used)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
InputControls                        733  0x000002ddInputControls                        733  0x000002dd (mem) word[1] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
InputCS                              640  0x00000280 (mem) word (global)  (usage 15)
InputData                            751  0x000002efInputData                            751  0x000002ef (mem) word[1] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 8)
InternalInputControls                735  0x000002dfInternalInputControls                735  0x000002df (mem) word[8] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 6)
INVERSE                               64  0x00000040 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (not used)
IROTARYIP_COLOR1                      10  0x0000000a (const dword)  (not used)
IROTARYIP_COLOR2                      12  0x0000000c (const dword)  (not used)
IROTARYIP_COLOR3                      14  0x0000000e (const dword)  (not used)
IROTARYIP_COLOR4                      16  0x00000010 (const dword)  (not used)
IROTARYIP_COLOR5                      18  0x00000012 (const dword)  (not used)
IROTARYIP_COLOR6                      20  0x00000014 (const dword)  (not used)
IROTARYIP_H                            6  0x00000006 (const dword)  (not used)
IROTARYIP_INDEX                        8  0x00000008 (const dword)  (not used)
IROTARYIP_MAXANGLE                    40  0x00000028 (const dword)  (not used)
IROTARYIP_MAXVALUE                    42  0x0000002a (const dword)  (not used)
IROTARYIP_MINANGLE                    44  0x0000002c (const dword)  (not used)
IROTARYIP_MINVALUE                    46  0x0000002e (const dword)  (not used)
IROTARYIP_TEXT1                       34  0x00000022 (const dword)  (not used)
IROTARYIP_TEXT2                       36  0x00000024 (const dword)  (not used)
IROTARYIP_TEXT3                       38  0x00000026 (const dword)  (not used)
IROTARYIP_VALUE1                      22  0x00000016 (const dword)  (not used)
IROTARYIP_VALUE2                      24  0x00000018 (const dword)  (not used)
IROTARYIP_VALUE3                      26  0x0000001a (const dword)  (not used)
IROTARYIP_VALUE4                      28  0x0000001c (const dword)  (not used)
IROTARYIP_VALUE5                      30  0x0000001e (const dword)  (not used)
IROTARYIP_VALUE6                      32  0x00000020 (const dword)  (not used)
IROTARYIP_W                            4  0x00000004 (const dword)  (not used)
IROTARYIP_X                            0  0x00000000 (const dword)  (not used)
IROTARYIP_Y                            2  0x00000002 (const dword)  (not used)
isalnum                              -41  0xffffffd7 (PmmC func) args[1] r=1  (not used)
isalpha                              -40  0xffffffd8 (PmmC func) args[1] r=1  (not used)
isdigit                              -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
islower                              -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
isprint                              -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
isspace                              -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
iStatictext0                           0  0x00000000 (const ??? 0)  (usage 3)
iStatictext1                           1  0x00000001 (const ??? 0)  (usage 3)
iStatictext2                           2  0x00000002 (const ??? 0)  (usage 3)
iStatictext3                           3  0x00000003 (const ??? 0)  (usage 3)
isupper                              -38  0xffffffda (PmmC func) args[1] r=1  (not used)
iswhite                              -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
isxdigit                             -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -404  0xfffffe6c (PmmC func) args[1] r=0  (not used)
ITOGGLEIP_COLOR1                      10  0x0000000a (const dword)  (not used)
ITOGGLEIP_COLOR2                      12  0x0000000c (const dword)  (not used)
ITOGGLEIP_COLOR3                      14  0x0000000e (const dword)  (not used)
ITOGGLEIP_COLOR4                      16  0x00000010 (const dword)  (not used)
ITOGGLEIP_COLOR5                      18  0x00000012 (const dword)  (not used)
ITOGGLEIP_COLOR6                      20  0x00000014 (const dword)  (not used)
ITOGGLEIP_H                            6  0x00000006 (const dword)  (not used)
ITOGGLEIP_INDEX                        8  0x00000008 (const dword)  (not used)
ITOGGLEIP_MATRIX                      40  0x00000028 (const dword)  (not used)
ITOGGLEIP_MOMENTARY                   42  0x0000002a (const dword)  (not used)
ITOGGLEIP_TEXT1                       34  0x00000022 (const dword)  (not used)
ITOGGLEIP_TEXT2                       36  0x00000024 (const dword)  (not used)
ITOGGLEIP_TEXT3                       38  0x00000026 (const dword)  (not used)
ITOGGLEIP_VALUE1                      22  0x00000016 (const dword)  (not used)
ITOGGLEIP_VALUE2                      24  0x00000018 (const dword)  (not used)
ITOGGLEIP_VALUE3                      26  0x0000001a (const dword)  (not used)
ITOGGLEIP_VALUE4                      28  0x0000001c (const dword)  (not used)
ITOGGLEIP_VALUE5                      30  0x0000001e (const dword)  (not used)
ITOGGLEIP_VALUE6                      32  0x00000020 (const dword)  (not used)
ITOGGLEIP_W                            4  0x00000004 (const dword)  (not used)
ITOGGLEIP_X                            0  0x00000000 (const dword)  (not used)
ITOGGLEIP_Y                            2  0x00000002 (const dword)  (not used)
IUSERGAUGE_COLOR1                     10  0x0000000a (const dword)  (not used)
IUSERGAUGE_COLOR2                     12  0x0000000c (const dword)  (not used)
IUSERGAUGE_COLOR3                     14  0x0000000e (const dword)  (not used)
IUSERGAUGE_COLOR4                     16  0x00000010 (const dword)  (not used)
IUSERGAUGE_COLOR5                     18  0x00000012 (const dword)  (not used)
IUSERGAUGE_COLOR6                     20  0x00000014 (const dword)  (not used)
IUSERGAUGE_H                           6  0x00000006 (const dword)  (not used)
IUSERGAUGE_INDEX                       8  0x00000008 (const dword)  (not used)
IUSERGAUGE_TEXT1                      34  0x00000022 (const dword)  (not used)
IUSERGAUGE_TEXT2                      36  0x00000024 (const dword)  (not used)
IUSERGAUGE_TEXT3                      38  0x00000026 (const dword)  (not used)
IUSERGAUGE_VALUE1                     22  0x00000016 (const dword)  (not used)
IUSERGAUGE_VALUE2                     24  0x00000018 (const dword)  (not used)
IUSERGAUGE_VALUE3                     26  0x0000001a (const dword)  (not used)
IUSERGAUGE_VALUE4                     28  0x0000001c (const dword)  (not used)
IUSERGAUGE_VALUE5                     30  0x0000001e (const dword)  (not used)
IUSERGAUGE_VALUE6                     32  0x00000020 (const dword)  (not used)
IUSERGAUGE_W                           4  0x00000004 (const dword)  (not used)
IUSERGAUGE_X                           0  0x00000000 (const dword)  (not used)
IUSERGAUGE_Y                           2  0x00000002 (const dword)  (not used)
IVORY                              65534  0x0000fffe (const dword)  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                  803  0x00000323kKeyboardKeystrokes                  803  0x00000323 (mem) word[1] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (not used)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LED1_cbe                              10  0x0000000a (const dword)  (not used)
LED1_cbs                               8  0x00000008 (const dword)  (not used)
LED1_cOff                             16  0x00000010 (const dword)  (not used)
LED1_cOn                              14  0x0000000e (const dword)  (not used)
LED1_cs                               12  0x0000000c (const dword)  (not used)
LED1_h                                 6  0x00000006 (const dword)  (not used)
LED1_iBr                              18  0x00000012 (const dword)  (not used)
LED1_iLr                              22  0x00000016 (const dword)  (not used)
LED1_oBr                              20  0x00000014 (const dword)  (not used)
LED1_oLr                              24  0x00000018 (const dword)  (not used)
LED1_sh                               26  0x0000001a (const dword)  (not used)
LED1_w                                 4  0x00000004 (const dword)  (not used)
LED1_x                                 0  0x00000000 (const dword)  (not used)
LED1_y                                 2  0x00000002 (const dword)  (not used)
LEDDIGIT_F_DP_COMMA                  N/A         N/A (macro)   0x0400   (not used)
LEDDIGIT_F_DP_ON                     N/A         N/A (macro)   0x0200   (not used)
LEDDIGIT_F_SET_SEGMENTS              N/A         N/A (macro)   0x1000   (not used)
LEDDIGIT_F_SHOW_DP                   N/A         N/A (macro)   0x0800   (not used)
LEDDIGITS_decimals                    10  0x0000000a (const dword)  (not used)
LEDDIGITS_digits                       8  0x00000008 (const dword)  (not used)
LEDDIGITS_digsize                     14  0x0000000e (const dword)  (not used)
LEDDIGITS_F_DP_COMMA                 N/A         N/A (macro)   0x0040   (not used)
LEDDIGITS_F_DP_DOT                   N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_FIXED                    N/A         N/A (macro)   0x0002   (not used)
LEDDIGITS_F_FLOAT                    N/A         N/A (macro)   0x0008   (not used)
LEDDIGITS_F_FLOATFORMATS             N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_GENERAL                  N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_INT16                    N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_INT32                    N/A         N/A (macro)   0x0004   (not used)
LEDDIGITS_F_LEADING0                 N/A         N/A (macro)   0x0020   (not used)
LEDDIGITS_F_LEADINGb                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_SCIENTIFIC               N/A         N/A (macro)   0x0001   (not used)
LEDDIGITS_F_SIGNED                   N/A         N/A (macro)   0x0010   (not used)
LEDDIGITS_F_TYPES                    N/A         N/A (macro)   0x000c   (not used)
LEDDIGITS_F_UNSIGNED                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_flags                       20  0x00000014 (const dword)  (not used)
LEDDIGITS_gap                         12  0x0000000c (const dword)  (not used)
LEDDIGITS_h                            6  0x00000006 (const dword)  (not used)
LEDDIGITS_offcolour                   18  0x00000012 (const dword)  (not used)
LEDDIGITS_oncolour                    16  0x00000010 (const dword)  (not used)
LEDDIGITS_w                            4  0x00000004 (const dword)  (not used)
LEDDIGITS_x                            0  0x00000000 (const dword)  (not used)
LEDDIGITS_y                            2  0x00000002 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (usage 39)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                               -47  0xffffffd1 (PmmC func) args[1] r=1  (not used)
LOCAL                                N/A         N/A (macro) //   (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
M_PA0                                  1  0x00000001 (const dword)  (not used)
M_PA1                                  2  0x00000002 (const dword)  (not used)
M_PA10                              1024  0x00000400 (const dword)  (not used)
M_PA11                              2048  0x00000800 (const dword)  (not used)
M_PA12                              4096  0x00001000 (const dword)  (not used)
M_PA13                              8192  0x00002000 (const dword)  (not used)
M_PA14                             16384  0x00004000 (const dword)  (not used)
M_PA15                             32768  0x00008000 (const dword)  (not used)
M_PA2                                  4  0x00000004 (const dword)  (not used)
M_PA3                                  8  0x00000008 (const dword)  (not used)
M_PA4                                 16  0x00000010 (const dword)  (not used)
M_PA5                                 32  0x00000020 (const dword)  (not used)
M_PA6                                 64  0x00000040 (const dword)  (not used)
M_PA7                                128  0x00000080 (const dword)  (not used)
M_PA8                                256  0x00000100 (const dword)  (not used)
M_PA9                                512  0x00000200 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                 897  0x00000381 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (usage 9)
MAX                                  -55  0xffffffc9 (PmmC func) args[2] r=1  (not used)
MaxIntObjects                         27  0x0000001b (const dword)  (usage 3)
MaxTotObjects                         67  0x00000043 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
media_Flush                         -218  0xffffff26 (PmmC func) args[0] r=1  (not used)
media_Image                         -217  0xffffff27 (PmmC func) args[2] r=0  (not used)
media_Init                          -219  0xffffff25 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -213  0xffffff2b (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -214  0xffffff2a (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                       93  0x0000005d (const dword)  (not used)
MEDIA_SECTOR_LO                       92  0x0000005c (const dword)  (not used)
media_SetAdd                        -209  0xffffff2f (PmmC func) args[2] r=0  (not used)
media_SetSector                     -210  0xffffff2e (PmmC func) args[2] r=0  (not used)
media_Video                         -207  0xffffff31 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -208  0xffffff30 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
media_WrSector                      -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -413  0xfffffe63 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -414  0xfffffe62 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -415  0xfffffe61 (PmmC func) args[1] r=1  (not used)
mem_ArrayOp1                         -67  0xffffffbd (PmmC func) args[4] r=0  (not used)
mem_ArrayOp2                         -68  0xffffffbc (PmmC func) args[5] r=0  (not used)
mem_Compare                         -421  0xfffffe5b (PmmC func) args[3] r=1  (not used)
mem_Copy                            -420  0xfffffe5c (PmmC func) args[3] r=1  (not used)
mem_Free                            -417  0xfffffe5f (PmmC func) args[1] r=1  (not used)
mem_Heap                            -418  0xfffffe5e (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -416  0xfffffe60 (PmmC func) args[2] r=1  (not used)
mem_Set                             -419  0xfffffe5d (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -54  0xffffffca (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                3386  0x00000d3a (User func) args[0] r=0  (usage 12)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NEEDLE_bgcol                          12  0x0000000c (const dword)  (not used)
NEEDLE_ccol                           36  0x00000024 (const dword)  (not used)
NEEDLE_colour                         32  0x00000020 (const dword)  (not used)
NEEDLE_crad                           34  0x00000022 (const dword)  (not used)
NEEDLE_cxx                             8  0x00000008 (const dword)  (not used)
NEEDLE_cyx                            10  0x0000000a (const dword)  (not used)
NEEDLE_extra                          30  0x0000001e (const dword)  (not used)
NEEDLE_F_DOUBLETRIANGLE                4  0x00000004 (const dword)  (not used)
NEEDLE_F_LINE                          0  0x00000000 (const dword)  (not used)
NEEDLE_F_POINTRECTANGLE                2  0x00000002 (const dword)  (not used)
NEEDLE_F_RECTANGLE                     1  0x00000001 (const dword)  (not used)
NEEDLE_F_ROUNDEDRECTANGLE              5  0x00000005 (const dword)  (not used)
NEEDLE_F_TRIANGLE                      3  0x00000003 (const dword)  (not used)
NEEDLE_h                               6  0x00000006 (const dword)  (not used)
NEEDLE_icol                           40  0x00000028 (const dword)  (not used)
NEEDLE_irad                           38  0x00000026 (const dword)  (not used)
NEEDLE_len                            22  0x00000016 (const dword)  (not used)
NEEDLE_maxa                           16  0x00000010 (const dword)  (not used)
NEEDLE_maxv                           20  0x00000014 (const dword)  (not used)
NEEDLE_mina                           14  0x0000000e (const dword)  (not used)
NEEDLE_minv                           18  0x00000012 (const dword)  (not used)
NEEDLE_offs                           26  0x0000001a (const dword)  (not used)
NEEDLE_rad                            28  0x0000001c (const dword)  (not used)
NEEDLE_style                          24  0x00000018 (const dword)  (not used)
NEEDLE_w                               4  0x00000004 (const dword)  (not used)
NEEDLE_x                               0  0x00000000 (const dword)  (not used)
NEEDLE_y                               2  0x00000002 (const dword)  (not used)
nInputs                                0  0x00000000 (const dword)  (not used)
nObjects                               4  0x00000004 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
NP_565                                 0  0x00000000 (const dword)  (not used)
NP_RGB                                 1  0x00000001 (const dword)  (not used)
NP_Write                            -535  0xfffffde9 (PmmC func) args[7] r=1  (not used)
NP_XRGB                                2  0x00000002 (const dword)  (not used)
NybleSwap                            -50  0xffffffce (PmmC func) args[1] r=1  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                          753  0x000002f1oDipSwitchs                          753  0x000002f1 (mem) word[1] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 189)
OFF                                    0  0x00000000 (const dword)  (not used)
oForms                               755  0x000002f3oForms                               755  0x000002f3 (mem) word[5] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (not used)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (not used)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (not used)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (not used)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (not used)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 3)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 2)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 6)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 10)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 4)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 2)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 6)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 12)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 5)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (not used)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (not used)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (not used)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (not used)
Ofs_String_Form                       24  0x00000018 (const dword)  (not used)
Ofs_String_GciFSFontIdx               26  0x0000001a (const dword)  (not used)
Ofs_String_Size                        4  0x00000004 (const dword)  (not used)
Ofs_String_StartH                      0  0x00000000 (const dword)  (not used)
Ofs_String_StartL                      2  0x00000002 (const dword)  (not used)
Ofs_String_Transparent                20  0x00000014 (const dword)  (not used)
Ofs_String_x1                          6  0x00000006 (const dword)  (not used)
Ofs_String_x2                         10  0x0000000a (const dword)  (not used)
Ofs_String_y1                          8  0x00000008 (const dword)  (not used)
Ofs_String_y2                         12  0x0000000c (const dword)  (not used)
oiAngularMeters                      775  0x00000307oiAngularMeters                      775  0x00000307 (mem) word[5] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
oiLedDigitss                         785  0x00000311oiLedDigitss                         785  0x00000311 (mem) word[5] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
oiviAngularMeter                     181  0x000000b5oiviAngularMeter                     181  0x000000b5 (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
oiviLedDigits                        189  0x000000bdoiviLedDigits                        189  0x000000bd (mem) word[4] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 384  0x00000180 (mem) word (global)  (usage 42)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (not used)
oObjects                             246  0x000000f6 (mem) word[68] (global)  (usage 216)
OP1_ADD                                5  0x00000005 (const dword)  (not used)
OP1_AND                                2  0x00000002 (const dword)  (not used)
OP1_BLACKEN                           16  0x00000010 (const dword)  (not used)
OP1_DARKEN                            18  0x00000012 (const dword)  (not used)
OP1_DIV                                8  0x00000008 (const dword)  (not used)
OP1_GRAY                              14  0x0000000e (const dword)  (not used)
OP1_IOR                                3  0x00000003 (const dword)  (not used)
OP1_LIGHTEN                           17  0x00000011 (const dword)  (not used)
OP1_MUL                                7  0x00000007 (const dword)  (not used)
OP1_NOP                                0  0x00000000 (const dword)  (not used)
OP1_REV                                9  0x00000009 (const dword)  (not used)
OP1_ROL                               12  0x0000000c (const dword)  (not used)
OP1_ROR                               13  0x0000000d (const dword)  (not used)
OP1_SET                                1  0x00000001 (const dword)  (not used)
OP1_SHL                               10  0x0000000a (const dword)  (not used)
OP1_SHR                               11  0x0000000b (const dword)  (not used)
OP1_SUB                                6  0x00000006 (const dword)  (not used)
OP1_WHITEN                            15  0x0000000f (const dword)  (not used)
OP1_XOR                                4  0x00000004 (const dword)  (not used)
OP2_ADD                                4  0x00000004 (const dword)  (not used)
OP2_AND                                1  0x00000001 (const dword)  (not used)
OP2_BLEND                              9  0x00000009 (const dword)  (not used)
OP2_COPY                               8  0x00000008 (const dword)  (not used)
OP2_DIV                                7  0x00000007 (const dword)  (not used)
OP2_IOR                                2  0x00000002 (const dword)  (not used)
OP2_MUL                                6  0x00000006 (const dword)  (not used)
OP2_SUB                                5  0x00000005 (const dword)  (not used)
OP2_XOR                                3  0x00000003 (const dword)  (not used)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (usage 3)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oStaticTexts                         765  0x000002fdoStaticTexts                         765  0x000002fd (mem) word[5] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 2)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 2)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 2)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (not used)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 2)
OT_PREVSTRING                        107  0x0000006b (const dword)  (not used)
OT_REPORT                            100  0x00000064 (const dword)  (usage 2)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 2)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 2)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OutputCS                             642  0x00000282 (mem) word (global)  (usage 9)
OVF                                  -63  0xffffffc1 (PmmC func) args[0] r=1  (not used)
OW_Read                             -523  0xfffffdf5 (PmmC func) args[1] r=1  (not used)
OW_Read9                            -524  0xfffffdf4 (PmmC func) args[1] r=1  (not used)
OW_Reset                            -522  0xfffffdf6 (PmmC func) args[1] r=1  (not used)
OW_Write                            -525  0xfffffdf3 (PmmC func) args[2] r=0  (not used)
PA0                                    1  0x00000001 (const dword)  (not used)
PA1                                    2  0x00000002 (const dword)  (not used)
PA10                                  11  0x0000000b (const dword)  (not used)
PA11                                  12  0x0000000c (const dword)  (not used)
PA12                                  13  0x0000000d (const dword)  (not used)
PA13                                  14  0x0000000e (const dword)  (not used)
PA14                                  15  0x0000000f (const dword)  (not used)
PA15                                  16  0x00000010 (const dword)  (not used)
PA2                                    3  0x00000003 (const dword)  (not used)
PA3                                    4  0x00000004 (const dword)  (not used)
PA4                                    5  0x00000005 (const dword)  (not used)
PA5                                    6  0x00000006 (const dword)  (not used)
PA6                                    7  0x00000007 (const dword)  (not used)
PA7                                    8  0x00000008 (const dword)  (not used)
PA8                                    9  0x00000009 (const dword)  (not used)
PA9                                   10  0x0000000a (const dword)  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL2_FILLED                      32768  0x00008000 (const dword)  (not used)
PANEL_FRAME                            3  0x00000003 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -34  0xffffffde (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PIN_AN                                 5  0x00000005 (const dword)  (not used)
PIN_ANAVG                              6  0x00000006 (const dword)  (not used)
pin_Counter                         -514  0xfffffdfe (PmmC func) args[3] r=1  (not used)
PIN_COUNTER_PA4                      123  0x0000007b (const dword)  (not used)
PIN_COUNTER_PA5                      124  0x0000007c (const dword)  (not used)
PIN_COUNTER_PA6                      125  0x0000007d (const dword)  (not used)
PIN_COUNTER_PA7                      126  0x0000007e (const dword)  (not used)
PIN_COUNTER_PA8                      127  0x0000007f (const dword)  (not used)
PIN_COUNTER_PA9                      128  0x00000080 (const dword)  (not used)
PIN_EVENT_PA4                        129  0x00000081 (const dword)  (not used)
PIN_EVENT_PA5                        130  0x00000082 (const dword)  (not used)
PIN_EVENT_PA6                        131  0x00000083 (const dword)  (not used)
PIN_EVENT_PA7                        132  0x00000084 (const dword)  (not used)
PIN_EVENT_PA8                        133  0x00000085 (const dword)  (not used)
PIN_EVENT_PA9                        134  0x00000086 (const dword)  (not used)
pin_HI                              -113  0xffffff8f (PmmC func) args[1] r=1  (not used)
PIN_INP                                0  0x00000000 (const dword)  (not used)
PIN_INP_HI                             1  0x00000001 (const dword)  (not used)
PIN_INP_LO                             2  0x00000002 (const dword)  (not used)
pin_LO                              -114  0xffffff8e (PmmC func) args[1] r=1  (not used)
PIN_OUT                                3  0x00000003 (const dword)  (not used)
PIN_OUT_OD                             4  0x00000004 (const dword)  (not used)
pin_Pulseout                        -512  0xfffffe00 (PmmC func) args[2] r=1  (not used)
pin_PulseoutB                       -513  0xfffffdff (PmmC func) args[2] r=1  (not used)
pin_PulseoutCount                   -519  0xfffffdf9 (PmmC func) args[4] r=1  (not used)
pin_Read                            -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
pin_Set                             -112  0xffffff90 (PmmC func) args[2] r=1  (not used)
pin_Val                             -115  0xffffff8d (PmmC func) args[2] r=0  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
pInputIndex                          398  0x0000018e (mem) word (global)  (usage 6)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -35  0xffffffdd (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (usage 3)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PTN_BDIAGONAL                      65518  0x0000ffee (const ??? 0)  (not used)
PTN_BRICKS                         65521  0x0000fff1 (const ??? 0)  (not used)
PTN_BS_HORIZONTAL                  65510  0x0000ffe6 (const ??? 0)  (not used)
PTN_BS_VERTICAL                    65509  0x0000ffe5 (const ??? 0)  (not used)
PTN_BSHORIZONTAL                   65516  0x0000ffec (const ??? 0)  (not used)
PTN_BSVERTICAL                     65515  0x0000ffeb (const ??? 0)  (not used)
PTN_CARGONET                       65522  0x0000fff2 (const ??? 0)  (not used)
PTN_CIRCUITS                       65523  0x0000fff3 (const ??? 0)  (not used)
PTN_COBBLESTONES                   65524  0x0000fff4 (const ??? 0)  (not used)
PTN_COURSE_B_DIAGONAL              65512  0x0000ffe8 (const ??? 0)  (not used)
PTN_COURSE_CROSS                   65513  0x0000ffe9 (const ??? 0)  (not used)
PTN_COURSE_DIAGONALCROSS           65514  0x0000ffea (const ??? 0)  (not used)
PTN_COURSE_DOTS                    65508  0x0000ffe4 (const ??? 0)  (not used)
PTN_COURSE_F_DIAGONAL              65511  0x0000ffe7 (const ??? 0)  (not used)
PTN_CROSSES                        65535  0x0000ffff (const ??? 0)  (not used)
PTN_DAISIES                        65525  0x0000fff5 (const ??? 0)  (not used)
PTN_DIZZY                          65526  0x0000fff6 (const ??? 0)  (not used)
PTN_EMPTY                          65504  0x0000ffe0 (const dword)  (not used)
PTN_FDIAGONAL                      65517  0x0000ffed (const ??? 0)  (not used)
PTN_FIELDEFFECT                    65527  0x0000fff7 (const ??? 0)  (not used)
PTN_FINE_CROSS                     65519  0x0000ffef (const ??? 0)  (not used)
PTN_FINE_DIAGONAL_CROSS            65520  0x0000fff0 (const ??? 0)  (not used)
PTN_FINE_DOTS                      65506  0x0000ffe2 (const ??? 0)  (not used)
PTN_KEY                            65528  0x0000fff8 (const ??? 0)  (not used)
PTN_MEDIUM_DOTS                    65507  0x0000ffe3 (const ??? 0)  (not used)
PTN_ROUNDER                        65529  0x0000fff9 (const ??? 0)  (not used)
PTN_SCALES                         65530  0x0000fffa (const ??? 0)  (not used)
PTN_SOLID                          65505  0x0000ffe1 (const ??? 0)  (not used)
PTN_STONE                          65531  0x0000fffb (const ??? 0)  (not used)
PTN_THATCHES                       65532  0x0000fffc (const ??? 0)  (not used)
PTN_TILE                           65533  0x0000fffd (const ??? 0)  (not used)
PTN_WAFFLESREVENGE                 65534  0x0000fffe (const ??? 0)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putchXY                               -3  0xfffffffd (PmmC func) args[3] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putnumXY                             -51  0xffffffcd (PmmC func) args[4] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
putstrCentred                         -5  0xfffffffb (PmmC func) args[3] r=0  (not used)
putstrXY                              -4  0xfffffffc (PmmC func) args[3] r=0  (not used)
PWM_10KHZ                              6  0x00000006 (const dword)  (not used)
PWM_15KHZ                              7  0x00000007 (const dword)  (not used)
PWM_20KHZ                              8  0x00000008 (const dword)  (not used)
PWM_25KHZ                              9  0x00000009 (const dword)  (not used)
PWM_30KHZ                             10  0x0000000a (const dword)  (not used)
PWM_35KHZ                             11  0x0000000b (const dword)  (not used)
PWM_5KHZ                               5  0x00000005 (const dword)  (not used)
PWM_625HZ                              4  0x00000004 (const dword)  (not used)
PWM_BINARY                             3  0x00000003 (const dword)  (not used)
pwm_Init                            -521  0xfffffdf7 (PmmC func) args[3] r=1  (not used)
PWM_OFF                                0  0x00000000 (const dword)  (not used)
PWM_PLAIN                              1  0x00000001 (const dword)  (not used)
PWM_SERVO                              2  0x00000002 (const dword)  (not used)
QEN1_COUNTER_HI                      136  0x00000088 (const dword)  (not used)
QEN1_COUNTER_LO                      135  0x00000087 (const dword)  (not used)
QEN1_DELTA                           137  0x00000089 (const dword)  (not used)
QEN2_COUNTER_HI                      139  0x0000008b (const dword)  (not used)
QEN2_COUNTER_LO                      138  0x0000008a (const dword)  (not used)
QEN2_DELTA                           140  0x0000008c (const dword)  (not used)
Qencoder1                           -515  0xfffffdfd (PmmC func) args[3] r=1  (not used)
Qencoder1Reset                      -517  0xfffffdfb (PmmC func) args[0] r=0  (not used)
Qencoder2                           -516  0xfffffdfc (PmmC func) args[3] r=1  (not used)
Qencoder2Reset                      -518  0xfffffdfa (PmmC func) args[0] r=0  (not used)
RAND                                 -59  0xffffffc5 (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
RANDVAL                              -60  0xffffffc4 (PmmC func) args[2] r=1  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          3162  0x00000c5a (User func) args[2] r=0  (usage 3)
RED                                63488  0x0000f800 (const dword)  (not used)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 2)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                    805  0x00000325rKeyboardRoutines                    805  0x00000325 (mem) word[1] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RULERGAUGE_F_ORIENT_VERT               2  0x00000002 (const dword)  (not used)
RULERGAUGE_F_TICKS_BOTTOM              0  0x00000000 (const dword)  (not used)
RULERGAUGE_F_TICKS_TOP                 1  0x00000001 (const dword)  (not used)
RULERGAUGE_HC                         24  0x00000018 (const dword)  (not used)
RULERGAUGE_height                      6  0x00000006 (const dword)  (not used)
RULERGAUGE_IC                         30  0x0000001e (const dword)  (not used)
RULERGAUGE_LC                         22  0x00000016 (const dword)  (not used)
RULERGAUGE_majorTickSize              16  0x00000010 (const dword)  (not used)
RULERGAUGE_MC                         26  0x0000001a (const dword)  (not used)
RULERGAUGE_medium                     18  0x00000012 (const dword)  (not used)
RULERGAUGE_minorTicks                 12  0x0000000c (const dword)  (not used)
RULERGAUGE_minorTickSize              14  0x0000000e (const dword)  (not used)
RULERGAUGE_options                    32  0x00000020 (const dword)  (not used)
RULERGAUGE_range                       8  0x00000008 (const dword)  (not used)
RULERGAUGE_TC                         28  0x0000001c (const dword)  (not used)
RULERGAUGE_threshold                  20  0x00000014 (const dword)  (not used)
RULERGAUGE_ticks                      10  0x0000000a (const dword)  (not used)
RULERGAUGE_width                       4  0x00000004 (const dword)  (not used)
RULERGAUGE_XP                          0  0x00000000 (const dword)  (not used)
RULERGAUGE_YP                          2  0x00000002 (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SAVE_TO_DISK                           7  0x00000007 (const dword)  (not used)
SCALE_BC                              20  0x00000014 (const dword)  (not used)
SCALE_BR                             N/A         N/A (macro)    0x0002   (not used)
SCALE_CenterGap                       26  0x0000001a (const dword)  (not used)
SCALE_CENTRE                         N/A         N/A (macro)    0x0003   (not used)
SCALE_END_ALIGN                      N/A         N/A (macro)    0x0020   (not used)
SCALE_FONT                            24  0x00000018 (const dword)  (not used)
SCALE_HIDE_ZERO                      N/A         N/A (macro)    0x0000   (not used)
SCALE_HORZ                           N/A         N/A (macro)    0x0000   (not used)
SCALE_length                           4  0x00000004 (const dword)  (not used)
SCALE_max                              8  0x00000008 (const dword)  (not used)
SCALE_min                              6  0x00000006 (const dword)  (not used)
SCALE_NO_END_ALIGN                   N/A         N/A (macro)    0x0000   (not used)
SCALE_NONE                           N/A         N/A (macro)    0x0000   (not used)
SCALE_SHOW_ZERO                      N/A         N/A (macro)    0x0040   (not used)
SCALE_TC                              18  0x00000012 (const dword)  (not used)
SCALE_ticklength                      12  0x0000000c (const dword)  (not used)
SCALE_ticklengthMinor                 16  0x00000010 (const dword)  (not used)
SCALE_ticks                           10  0x0000000a (const dword)  (not used)
SCALE_TICKS_BOTH                     N/A         N/A (macro)    0x000c   (not used)
SCALE_TICKS_BR                       N/A         N/A (macro)    0x0008   (not used)
SCALE_TICKS_NONE                     N/A         N/A (macro)    0x0000   (not used)
SCALE_TICKS_TL                       N/A         N/A (macro)    0x0004   (not used)
SCALE_ticksMinor                      14  0x0000000e (const dword)  (not used)
SCALE_TL                             N/A         N/A (macro)    0x0001   (not used)
SCALE_type                            28  0x0000001c (const dword)  (not used)
SCALE_VERT                           N/A         N/A (macro)    0x0010   (not used)
SCALE_XC                              22  0x00000016 (const dword)  (not used)
SCALE_XP                               0  0x00000000 (const dword)  (not used)
SCALE_YP                               2  0x00000002 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -61  0xffffffc3 (PmmC func) args[1] r=0  (not used)
SendReport                          3319  0x00000cf7 (User func) args[4] r=0  (usage 5)
serin                               -236  0xffffff14 (PmmC func) args[0] r=1  (usage 3)
serin1                              -237  0xffffff13 (PmmC func) args[0] r=1  (not used)
serin2                              -238  0xffffff12 (PmmC func) args[0] r=1  (not used)
serin3                              -239  0xffffff11 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                              -240  0xffffff10 (PmmC func) args[1] r=0  (usage 15)
serout1                             -241  0xffffff0f (PmmC func) args[1] r=0  (not used)
serout2                             -242  0xffffff0e (PmmC func) args[1] r=0  (not used)
serout3                             -243  0xffffff0d (PmmC func) args[1] r=0  (not used)
seroutCS                            3402  0x00000d4a (User func) args[1] r=0  (usage 15)
seroutOcs                           3369  0x00000d29 (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                             -224  0xffffff20 (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (usage 12)
SIN                                  -57  0xffffffc7 (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER5_base_color                    14  0x0000000e (const dword)  (not used)
SLIDER5_F_ORIENT_VERT                N/A         N/A (macro)     0x0001    /* Switch orientation (0 - horizontal, 1 - vertical) */   (not used)
SLIDER5_F_PROGRESSBAR                N/A         N/A (macro)     0x0008    /* Progress Bar mode */   (not used)
SLIDER5_F_TICKS                      N/A         N/A (macro)     0x0002    /* Enable Marker Ticks*/   (not used)
SLIDER5_F_VALUE_IND                  N/A         N/A (macro)     0x0004    /* Enable slider value indicator */   (not used)
SLIDER5_font_c                        38  0x00000026 (const dword)  (not used)
SLIDER5_font_s                        36  0x00000024 (const dword)  (not used)
SLIDER5_knob_f_c_1                    46  0x0000002e (const dword)  (not used)
SLIDER5_knob_f_c_2                    48  0x00000030 (const dword)  (not used)
SLIDER5_knob_f_g                      50  0x00000032 (const dword)  (not used)
SLIDER5_knob_o_c_1                    40  0x00000028 (const dword)  (not used)
SLIDER5_knob_o_c_2                    42  0x0000002a (const dword)  (not used)
SLIDER5_knob_o_g                      44  0x0000002c (const dword)  (not used)
SLIDER5_len                            4  0x00000004 (const dword)  (not used)
SLIDER5_max_val                       12  0x0000000c (const dword)  (not used)
SLIDER5_min_val                       10  0x0000000a (const dword)  (not used)
SLIDER5_num_ticks_L_1                 24  0x00000018 (const dword)  (not used)
SLIDER5_num_ticks_L_2                 26  0x0000001a (const dword)  (not used)
SLIDER5_options                        8  0x00000008 (const dword)  (not used)
SLIDER5_thk                            6  0x00000006 (const dword)  (not used)
SLIDER5_tick_maj_c                    30  0x0000001e (const dword)  (not used)
SLIDER5_tick_maj_l                    28  0x0000001c (const dword)  (not used)
SLIDER5_tick_min_c                    34  0x00000022 (const dword)  (not used)
SLIDER5_tick_min_l                    32  0x00000020 (const dword)  (not used)
SLIDER5_total_tick_B_R                22  0x00000016 (const dword)  (not used)
SLIDER5_total_tick_T_L                20  0x00000014 (const dword)  (not used)
SLIDER5_track_color                   18  0x00000012 (const dword)  (not used)
SLIDER5_track_empty                   16  0x00000010 (const dword)  (not used)
SLIDER5_x_pos                          0  0x00000000 (const dword)  (not used)
SLIDER5_y_pos                          2  0x00000002 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -461  0xfffffe33 (PmmC func) args[1] r=0  (not used)
snd_Continue                        -464  0xfffffe30 (PmmC func) args[0] r=0  (not used)
snd_Freq                            -466  0xfffffe2e (PmmC func) args[2] r=1  (not used)
snd_Pause                           -463  0xfffffe31 (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -460  0xfffffe34 (PmmC func) args[1] r=1  (not used)
snd_Playing                         -465  0xfffffe2f (PmmC func) args[0] r=1  (not used)
snd_Stop                            -462  0xfffffe32 (PmmC func) args[0] r=0  (not used)
snd_Volume                          -459  0xfffffe35 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SPI0                                   0  0x00000000 (const dword)  (not used)
SPI1                                   1  0x00000001 (const dword)  (not used)
SPI16_MODE_0                           8  0x00000008 (const dword)  (not used)
SPI16_MODE_1                           9  0x00000009 (const dword)  (not used)
SPI16_MODE_2                          10  0x0000000a (const dword)  (not used)
SPI16_MODE_3                          11  0x0000000b (const dword)  (not used)
SPI16_MODE_4                          12  0x0000000c (const dword)  (not used)
SPI16_MODE_5                          13  0x0000000d (const dword)  (not used)
SPI16_MODE_6                          14  0x0000000e (const dword)  (not used)
SPI16_MODE_7                          15  0x0000000f (const dword)  (not used)
SPI1_Init                           -349  0xfffffea3 (PmmC func) args[3] r=1  (not used)
SPI1_Read                           -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
spi1_ReadBlock                      -333  0xfffffeb3 (PmmC func) args[2] r=0  (not used)
SPI1_SCK_pin                        -346  0xfffffea6 (PmmC func) args[1] r=1  (not used)
SPI1_SDI_pin                        -343  0xfffffea9 (PmmC func) args[1] r=1  (not used)
SPI1_SDO_pin                        -340  0xfffffeac (PmmC func) args[1] r=1  (not used)
SPI1_Write                          -355  0xfffffe9d (PmmC func) args[1] r=1  (not used)
spi1_WriteBlock                     -359  0xfffffe99 (PmmC func) args[2] r=0  (not used)
SPI2                                   2  0x00000002 (const dword)  (not used)
SPI2_Init                           -350  0xfffffea2 (PmmC func) args[3] r=1  (not used)
SPI2_Read                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
spi2_ReadBlock                      -334  0xfffffeb2 (PmmC func) args[2] r=0  (not used)
SPI2_SCK_pin                        -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
SPI2_SDI_pin                        -344  0xfffffea8 (PmmC func) args[1] r=1  (not used)
SPI2_SDO_pin                        -341  0xfffffeab (PmmC func) args[1] r=1  (not used)
SPI2_Write                          -356  0xfffffe9c (PmmC func) args[1] r=1  (not used)
spi2_WriteBlock                     -360  0xfffffe98 (PmmC func) args[2] r=0  (not used)
SPI3                                   3  0x00000003 (const dword)  (not used)
SPI3_Init                           -351  0xfffffea1 (PmmC func) args[3] r=1  (not used)
SPI3_Read                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
spi3_ReadBlock                      -335  0xfffffeb1 (PmmC func) args[2] r=0  (not used)
SPI3_SCK_pin                        -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
SPI3_SDI_pin                        -345  0xfffffea7 (PmmC func) args[1] r=1  (not used)
SPI3_SDO_pin                        -342  0xfffffeaa (PmmC func) args[1] r=1  (not used)
SPI3_Write                          -357  0xfffffe9b (PmmC func) args[1] r=1  (not used)
spi3_WriteBlock                     -361  0xfffffe97 (PmmC func) args[2] r=0  (not used)
SPI8_MODE_0                            0  0x00000000 (const dword)  (not used)
SPI8_MODE_1                            1  0x00000001 (const dword)  (not used)
SPI8_MODE_2                            2  0x00000002 (const dword)  (not used)
SPI8_MODE_3                            3  0x00000003 (const dword)  (not used)
SPI8_MODE_4                            4  0x00000004 (const dword)  (not used)
SPI8_MODE_5                            5  0x00000005 (const dword)  (not used)
SPI8_MODE_6                            6  0x00000006 (const dword)  (not used)
SPI8_MODE_7                            7  0x00000007 (const dword)  (not used)
SPI_ADDRESS_MODE4                  32768  0x00008000 (const dword)  (not used)
spi_Disable                         -339  0xfffffead (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -336  0xfffffeb0 (PmmC func) args[2] r=0  (not used)
SPI_INIT                               3  0x00000003 (const dword)  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -337  0xfffffeaf (PmmC func) args[0] r=1  (not used)
spi_ReadBlock                       -332  0xfffffeb4 (PmmC func) args[2] r=0  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -338  0xfffffeae (PmmC func) args[1] r=0  (not used)
spi_WriteBlock                      -358  0xfffffe9a (PmmC func) args[2] r=0  (not used)
spiflash_Block32Erase               -622  0xfffffd92 (PmmC func) args[2] r=1  (not used)
spiflash_BlockErase                 -541  0xfffffde3 (PmmC func) args[3] r=0  (not used)
spiflash_BulkErase                  -540  0xfffffde4 (PmmC func) args[2] r=0  (not used)
spiflash_Exec                       -554  0xfffffdd6 (PmmC func) args[3] r=1  (not used)
spiflash_GetC                       -547  0xfffffddd (PmmC func) args[2] r=1  (not used)
spiflash_GetS                       -551  0xfffffdd9 (PmmC func) args[4] r=1  (not used)
spiflash_GetW                       -549  0xfffffddb (PmmC func) args[2] r=1  (not used)
SPIFLASH_HOLDCS                    32768  0x00008000 (const dword)  (not used)
spiflash_ID                         -539  0xfffffde5 (PmmC func) args[2] r=1  (not used)
spiflash_Image                      -545  0xfffffddf (PmmC func) args[4] r=1  (not used)
spiflash_LoadFunction               -552  0xfffffdd8 (PmmC func) args[2] r=1  (not used)
spiflash_LoadGCFImageControl        -632  0xfffffd88 (PmmC func) args[2] r=1  (not used)
spiflash_LoadImageControl           -555  0xfffffdd5 (PmmC func) args[2] r=1  (not used)
spiflash_PlayWAV                    -556  0xfffffdd4 (PmmC func) args[2] r=1  (not used)
spiflash_PutC                       -546  0xfffffdde (PmmC func) args[3] r=0  (not used)
spiflash_PutS                       -550  0xfffffdda (PmmC func) args[3] r=1  (not used)
spiflash_PutW                       -548  0xfffffddc (PmmC func) args[3] r=0  (not used)
spiflash_Read                       -543  0xfffffde1 (PmmC func) args[4] r=1  (not used)
spiflash_ReadByte                   -629  0xfffffd8b (PmmC func) args[3] r=1  (not used)
spiflash_Run                        -553  0xfffffdd7 (PmmC func) args[3] r=1  (not used)
spiflash_Sector4Erase               -623  0xfffffd91 (PmmC func) args[2] r=1  (not used)
spiflash_SetAdd                     -542  0xfffffde2 (PmmC func) args[3] r=0  (not used)
spiflash_SetMode                    -631  0xfffffd89 (PmmC func) args[2] r=0  (not used)
spiflash_SIG                        -538  0xfffffde6 (PmmC func) args[2] r=1  (not used)
spiflash_Write                      -544  0xfffffde0 (PmmC func) args[4] r=1  (not used)
spiflash_WriteByte                  -630  0xfffffd8a (PmmC func) args[3] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -62  0xffffffc2 (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -487  0xfffffe19 (PmmC func) args[3] r=1  (not used)
str_Cat                             -485  0xfffffe1b (PmmC func) args[2] r=1  (not used)
str_CatN                            -486  0xfffffe1a (PmmC func) args[3] r=1  (not used)
str_Copy                            -488  0xfffffe18 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -489  0xfffffe17 (PmmC func) args[3] r=1  (not used)
str_Find                            -481  0xfffffe1f (PmmC func) args[2] r=1  (not used)
str_FindI                           -482  0xfffffe1e (PmmC func) args[2] r=1  (not used)
str_GetByte                         -475  0xfffffe25 (PmmC func) args[1] r=1  (not used)
str_GetC                            -474  0xfffffe26 (PmmC func) args[2] r=1  (not used)
str_GetD                            -471  0xfffffe29 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -473  0xfffffe27 (PmmC func) args[2] r=1  (not used)
str_GetW                            -472  0xfffffe28 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -476  0xfffffe24 (PmmC func) args[1] r=1  (not used)
str_Length                          -483  0xfffffe1d (PmmC func) args[1] r=1  (not used)
str_Match                           -479  0xfffffe21 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -480  0xfffffe20 (PmmC func) args[2] r=1  (not used)
str_Printf                          -484  0xfffffe1c (PmmC func) args[2] r=1  (not used)
str_Ptr                             -470  0xfffffe2a (PmmC func) args[1] r=1  (not used)
str_PutByte                         -477  0xfffffe23 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -478  0xfffffe22 (PmmC func) args[2] r=0  (not used)
strheight                            -14  0xfffffff2 (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                             -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -56  0xffffffc8 (PmmC func) args[2] r=0  (not used)
SWITCH1_cOff                          20  0x00000014 (const dword)  (not used)
SWITCH1_cOn                           18  0x00000012 (const dword)  (not used)
SWITCH1_dshd                          12  0x0000000c (const dword)  (not used)
SWITCH1_F_ORIENT_VERT                N/A         N/A (macro)   0x0001  /* switch orientation (0: Horizontal, 1: Vertical) */   (not used)
SWITCH1_fcOff                         32  0x00000020 (const dword)  (not used)
SWITCH1_fcOn                          30  0x0000001e (const dword)  (not used)
SWITCH1_flg                            8  0x00000008 (const dword)  (not used)
SWITCH1_fnt                           26  0x0000001a (const dword)  (not used)
SWITCH1_fsz                           28  0x0000001c (const dword)  (not used)
SWITCH1_len                            4  0x00000004 (const dword)  (not used)
SWITCH1_lshd                          10  0x0000000a (const dword)  (not used)
SWITCH1_oBz                           14  0x0000000e (const dword)  (not used)
SWITCH1_tBz                           16  0x00000010 (const dword)  (not used)
SWITCH1_thk                            6  0x00000006 (const dword)  (not used)
SWITCH1_tOff                          24  0x00000018 (const dword)  (not used)
SWITCH1_tOn                           22  0x00000016 (const dword)  (not used)
SWITCH1_x                              0  0x00000000 (const dword)  (not used)
SWITCH1_y                              2  0x00000002 (const dword)  (not used)
sys_DeepSleep                       -405  0xfffffe6b (PmmC func) args[1] r=1  (not used)
sys_Driver                          -531  0xfffffded (PmmC func) args[0] r=0  (not used)
sys_ErrorMessage                    -534  0xfffffdea (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -396  0xfffffe74 (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -397  0xfffffe73 (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -398  0xfffffe72 (PmmC func) args[0] r=0  (usage 3)
sys_GetDate                         -401  0xfffffe6f (PmmC func) args[0] r=0  (not used)
sys_GetDateVar                      -528  0xfffffdf0 (PmmC func) args[3] r=0  (not used)
sys_GetTime                         -399  0xfffffe71 (PmmC func) args[0] r=0  (not used)
sys_GetTimer                        -394  0xfffffe76 (PmmC func) args[1] r=1  (not used)
sys_GetTimeVar                      -529  0xfffffdef (PmmC func) args[4] r=0  (not used)
sys_PmmC                            -530  0xfffffdee (PmmC func) args[0] r=0  (not used)
sys_SetDate                         -402  0xfffffe6e (PmmC func) args[3] r=1  (not used)
sys_SetTime                         -400  0xfffffe70 (PmmC func) args[3] r=1  (not used)
sys_SetTimer                        -393  0xfffffe77 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -403  0xfffffe6d (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -368  0xfffffe90 (PmmC func) args[0] r=1  (not used)
sys_T                               -391  0xfffffe79 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -392  0xfffffe78 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 11)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 3)
TB1                                  100  0x00000064 (const dword)  (not used)
TB2                                  101  0x00000065 (const dword)  (not used)
TB3                                  102  0x00000066 (const dword)  (not used)
TB4                                  103  0x00000067 (const dword)  (not used)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 3)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ANGLE                            15  0x0000000f (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 14)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tiAngularMeter                        39  0x00000027 (const dword)  (usage 21)
tiButtonD                             51  0x00000033 (const dword)  (usage 3)
tiButtonE                             52  0x00000034 (const dword)  (usage 3)
tiDial                                55  0x00000037 (const dword)  (usage 3)
tiGauge                               40  0x00000028 (const dword)  (usage 3)
tiLabelB                              41  0x00000029 (const dword)  (usage 6)
tiLed                                 45  0x0000002d (const dword)  (usage 3)
tiLedDigit                            50  0x00000032 (const dword)  (usage 6)
tiLedDigits                           47  0x0000002f (const dword)  (usage 3)
tiLedDigitsH                          38  0x00000026 (const dword)  (usage 10)
tiLinearInput                         67  0x00000043 (const dword)  (usage 9)
tImage                                12  0x0000000c (const dword)  (usage 3)
tiMediaButton                         53  0x00000035 (const dword)  (usage 3)
tiMediaGauge                          43  0x0000002b (const dword)  (usage 3)
tiMediaLed                            46  0x0000002e (const dword)  (usage 3)
tiMediaRotary                         56  0x00000038 (const dword)  (usage 3)
tiMediaSlider                         61  0x0000003d (const dword)  (usage 3)
tiMediaThermometer                    44  0x0000002c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tiNeedle                              48  0x00000030 (const dword)  (usage 3)
tiRotaryInput                         57  0x00000039 (const dword)  (usage 6)
tiRuler                               49  0x00000031 (const dword)  (usage 3)
tiSliderC                             66  0x00000042 (const dword)  (usage 3)
tiSliderD                             65  0x00000041 (const dword)  (usage 3)
tiSliderE                             60  0x0000003c (const dword)  (usage 3)
tiSliderF                             64  0x00000040 (const dword)  (usage 3)
tiSliderG                             63  0x0000003f (const dword)  (usage 3)
tiSliderH                             62  0x0000003e (const dword)  (usage 3)
tiSwitch                              58  0x0000003a (const dword)  (usage 3)
tiSwitchB                             59  0x0000003b (const dword)  (usage 6)
tiToggleInput                         54  0x00000036 (const dword)  (usage 6)
tiUserGauge                           42  0x0000002a (const dword)  (usage 3)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 6)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 3)
tMagicObject                          34  0x00000022 (const dword)  (usage 6)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -1  0xffffffff (PmmC func) args[1] r=0  (not used)
tolower                              -46  0xffffffd2 (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -406  0xfffffe6a (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -408  0xfffffe68 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 6)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 12)
touch_Set                           -407  0xfffffe69 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
touch_TestArea                      -410  0xfffffe66 (PmmC func) args[1] r=1  (not used)
touch_TestBox                       -409  0xfffffe67 (PmmC func) args[1] r=1  (not used)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           394  0x0000018a (mem) word (global)  (usage 14)
TouchXpos                            388  0x00000184 (mem) word (global)  (usage 12)
TouchYpos                            390  0x00000186 (mem) word (global)  (usage 9)
toupper                              -45  0xffffffd3 (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSmartGauge                           35  0x00000023 (const dword)  (usage 6)
tSmartKnob                            37  0x00000025 (const dword)  (usage 6)
tSmartSlider                          36  0x00000024 (const dword)  (usage 6)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 3)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 5)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 8)
txt_Angle                            -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Attributes                       -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -19  0xffffffed (PmmC func) args[1] r=1  (not used)
txt_Bold                             -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Delay                            -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -18  0xffffffee (PmmC func) args[1] r=1  (not used)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontBank                         -52  0xffffffcc (PmmC func) args[2] r=1  (not used)
txt_FontID                           -20  0xffffffec (PmmC func) args[1] r=1  (not used)
txt_Height                           -22  0xffffffea (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Italic                           -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -26  0xffffffe6 (PmmC func) args[1] r=1  (not used)
txt_Set                              -17  0xffffffef (PmmC func) args[2] r=0  (not used)
txt_Underline                        -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Width                            -21  0xffffffeb (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -23  0xffffffe9 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -24  0xffffffe8 (PmmC func) args[1] r=1  (not used)
uadd_3232                            -71  0xffffffb9 (PmmC func) args[3] r=1  (not used)
ucmp_3232                            -75  0xffffffb5 (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                            -74  0xffffffb6 (PmmC func) args[3] r=1  (not used)
ULCD_220RD_DIABLO16_GFX                0  0x00000000 (const ??? 0)  (not used)
umul_1616                            -73  0xffffffb7 (PmmC func) args[3] r=1  (not used)
UNCHECKED                              1  0x00000001 (const dword)  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                         -15  0xfffffff1 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                     UNRESOLVED (User func) args[1] r=0  (not used)
USD_ENABLE                            18  0x00000012 (const dword)  (not used)
usub_3232                            -72  0xffffffb8 (PmmC func) args[3] r=1  (not used)
vIAngularMeter0                        2  0x00000002 (mem) word[10] (global)  (usage 3)
vIAngularMeter1                       46  0x0000002e (mem) word[10] (global)  (usage 3)
vIAngularMeter2                       90  0x0000005a (mem) word[10] (global)  (usage 3)
vIAngularMeter3                      134  0x00000086 (mem) word[10] (global)  (usage 3)
vILedDigits0                          22  0x00000016 (mem) word[12] (global)  (usage 3)
vILedDigits1                          66  0x00000042 (mem) word[12] (global)  (usage 3)
vILedDigits2                         110  0x0000006e (mem) word[12] (global)  (usage 3)
vILedDigits3                         154  0x0000009a (mem) word[12] (global)  (usage 3)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
vObjects                             178  0x000000b2 (mem) word[28] (global)  (usage 15)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (usage 24)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
widget_Add                          -590  0xfffffdb2 (PmmC func) args[3] r=1  (usage 3)
widget_ClearAttributes              -599  0xfffffda9 (PmmC func) args[3] r=1  (usage 3)
widget_Create                       -589  0xfffffdb3 (PmmC func) args[1] r=1  (usage 3)
WIDGET_DECIMALS                       11  0x0000000b (const dword)  (not used)
WIDGET_DELAY                          10  0x0000000a (const dword)  (not used)
widget_Delete                       -591  0xfffffdb1 (PmmC func) args[2] r=1  (not used)
widget_Disable                      -596  0xfffffdac (PmmC func) args[2] r=1  (usage 3)
widget_Enable                       -595  0xfffffdad (PmmC func) args[2] r=1  (usage 3)
WIDGET_F_DISABLED                   2048  0x00000800 (const dword)  (not used)
WIDGET_F_FLASH                      1024  0x00000400 (const dword)  (not used)
WIDGET_F_INITIALISED                8192  0x00002000 (const dword)  (usage 3)
WIDGET_F_INTERNAL                  16384  0x00004000 (const dword)  (not used)
WIDGET_F_RESERVED                    960  0x000003c0 (const dword)  (not used)
WIDGET_F_TOUCH_ENABLE              32768  0x00008000 (const dword)  (usage 3)
WIDGET_F_UNDRAW_ONLY                4096  0x00001000 (const dword)  (not used)
WIDGET_FLAGS                           6  0x00000006 (const dword)  (not used)
WIDGET_FRAMES                         11  0x0000000b (const dword)  (not used)
widget_GetWord                      -593  0xfffffdaf (PmmC func) args[3] r=1  (not used)
WIDGET_HEIGHT                          3  0x00000003 (const dword)  (not used)
WIDGET_HI_WORD                         5  0x00000005 (const dword)  (not used)
WIDGET_LO_WORD                         4  0x00000004 (const dword)  (not used)
WIDGET_RAM_SPACE                      10  0x0000000a (const dword)  (usage 24)
widget_Realloc                      -592  0xfffffdb0 (PmmC func) args[2] r=1  (not used)
widget_SetAttributes                -598  0xfffffdaa (PmmC func) args[3] r=1  (usage 3)
widget_Setposition                  -594  0xfffffdae (PmmC func) args[4] r=1  (not used)
widget_SetWord                      -597  0xfffffdab (PmmC func) args[4] r=1  (not used)
WIDGET_TAG                             7  0x00000007 (const dword)  (not used)
WIDGET_TAG2                            8  0x00000008 (const dword)  (not used)
widget_Touched                      -600  0xfffffda8 (PmmC func) args[2] r=1  (usage 3)
WIDGET_VAL1                            9  0x00000009 (const dword)  (usage 8)
WIDGET_VAL2                           10  0x0000000a (const dword)  (not used)
WIDGET_WIDTH                           2  0x00000002 (const dword)  (not used)
WIDGET_XOTHER                          4  0x00000004 (const dword)  (not used)
WIDGET_XPOS                            0  0x00000000 (const dword)  (not used)
WIDGET_YOTHER                          5  0x00000005 (const dword)  (not used)
WIDGET_YPOS                            1  0x00000001 (const dword)  (not used)
wp                                   644  0x00000284 (mem) word (global)  (usage 21)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_LABEL                           12  0x0000000c (const dword)  (not used)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_STR                              2  0x00000002 (const dword)  (not used)
WRITE_STRU                             3  0x00000003 (const dword)  (not used)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         2988  0x00000bac (User func) args[3] r=0  (usage 13)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
xobj2iobj                            197  0x000000c5xobj2iobj                            197  0x000000c5 (mem) word[8] (member of C:\Users\0xxxa\Desktop\Volvo-CAN-Gauge\4D Systems Display Project\VolvoBoostGauge.4DWork\VolvoBoostGauge.4DGenieS)  (usage 3)
XYLIN_X                                1  0x00000001 (const dword)  (not used)
XYLIN_Y                                0  0x00000000 (const dword)  (not used)
XYROT_EAST                             0  0x00000000 (const dword)  (not used)
XYROT_SOUTH                            1  0x00000001 (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 6)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
